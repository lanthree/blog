<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on Engineers Cool</title>
    <link>https://engineers.cool/</link>
    <description>Recent content in 学习笔记 on Engineers Cool</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 02 Feb 2022 22:15:17 +0800</lastBuildDate><atom:link href="https://engineers.cool/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[WIP] Rocketmq</title>
      <link>https://engineers.cool/posts/architecture/mq/rocketmq/</link>
      <pubDate>Wed, 02 Feb 2022 22:15:17 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/architecture/mq/rocketmq/</guid>
      <description>RocketMQ 架构 Doc
单机存储 Failover </description>
    </item>
    
    <item>
      <title>[WIP] MQ</title>
      <link>https://engineers.cool/posts/architecture/mq/mq_comm/</link>
      <pubDate>Wed, 02 Feb 2022 22:15:10 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/architecture/mq/mq_comm/</guid>
      <description>Why MQ？  异步处理 解耦服务 削峰填谷 顺序消息  术语          Producer    Consumer    Topic    MessageQueue/Partition    Broker    Consumer Group    Rebalance    Message ordering     mq选型    MQ 场景 设计目标 CAP 硬件     kafka       NSQ/RocketMQ        RocketMQ vs.</description>
    </item>
    
    <item>
      <title>[WIP] Kafka</title>
      <link>https://engineers.cool/posts/architecture/mq/kafka/</link>
      <pubDate>Wed, 02 Feb 2022 22:15:02 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/architecture/mq/kafka/</guid>
      <description>设计理念  低延迟：时间复杂度O(1) 高吞吐 水平扩展 顺序性：保证每个partition内的消息顺序传输 多场景：支持离线数据和实时数据  架构 Broker（kafka svr）依赖Zookeeper做：
 元数据管理 领导选举  消费是PULL模型：
   消费模型 优点 缺点     PUSH 延迟低 容易怼挂消费者   PULL 削峰效果好：消费者根据处理能力拉数据； 可以批量PULL = 性能更好 延迟相对高    数据
 Record  key - value timestamp   Topic  逻辑概念 发布-订阅均基于Topic   Partition  一个Topic包含一个或多个Partion  均匀分布在多个Broker - 以达到高并行处理能力   每个Partition物理上对应一个文件夹（每一段对应一个Segment，及一个文件）    Producer</description>
    </item>
    
    <item>
      <title>Redis中的数据结构</title>
      <link>https://engineers.cool/posts/architecture/redis/ds/</link>
      <pubDate>Wed, 02 Feb 2022 22:14:52 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/architecture/redis/ds/</guid>
      <description>键值如何组织 为了实现从键到值的快速访问O(1)，Redis使用hash表来组织键值映射。
全局hash表 hash表中每个桶中的元素（entry）保存了*key和*value，分别指向实际的键和值。这个hash表在内存中，维护了所有的键值对。当hash冲突时，Redis使用拉链法解决冲突：
桶中链表上的元素，在查找时需要O(n)的遍历，当链表过长时，会直接导致元素查找时间过长，效率降低。此时，Redis会对hash表做rehash操作：增加现有的hash桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量。
渐进式rehash 为了使rehash操作更高效，Redis使用两个全局hash表，hash表1和hash表2。最开始，Redis默认使用hash表1，此时hash表2没有被分配空间。rehash时，会给hash表2分配更大的空间，然后将hash表1中的元素rehash到hash表2，最后切换为hash表2并释放hash表1的空间。
当下一次需要rehash时，会重复上面步骤（只是会从hash表2 rehahs到hash表1）。
因为rehash过程可能涉及大量的数据拷贝，一次性完成的话，会造成Redis阻塞，所以Redis采用了渐进式rehash：每处理一个请求时，从hash表1中第一个索引开始，将第一个索引下的所有entry rehash到hash表2，下一次请求时，处理下一个索引。
这里hash表1处理请求时，顺带从头开始rehash内容，而不是rehash当前处理的位置。有个全局变量记录rehash的进度。rehash过程，entry从原表移动到新表，而且rehash时，PUT操作只会在新表生效。
?&amp;gt; 这里需要从代码确认下 TODO
值的数据结构 简单动态字符串 先看它的结构：
struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* 已使用的长度 */ uint32_t alloc; /* buf总可用（包括已使用）长度；不包括sdshdr结构体的大小，以及buf结尾&amp;#39;\0&amp;#39;占用的1字节 */ unsigned char flags; /* 前3bits表示类型, 后5bits未使用 */ char buf[]; }; 为了更高效的（减少浪费）使用内存，sdshdr有不同的类型（用flag标识）：sdshdr8、sdshdr16、sdshdr32、sdshdr64（在生成新字符串时，可以动态的根据字符串长度，生成不同类型的结构）。不同的类型，其len、alloc的数据类型不同，例如sdshdr16对应uint16_t。节省hdr结构空间的同时，约束了buf的最大长度。另外，sds提供的API中，buf结构是二进制安全的，不会因为数组中有&#39;\0&amp;rsquo;而被截断（使用len判断长度）。但是如果用于打印，那就不保证不被截断了。
在代码中，上面结构只是sds的头的定义，sbs本身被定义为typedef char *sds;，相当于在代码中，sdshdr结构中的buf作为sds传递，sds的API为了适配（或者说 是sds为了适配API？），会通过数组下标-1取到flags，再操作：
static inline size_t sdslen(const sds s) { unsigned char flags = s[-1]; switch(flags&amp;amp;SDS_TYPE_MASK) { case SDS_TYPE_5: return SDS_TYPE_5_LEN(flags); case SDS_TYPE_8: return SDS_HDR(8,s)-&amp;gt;len; case SDS_TYPE_16: return SDS_HDR(16,s)-&amp;gt;len; case SDS_TYPE_32: return SDS_HDR(32,s)-&amp;gt;len; case SDS_TYPE_64: return SDS_HDR(64,s)-&amp;gt;len; } return 0; } 双向链表 压缩列表 在列表、散列和有序集合的长度较短或者体积较小的时候，Redis可以选择使用一种名为压缩列表（ziplist）的紧凑存储方式来存储这些结构。压缩列表一块连续的内存空间（可以减少内存碎片），所有元素紧挨在一起，头部有三个字段zlbytes、zltail和zllen，尾部有一个zlend。</description>
    </item>
    
    <item>
      <title>线性代数-基本符号</title>
      <link>https://engineers.cool/posts/math/la_notions/</link>
      <pubDate>Wed, 02 Feb 2022 22:13:59 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/math/la_notions/</guid>
      <description>向量空间 向量空间$V$，由向量$v$组成，一同向量加法与标量乘法，满足一下8个属性（向量空间的公里）：
 交换律：$v+w=w+v \textrm{ for all }v,w\in V$ 结合律：$(u+v)+w=u+(v+w) \textrm{ for all }u,v,w\in V$ 零向量：存在特殊向量（用$0$标识），满足$v+0=v\textrm{ for all } v\in V $ 加法逆元：任意向量$v\in V$都存在一个向量$w\in V$，满足$v+w=0$。这个向量一般用$-v$标识 乘法单位：$1v=v\textrm{ for all }v\in V$ 乘法结合律：$(\alpha\beta)v=\alpha(\beta v)\textrm{ for all }v\in V\textrm{ and all scalars }\alpha,\beta$ 分配律：$\alpha (u+v)=\alpha u+\alpha v\textrm{ for all }u,v\in V\textrm{ and all scalars }\alpha $ 分配律：$(\alpha +\beta )v=\alpha v+\beta v\textrm{ for all }v\in V\textrm{ and all scalars }\alpha,\beta $     符号 释义     $ \mathbb{R}^{n} $ $n$维实数向量空间：由所有的 $ \mathrm{v} = \left( \begin{array}{c} v_{1} \ v_{2} \ \vdots \ v_{n} \end{array} \right) $组成，其中所有$ v $都是实数   $ \mathbb{C}^{n} $ $n$维复数向量空间：由所有的 $ \mathrm{v} = \left( \begin{array}{c} v_{1} \ v_{2} \ \vdots \ v_{n} \end{array} \right) $组成，其中所有$ v $都是复数   $ \mathbb{F}^{n} $ $n$维向量空间，即可以是$\mathbb{R}^{n}$，也可以是$\mathbb{C}^{n}$   $ \mathit{M}{m \times n} $ 或者 $ \mathit{M}{m,n}$ 加法、乘法运算标量   $ \mathit{M}_{m,n}^{\mathbb{R}} $ 分元都是实数的$ \mathit{M}_{m,n} $   $ \mathit{M}_{m,n}^{\mathbb{C}} $ 分元都是复数的$ \mathit{M}_{m,n} $   $ \mathbb{P}^{n}$ n次多项式空间：由素有的 $p(t) = a_{0} + a_{1}t + a_{2}t^{2} + \dots + a_{n}t^n$组成。其中，$t$是自变量，任意$a_{k}\textrm{ for all } 0\leqslant k \leqslant n$都可以是$0$   $A=\left(a_{j, k}\right)_{j=1, k=1}^{m,\ \ \ n} $ $m$行$n$列的矩阵$\left(\begin{array}{cccc} a_{1,1} &amp;amp; a_{1,2} &amp;amp; \ldots &amp;amp; a_{1, n} \ a_{2,1} &amp;amp; a_{2,2} &amp;amp; \ldots &amp;amp; a_{2, n} \ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \ a_{m, 1} &amp;amp; a_{m, 2} &amp;amp; \ldots &amp;amp; a_{m, n}\end{array}\right)$   $A_{j,k}$或者$(A)_{j,k}$ 矩阵$A$的$j$行$k$列的项，$A$也可小写   $A^{T}$ 矩阵$A$的转置，即$(A^{T})j,k = (A)_{k,j}$    线性组合，基  定义 2.</description>
    </item>
    
    <item>
      <title>常用命令</title>
      <link>https://engineers.cool/posts/comm_cmd/</link>
      <pubDate>Wed, 02 Feb 2022 22:13:53 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/comm_cmd/</guid>
      <description>rebase master 开发分支从较旧的master拉出，需要合并master的代码修改
 更新master git checkout master git pull  切换到你的开发分支 git checkout $YOUR_WORK_BRANCH  rebase操作 git rebase master # 若有冲突 解决冲突 然后 git rebase --continue   合并开发分支的多个Commit记录 假设合并最近4次commit
 rebase self git rebase -i HEAD~4  git会罗列最近4次commit的记录，例如 pick u8sa9du pick 19id9is pick fudhf82 pick asdj187 从第二个开始改成s pick u8sa9du s 19id9is s fudhf82 s asdj187 保存退出 git自动打开COMMIT_EDITMSG，修改并保存合并后的commit msg  git log [alias] lg = log --graph --pretty=format:&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr)%Creset&amp;#39; --abbrev-commit --date=relative git 中文路径乱码 git config core.</description>
    </item>
    
    <item>
      <title>[WIP] golang</title>
      <link>https://engineers.cool/posts/stereotype/language/golang/</link>
      <pubDate>Wed, 02 Feb 2022 21:49:17 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/language/golang/</guid>
      <description>流程语句 for // Like a C for for init; condition; post { } // Like a C while for condition { } // Like a C for(;;) for { } 遍历容器
for key, value := range oldMap { newMap[key] = value } // 甚至可以遍历字符串 for pos, char := range &amp;#34;日本\x80語&amp;#34; { // \x80 is an illegal UTF-8 encoding  fmt.Printf(&amp;#34;character %#U starts at byte position %d\n&amp;#34;, char, pos) } // print // character U+65E5 &amp;#39;日&amp;#39; starts at byte position 0 // character U+672C &amp;#39;本&amp;#39; starts at byte position 3 // character U+FFFD &amp;#39;�&amp;#39; starts at byte position 6 // character U+8A9E &amp;#39;語&amp;#39; starts at byte position 7  // 只要key for key := range m { if key.</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43;</title>
      <link>https://engineers.cool/posts/stereotype/language/effective_cpp/</link>
      <pubDate>Wed, 02 Feb 2022 21:49:07 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/language/effective_cpp/</guid>
      <description>条款01：视C++为一个语言联邦  C：C++以C为基础，区块（blocks）、语句（statements）、预处理器（preprocessor）、内置数据类型（built-in data types）、数据（arrays）、指针（pointers）等统统来自C。 Object-Oriented C++：这部分也就是C with Classes所诉求的，classes（包括构造函数和析构函数），封装（encapsulation）、继承（inheritance）、多态（polymorphism）、virtual函数（动态绑定）……等等。 Template C++：这是C++的泛型编程（generic programming）部分，它们带来崭新的编程范型（prpgramming paradigm），也就是所谓的template metaprogramming（TMP，模版元编程）。 STL：STL是个template程序库。  请记住：
 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。  条款02：尽量以const，enum，inline替换#define 以常量替换#define：
 定义常量指针（constant pointers），如果要在头文件内定义一个常量的（不变的）char*-bases字符串，必须写const两次：  const char* const authorName = &amp;quot;Scott Meyers&amp;quot;; 或者写成const std::string authorName(&amp;quot;Scott Meyers&amp;quot;);   class专属常量   // static class 常量声明位于头文件内 class CostEstimate { private: static const double FudgeFactor; ... }; // static class常量定义位于实现文件内 const double CostEstimate::FudgeFactor = 1.35;     enum hack：一个属于枚举类型（enumerated type）的数值可权充ints被使用</description>
    </item>
    
    <item>
      <title>C&#43;&#43;</title>
      <link>https://engineers.cool/posts/stereotype/language/cpp/</link>
      <pubDate>Wed, 02 Feb 2022 21:49:00 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/language/cpp/</guid>
      <description>程序编译过程 编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。
 编译预处理：处理以#开头的指令 编译、优化：将源码.cpp文件翻译成.s汇编代码 汇编：将汇编代码.s翻译成机器指令.o文件 链接：汇编程序生成的木匾文件，即.o文件，并不会立即执行，因为可能会出现：.cpp文件中的函数引用了另一个.cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的。就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的文件  链接分为两种：
 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行文件中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址空间  内存管理 C++内存分区：栈、堆、全局/静态存储区、常量存储区、代码区
 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放 堆：动态申请的内存空间，就是由malloc/new分配的内存块，有程序员控制它的分配和释放，如果程序执行结束没有释放，操作系统会自动回收 全局/静态存储区（.bss段和.data段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在C语言中，为初始化的放在.bss段中，初始化的放在.data段中，C++中不再区分 常量存储区（.data段）：存放的是常量，不允许修改，程序运行结束自动释放 代码区（.text段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里  以上存储区在内容中的分布是如下形式（从低地址到高地址）：.text段 -&amp;gt; .data段 -&amp;gt; 堆 -&amp;gt; unused-&amp;gt; 栈 -&amp;gt; env
栈和堆的区别     栈 堆     申请方式 系统自动分配 程序主动申请   申请后系统响应 分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出 堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该结点从链表中删除，大多数系统中该块空间的首地址存放的本次分配空间的大小，便于释放，将该快空间上的剩余空间再次连接在空闲链表上   地址 栈在内存中是连续的一块空间（向低地址扩展） 堆在内存中的空间（向高地址扩展）是不连续的   申请效率 申请效率高 申请效率低，使用起来方便但是容易产生碎片   存放的内容 局部变量，函数的参数 由程序控制    虚表  虚表  内存对齐 内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://engineers.cool/posts/stereotype/os/intro/</link>
      <pubDate>Wed, 02 Feb 2022 21:48:01 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/os/intro/</guid>
      <description>进程间的通信方式 首先需要理解下面的概念：
 竞态条件：即两个或多个线程同时对一个共享数据进行修改，从而影响程序运行的正确性时，被称为竞态条件（race condition）。 临界区：不仅共享数据会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件，避免方式可以概括为：禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写。而读写共享资源的程序片段，就是临界区。  进程间的通信方式：管道、消息队列、信号量、信号、共享内存、socket套接字
 管道：无名管道、有名管道  无名管道：半双工通信，具有固定的读端和写端；是一个特殊的文件；只用于亲属进程间的通信； 有名管道：和无名管道类似，但可以用于非亲属进程间的通信   消息队列：是一个链接表，存放于系统的内核。消息队列有特定的格式和优先级。具有读权限的进程可以向消息队列读数据，具有写权限的进程刻意向消息队列中添加数据。 信号量：是一个计数器，用于进程间同步与互斥，不记录进程间通信的数据 信号：是一个复杂的通信方式，一帮用于通知接收进程某件事已发生 共享内存：多个进程共享同一个内存区域，不同进程可以及时看到其他进程对数据的修改 socket套接字：用于不同主机间的进程通信  进程和线程的区别 操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。
 一个进程可以包含多个线程；线程在进程下进行 不同进程数据很难共享 同一进程下不同线程间数据很易共享 进程要比线程消耗更多的计算机资源 进程间不会互相影响，一个线程挂掉将导致整个进程挂掉 进程可以扩展到多机，线程最多扩展到多核 线程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等他结束，才能使用这一块内存 - 互斥锁 进程使用的内存地址可以限定使用量 - 信号量  </description>
    </item>
    
    <item>
      <title>AVL树</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/avl/</link>
      <pubDate>Wed, 02 Feb 2022 21:34:05 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/avl/</guid>
      <description>AVL（Adelson-Velskii and Landis）树是带有平衡条件的（balance condition）的二叉查找树：一颗AVL树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。
 高度是指从该节点到叶子节点的最长简单路径边的条数。叶子结点高度为0，NIL结点高度-1。
 可以证明，数高为O(logN)。在假设 删除为懒惰删除 情况下，删除和查找都可以在简单地在O(logN)复杂度内执行。只有插入操作，因为可能会破坏平衡条件，需要做操作，我们称其为旋转（rotation）。在插入以后，只有那些从插入点到根结点的路径上的结点的平衡可能被改变，因此只有这些结点的可能需要平衡，我们沿着这条路径平衡该树。
可以如下，简单定义AVL树：
template &amp;lt;typename Comparable&amp;gt; class AvlTree { struct AvlNode { Comparable element; AvlNode* left; AvlNode* right; int height; AvlNode(const Comparable&amp;amp; that_ele, AvlNode* lt, AvlNode* rt, int h = 0) : element(that_ele), left(lt), right(rt), height(h) {} }; public: AvlTree() : root(nullptr) {} int Height() const { return root == nullptr ? -1 : _height(root); } private: int _height(AvlNode* t) const { return t == nullptr ?</description>
    </item>
    
    <item>
      <title>B&#43;树</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/b&#43;tree/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:58 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/b&#43;tree/</guid>
      <description>定义 基于B树的定义上，有以下修改：
 数据项存储在叶子上 有M个子树的中间节点包含有M个元素（B树中是M-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。（以下以最小为例） 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接 平级结点间通过双向链表相连  一个可能的3阶B+树如下：
单个数据项的查找过程类似于B树，而且磁盘读取次数更稳定（B树因内部结点有数据项，可能提前结束，也可能因为数据项过大，多次磁盘读取才能找其子结点）。
另外，因为B+的平级结点间通过双向链表相连，所以范围查找具有更好的性能（B树需要多次递归），例如下图查找19到37所有值的过程：
插入/删除 插入/删除过程与B树基本一致。（笑）
参考  漫画：什么是B+树？ wikipedia B+树 再有人问你为什么MySQL用B+树做索引，就把这篇文章发给她  </description>
    </item>
    
    <item>
      <title>B树</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/btree/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:56 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/btree/</guid>
      <description>?&amp;gt; 只有基本思想，没有代码。基本摘抄自《数据结构与算法分析 C++描述》。另外，网上一般看到的B树定义中，非叶结点也是会存储数据的，其他基本一样
!&amp;gt; 又看了算法导论，果然这里有问题，B树在中间节点也有数据，参考下面定义中1、2条的补充说明。
假设磁盘上持久化维护着一颗查找树。如果它是普通的查找树，那么最坏情况下需要N次磁盘读取才能找到需要的值。为了减少磁盘访问次数（磁盘访问相对于CPU计算慢很多），AVL树可以把查找次数收敛到logN。为了仅一步减少查找次数，直观上，可以让结点有更多分支，自然就会有更少的高度。一颗完全二叉树的高度大约为$\log_2N$，一颗完全M叉树的高度大约是$\log_MN$。
定义 在二叉查找树中，需要一个键来决定到底取用两个分支中哪一个；在M叉树中，则需要M-1个键。另外，必须制定平衡策略，以保障其不会退化成二叉树，甚至是链表。B树由此设计，原则上B树保证只有少数的磁盘访问（树的高度）。阶为M的B树是一颗具有下列结构特性的树：
 数据项存储在叶子上  看网上也有的定义是非叶子结点也可以存数据项，即没有这一条   非叶结点存储直到M-1个键，以指示搜索的方向；键i代表子树i+1中的最小的键  在网上看到的版本，键i还附带数据，所以键i分割其左右的子树，而不是代表子树i+1中的最小的键   树的根或者是一片树叶，或者其儿子树在2和M之间 除根外，所有非树叶结点的儿子树在$\lceil M/2 \rceil$和M之间 所有的树叶都在相同的深度上，并有$\lceil L/2 \rceil$和L之间个数数据项，稍后描述L的确定  下图是一个5阶B树的一个例子。注意，所有的非树叶的结点的儿子树都在3和5之间（从而有2到4个键）；根可能只有两个儿子。设定L是5，因此每片树叶有3到5个数据项。
每个节点代表一个磁盘区块，我们可以据此选择M和L。例如，一个区块容纳8192字节，假设每个键32字节，M阶B树的结点有M-1个键，即32M-32字节，每个分支是4字节（指向其他内存区块），有M个分支，总共36M-32字节，使不超过8192字节的M最大值是228，因此M可以是228。假设每条记录是256字节，8192/256=32，那么可以选择L为32。那么假设满树的情况下，一层可以容纳32*228=7296个数据项，多一层则多228倍。另外，最坏情况下，树高近似是$\log_{M/2}{N}$
插入 首先设想把57插入到图2的5阶B树中，沿树向下查找，把它作为第5个儿子添加到树叶中：
这是简单情况，因为该树叶还没有装满。现在设想再把55插入树中。观察上图可以发现，55想要插入的树叶已经满了，现在由于其父结点的子结点树不到L，所以可以把该叶子结点分成两片树叶，每片3项：
再设想把40插入图4中，此时必须把包含键35到39而又要包含40的树叶，分成两片。但是，这将使父结点有6个儿子，可是它最多只能有5个儿子。因此，要分裂这个父结点。结果在下图给出：
正如这里的情形所示，当一个非树叶结点分裂时，它的父结点得到一个儿子。当父结点的儿子个数已经达到规定的限度，那么将沿树向上分裂结点，直到找到一个父结点它不需要再分裂，或者到达树根。如果需要分裂树根，那么需要建立一个新的根，这个根以分裂得到的两个树根作为它的两个儿子。这就是准许树根可以有两个儿子特权的原因。这也是B树增加高度的唯一方式。
还有其他方式处理儿子过多的情况。一种方法是在相邻结点有空间时把一个儿子交给该结点领养。相对于直接分裂，这趋向于使得结点更满。
删除 删除结点时，如果被删的项所在的树叶的数据项数已经是最小限度，那么可以通过在邻结点本身没有达到最小值时领养一个邻项来矫正这种状态。如果邻结点也已经是最小值，那么可以合并两个结点形成一个满页。可是，这会使得父结点失去一个儿子。如果失去儿子的结果又引起父结点的儿子数低于最小值，那么使用相同的策略继续进行。这个过程可以一直上行到根。如果根只剩一个儿子，那么删除根，并让这个儿子成为新根。这是B树降低高度的唯一的方式。
参考  《数据结构与算法分析 C++描述》 wikipedia B树  </description>
    </item>
    
    <item>
      <title>红黑树</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/rbtree/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:48 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/rbtree/</guid>
      <description>定义 红黑树是一种具有下列着色性质的二叉查找树：
 每一个结点或者着红色，或者着黑色 根是黑色的 如果一个结点是红色的，那么它的子结点必须是黑色的 从一个几点到一个NULL指针的每一条路径都必须包含相同数目的黑色结点  一个典型的红黑树如下图所示：
插入 首先，考虑插入过程，通常把新项作为树叶放到树种（通过二叉查找树找到合适的位置）。然后考虑着色以及平衡的事情。如果把该项涂成黑色，那么在不做其他调整情况下，会违反性质4。如果把该项涂成红色，在父结点是黑色时，插入操作完成，在父结点是红色时，为了不违反性质3，也需要做调整（着色改变 和 树的旋转）。以下以涂成红色为例讨论。
?&amp;gt; 感觉涂成黑色也可以？只是当前看到的这个没有讨论？
如果新项（着红色）的父结点是黑色，那么插入完成。如果父结点是红色，那么有以下几种情况（每种都有一个镜像对称）需要考虑。（另外以下讨论中，以NULL为黑色）
父结点的兄弟结点是黑色（情况A）  以下讨论都，令X是新插入结点，P是父结点，S是该父结点的兄弟结点（若存在），G是祖父结点
 如果S结点是黑色（例如在图1中插入8），在这种情况下，只有X和P是红色，G是黑色（G如果不是黑色，那么在插入新结点前，就会有红G-&amp;gt;红P的违反性质3的情况）。X、P、G可以行政一个一字型链或者之字形链。下图指出，当P是G的左儿子时，应如何旋转。（还有镜像的P是右儿子的情况，自行想象）
这两种情况下，子树的新根颜色保持不变，不会打破新跟与原子树的父结点的着色约束。另外，新根到A、B、C的叶子上的黑色结点个数保持不变：
 情况1：A为空，不讨论；旋转前，G到B经历1个黑色结点，G到C经历2个黑色结点，旋转后 新根到B、C经历的黑色结点个数一样。 情况2：B1、B2为空，不讨论；旋转前，G到A经历1个黑色结点，G到C经历2个黑色结点，旋转后 新根到A、C经历的黑色结点个数一样。  父结点的兄弟结点是红色（情况B） 如果S结点是红色（例如在图1中插入79），在这种情况下，X、P、S是红色，G是黑色。此时，从跟结点G到A、B、C只有1个黑结点，在旋转后，我们也希望新根到A、B、C的黑色结点树是1（这样才能保证，新根到A、B、C的叶子的黑色结点数一致）。又由于不能有连续的红色结点，所以S和新根需要是红色，而G和X是黑色：
子树是平衡了，但是子树的父结点（R）可能是红色。这时，需要判断结点R的兄弟结点是黑色还是红色，然后重新按上面讨论的 情况A、情况B 处理，直到不再有两个相连的红色结点。
删除 !&amp;gt; “删除”操作的内容，基本来自Ref3。
 要删除的结点，没有子结点，考虑两种情况：  该结点为红色，直接删除即可。 该结点为黑色，则需要进行平衡操作，下图展示了这种需要平衡的情况   要删除的结点，有一个子结点。此时，要删除的结点一定是黑色，其子结点一定是红色。那么可以让删除结点的父结点连接到该子结点，并着黑色。 有两个子结点时。与二叉搜索树一样，把 左子结点的最大值/右子结点的最小值 复制到要删除的结点上，把问题转换为删除被复制的结点，递归此过程，直到把问题转换为情况1 或者 情况2。   以上过程，总体上，是把删除结点的问题，归结为删除最下层子结点的问题：如果该最下层子结点是红色（情况1.1、情况2），那么可以安全的删除。如果该最下层子结点是黑色（情况1.2），那需要做平衡操作。
 平衡操作 约定结点名称如下：
另外，记h(A-&amp;gt;B-&amp;gt;NIL)表示从A走到B再走到某一个NIL结点的黑色结点数量。
接下来考虑如何平衡，首先需要平衡是因为删除了一个黑色结点D（图4），导致其父结点走这个儿子的路径的黑色结点树少了1。那么，为了平衡有两种操作：
 操作1：h(P-&amp;gt;N-&amp;gt;NIL)不变，h(P-&amp;gt;S-&amp;gt;NIL)减1。这种平衡操作会使得h(G-P-&amp;gt;NIL)减1，此时需要将P当成新的N，向上递归处理。 操作2：h(P-&amp;gt;N-&amp;gt;NIL)加1，h(P-&amp;gt;S-&amp;gt;NIL)不变。也就是回复原来的黑色结点数。  N为跟结点 无需平衡操作。
S为黑色 先考虑，S的子结点全黑的情况：
 P为黑：此时可以通过S着红色，来达到操作1，然后以P为新的需平衡结点，向上递归处理。 P为红：此时可以通过交换P、S的着色（P：红-&amp;gt;黑；S：黑-&amp;gt;红），来达到操作2，完成平衡。  再考虑，S的子结点不全黑：</description>
    </item>
    
    <item>
      <title>逆波兰表达式</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/reverse_polish_notation/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:41 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/reverse_polish_notation/</guid>
      <description>/* This implementation does not implement composite functions, functions with variable number of arguments, and unary operators. */ while there are tokens to be read: read a token if the token is: - a number: put it into the output queue - a function: push it onto the operator stack - an operator o1: while ( there is an operator o2 other than the left parenthesis at the top of the operator stack, and (o2 has greater precedence than o1 or they have the same precedence and o1 is left-associative) ): pop o2 from the operator stack into the output queue push o1 onto the operator stack - a left parenthesis (i.</description>
    </item>
    
    <item>
      <title>跳表</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/skip_list/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:29 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/skip_list/</guid>
      <description>简介 跳表（skip list）是一个有序链表的随机化的变体，有附加的、平行的链表。在上层的平行链表指数级的跳过多个元素。为了快速找到正确的部分，搜索从最高层开始，递进地进入底层。加入元素时，先随机选择层高，然后给该层以及所有下层的链表的正确顺序的位置加入该元素。
   算法 平均 最差     Space $O(n)$ $O(n\log n)$   Search $n\log n)$ $O(n)$   Insert $n\log n)$ $O(n)$   Delete $n\log n)$ $O(n)$    实现 数据结构以及初始化 template &amp;lt;typename Comparable, typename Value&amp;gt; class SkipList { struct Node { Comparable key; Value val; Node* forward[MAXLEVEL]; }; public: SkipList() {} private: Node* hdr_; // 链表头  int list_level_; // 链表当前level }; 定义Node为跳表的一个结点（注意，这个结点包含跳表的多个层级的指针forward，最低0，最高MAXLEVEL-1）。下图左边为一个有两个key的跳表的内部结构示意图。第0个结点只用于维护表头，不存储数据；每个结点都有一个forward数组，维护该结点对应层级的下一个结点的地址：例如node1层级是0，那么只有forward[0]有效，并指向了node2；而node2的层级是2，那么forward[0~2]都有效，虽然都指向了nullptr：</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/sort/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:23 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/sort/</guid>
      <description>冒泡排序 时间复杂度O(n^2)
 每次从尾到头（已排序列的尾部）迭代遍历，把相邻数字的更小（大）的元素放前面 重复1步，直到所有元素均排序完毕。  选择排序 时间复杂度O(n^2)
 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置（与之交换位置即可）。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾（同1）。 重复第2步，直到所有元素均排序完毕。  插入排序 插入排序由N-1此插入组成，对于第i趟，把下标i的数字插入到下标0~i的合适位置。时间复杂度O(n^2)。
template &amp;lt;typename Comparable&amp;gt; void insertionSort(std::vector&amp;lt;Comparable&amp;gt;&amp;amp; v) { int j; for (int p = 1; p &amp;lt; v.size(); p++) { Comparable tmp = v[p]; for (j = p; j &amp;gt; 0 &amp;amp;&amp;amp; tmp &amp;lt; v[j - 1]; j--) { v[j] = v[j - 1]; } v[j] = tmp; } } 可能的STL实现：
template &amp;lt;typename Iterator, typename Comparator, typename Object&amp;gt; void _insertionSort(const Iterator&amp;amp; begin, const Iterator&amp;amp; end, Comparator lessThan, const Object&amp;amp; obj) { Iterator j; for (Iterator p = begin + 1; p !</description>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://engineers.cool/posts/stereotype/alg_ds/tp_sort/</link>
      <pubDate>Wed, 02 Feb 2022 21:33:19 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/alg_ds/tp_sort/</guid>
      <description>拓扑排序（topological sort）是对有向无环图的顶点的一种排序。LeetCode 210.课程表II基本是一道模板题，可以参考这道题。
伪代码：
void Graph::toposort() { queue&amp;lt;Vertex&amp;gt; q; int counter = 0; for Vectex &amp;amp;v : vectexes_: if v.indegree == 0: q.push(v); while not q.empty(): Vertex&amp;amp; v = q.top(); q.pop(); v.topoNum = ++counter; for Vectex &amp;amp;w : v.linked: if (--w.indegree == 0): q.push(w); if counter != VECTEX_NUM: throw CycleFoundException(); } </description>
    </item>
    
    <item>
      <title>MySQL事务</title>
      <link>https://engineers.cool/posts/stereotype/database/transaction/</link>
      <pubDate>Wed, 02 Feb 2022 19:51:17 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/database/transaction/</guid>
      <description>基于InnoDB
 数据库事务指的是：满足ACID特性的一组操作。
ACID  原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。  回滚可以用日志实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。   一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据库的读结果都是相同的。 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其他事务是不可见的。 持久性（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中，即使系统发生崩溃，事务执行的结果也不能丢失。  可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复    可以按如下思路理解：
 只有满足一致性，事务的执行结果才是正确的 在无并发的情况下，事务串行执行，隔离型一定能满足。此时只要能满足原子性，就能满足一致性 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性 事务满足持久化，是为了能够应对数据库崩溃的情况  并发一致性问题 在并发情况下，不考虑事务的隔离性，会有以下并发一致性问题：
 读脏数据：T1修改了一个数据，T2随后读取这个数据，如果T1撤销了这次修改，T2读取的就是脏数据 不可重复读：T2读取了一个数据，T1对该数据做了修改，如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同 幻影读：T1读取某个范围的数据，T2在这个范围插入更新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次读取的结果不同  产生并发不一致问题的主要原因，是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。
隔离级别 MySQL支持SQL标准定义的四种隔离级别：
 读未提交（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的 读提交（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。即，一个事务所做的修改在提交之前对其他事务是不可见的 可重复读（REPEATABLE READ）：保证在同一个事务中多次读取同一个数据的结果是一样的 串性化（SERIALIZABLE）：强制事务串性执行  从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是MySQL的默认级别。
事务隔离就是为了解决上面并发一致性的问题，下面展示了4中隔离级别对这三个问题的解决程度：
   隔离级别 脏读 不可重复读 幻读     读未提交 可能 可能 可能   读提交  可能 可能   可重复读   可能   串性化       修改丢失 如果多个线程操作，基于同一个查询结果对表中的记录进行修改，那么后修改的记录会覆盖前面修改的记录，前面的修改丢失掉了，这就叫丢失更新。</description>
    </item>
    
    <item>
      <title>MySQL锁</title>
      <link>https://engineers.cool/posts/stereotype/database/lock/</link>
      <pubDate>Wed, 02 Feb 2022 19:51:10 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/database/lock/</guid>
      <description>锁粒度 MySQL提供了两种封锁粒度：行级锁、表级锁。
应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁冲突的可能就越少，系统的并发程度就越高。锁的各种操作（包括获取锁、释放锁 以及 检查锁状态）都需要消耗资源。
MySQL不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式实现了锁机制，服务器层完全不了解存储引擎中的锁实现：
 InnoDB存储引擎既支持行级锁（row-level locking），也支持表级锁（table-level locking），但默认情况下采用行级锁。 MyISAM和MEMORY存储引擎采用的是表级锁（table-level locking） BDB存储引擎采用的是页面锁（page-level locking），也支持表级锁  不同粒度锁的比较：
 表级锁：开销小，加锁快；不会出现死锁；锁粒度度大，发生冲突的高度最高，并发度最低。  存储引擎通过 总是一次性同时获取所有需要的锁 以及 总是按相同的顺序获取表锁 来避免死锁。   行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突概率最低，并发度也最高。  最大程度的支持并发，同时也带来了最大的锁开销。 在InnoDB中，除单个SQL组成的事物外，锁是逐步获得的，这就决定了在InnoDB中发生死锁是可能的。 行级锁只在存储引擎层实现，而MySQL服务器层没有实现。 行级锁更适合于有大量索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。   页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。  锁类型  基于InnoDB
  共享锁（读锁，S）：其他事务可以读，但不能写。  一个事务对数据对象A加了S锁，可以对A进行读操作，但是不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。   排他锁（写锁，X）：其他事务不能读，也不能写。  一个事务对数据对象A加了X锁，就可以对A进行读取和更新操作。加锁期间其他事务不能对A加任务锁。    为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks）：意向共享锁（IS）、意向排他锁（IX）。IS/IX都是表锁，用来表示一个事务想要在表中的某个数据行上加S锁或X锁。有以下两个规定：
 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或更强的锁 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁  通过引入意向锁，事务T想要对表A加X锁，只需要检测是否有其他事务对表A加了X/IX/IS锁，后两者标识有其他使用给该表中的某行加了X/S锁。
锁的兼容关系
   锁 X IX S IS     X       IX  Y  Y   S   Y Y   IS  Y Y Y     任意IS/IX锁之间都是兼容的，他们只表示想要加锁，而不是真正加锁 S锁只有S锁和IS锁兼容，也就是说事务T想要对数据行加S锁，其他事务可以获得对表或者表中行的S锁  隐式与显示锁定 MySQL的InnoDB存储引擎采用两段锁协议（加锁和解锁分为两个阶段进行），会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同时时刻被释放，这被称为隐式锁定。</description>
    </item>
    
    <item>
      <title>计算机网络</title>
      <link>https://engineers.cool/posts/stereotype/net/cheatsheet/</link>
      <pubDate>Wed, 02 Feb 2022 19:10:18 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/stereotype/net/cheatsheet/</guid>
      <description>封装 &amp;amp;&amp;amp; 分用 当应用程序用TCP传输数据时，数据被送入协议栈中，然后逐个通过每一层直到当作一串比特流送入网络：
更准确地说，上图IP和网络接口层之间传送的单元是分组（packet）。分组既可以是一个IP数据报，也可以是IP数据报的一个片（fragment）。
当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这一过程成为分用（Demultiplexing）：
IP协议  总长度地段是指整个IP数据报的长度，以字节为单位。 标识字段唯一的标识主机发送的每一份数据报。通常每发送一份它的值就会加1。 TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。通常为32或64。当该字段为0时，数据报就被丢弃，并发送ICMP报文通知给源主机。 首部校验和字段是根据IP首部计算的校验和码。ICMP、IGMP、UDP、TCP他们各自的首部中均含有同时覆盖 首部和数据 校验和码。  首先把校验和字段置为0，对首部中每个16bit进行二进制反码求和。    IP分片 物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向哪个数据接口发送数据（选路），并查询该接口获得其MTU。IP把MTP与数据报长度比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。
对于发送端的每份IP数据报来说，其标识字段都包含一个唯一值。该值在数据报分片时被复制每个片中。标志字段用其中一个bit来表示“更多的片”。除了最后一片外，其他每个组成数据报的片都要把该bit置1。片偏移字段指的是该片偏移原始数据报开始出的位置。另外，当数据报被分片后，每个片的总长度值该为该片的长度值。
 标志字段中有一个bit称作“不分片”位。如果该bit为1，IP将不对数据报进行分片，相反把数据报丢弃并发送一个ICMP差错报文。
 IP数据报指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的分片。
IP路由选择 路由表、路由寻址。
ARP &amp;amp;&amp;amp; RARP ICMP UDP UDP是一个简单的瞄向数据报的运输层协议：进程的每个输出操作都正好产生一个UDP数据报，并组装成一份带发送的IP数据报。UDP数据报封装成一份IP数据报：
UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是不保证它们能到达目的地。UDP首部的各字段如下图所示：
 IP数据报长度指的是数据报全长，该字段值最小为8字节（数据长度为0）。 UDP和TCP在首部都有覆盖它们首部和数据的检验和。UDP是可选的，TCP是必须的。  UDP校验和的计算方式跟IP首部检验和的计算方式类似（16bit的二进制反码和）。但是有2点不同：
 UDP数据报的长度可以为奇数字节，在计算前会在最后补充字节0对齐 计算时包含一个12字节长的伪首部。  DNS TCP  TCP将用户数据打包构成报文段：它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的检验和。
 TCP提供一种面向连接的，可靠的字节流服务。TCP通过下列方式来提供可靠性：
 应用数据被分割成TCP认为最适合发送的数据块。 当TCP发送一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。 TCP将保持它首部和数据的检验和。如果手段的段校验和有差错，TCP将丢低这个报文段和不确认收到此报文段（希望发端超时重发）。 TCP将对收到的数据进行重新排序（到达失序），将收到的数据以正确的顺序交给应用层。 TCP的接收端丢弃重复的数据。 提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一段发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区益处。  插口对（socket pair）包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组，可唯一确定互联网络中每个TCP连接的双方。
当建立一个新的连接时，SYN标志变1，序号字段包含有这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1（每个传输的字节都被计数）。
确认序号包含发送确认的一端所希望收到的下一个序号。只有ACK标志为1时确认序号字段才有效。另外，连接的每一端必须保持每个方向上的传输数据序号（全双工）。
TCP首部中有6个标志bit，它们中的多个可同时被设置为1：
 URG：紧急指针（urgent pointer）有效 ACK：确认序号有效 PSH：接收方应该尽快将这报文段交给应用层 RST：重建连接 SYN：同步序号用来发起一个连接 FIN：发端完成发送任务  TCP的流量控制有连接的每一端通过声明的窗口大小来提供。TCP检验和的计算和UDP检验和计算相似。</description>
    </item>
    
    <item>
      <title>Raft</title>
      <link>https://engineers.cool/posts/distribute-system/papers-read/raft/</link>
      <pubDate>Wed, 02 Feb 2022 09:51:01 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/distribute-system/papers-read/raft/</guid>
      <description>In Search of an Understandable Consensus Algorithm
 摘要  原论文在这里
 Raft是一种用于管理副本日志的共识算法（Consensus Algorithm）。它提供一个等同于(multi-)Paxos的结果，效率跟Paxos一样，但是组织结构不同于Paxos；这令Raft比Paxos更利于理解，对于建设实际系统提供了更好的基础。为了增加可理解性，Raft分离了共识的关键元素，例如，leader选举、日志副本和安全(safety)，他主张更强的一致性，来减少必须要考虑的状态的数量。一项用户研究的结果表明，对于学生来说，Raft比Paxos更容易学习。Raft还包括一个改变集群中成员关系的新机制，它使用重叠的多数来保证安全。
1. 介绍 共识算法允许一批机器像 能够经受其部分成员故障的一致的群体 一样工作。因此，在建设可靠的大型软件系统中，共识算法承担着关键角色。在过去十年中，Paxos算法统治着共识算法的讨论：大部分共识的实现都是基于Paxos或受其影响，Paxos也变成教导学生共识算法的重要工具。
不幸的是，尽管人们极力尝试让它平易近人，Paxos还是非常难懂。此外，为了支持实际系统，它的架构需要复杂的变化。结果，系统的构建者和学生都在与Paxos作斗争。
在亲自跟Paxos斗争之后，我们开始寻找一个新的 能为系统构建和教育提供更好基础 共识算法。我们的方法不同寻常，因为我们的首要目标是可理解性：我们是否可以为实际系统定义一个共识算法，并用一种明显比Paxos容易学习的方式描述它？另外，我们希望算法能够促进直觉的发展，这对于系统构建者来说是必不可少的。重要的不仅是算法是否有效，还在于它能明显地被理解为什么有效。
这项工作的成果是一个称为Raft的共识算法。在设计Raft时，我们应用特殊的技术来提高可理解性，包括分解（Raft分解leader选举、日志副本和安全）和减少状态空间（相对于Paxos，Raft减少了非确定性程度和服务器之间保持一致性的方法）。一项涉及2所大学43名学生的用户研究表明，Raft明显比Paxos容易理解：在学习完两个算法后，其中33名学习对Raft问题的回答比Paxos问题要好。
Raft在许多方面与现有的共识算法相似（最明显的是，Oki和Liskov的Viewstamped Replication），但是特有几个新颖的特性：
 强leader（strong leader）：相对于其他共识算法，Raft使用一种更强形式的leader模式。例如，日志条目（log entries）只能从leader向其他server流动。这减缓了备份日志的管理，也让Raft更容易理解。 leader选举（leader election）：Raft使用随机的timer来选举leader。这仅仅在任何共识算法都需要的heartbeat上增加一点点机制，但是简单快速地解决了冲突问题。 成员关系变化（membership changes）：Raft用于更改集群中的服务器集的机制使用了一种新的联合共识（joint consensus）方法，在这种方法中，两种不同配置的大部分服务 在转换期间 重叠（overlap）。这允许集群在配置更改期间继续正常运行。  我们相信，无论出于教育目的 还是最为实现基础，Raft都比Paxos更优秀。Raft比其他算法都简单，可理解性更强；描述完整，足以满足实际系统的需要；它有几个开源实现，被多家公司使用；其安全特性已得到正式规定和证明； 其效率可与其他算法相媲美。
论文的其余部分介绍了副本状态机（replicated state machine）问题（第2节），讨论Paxos的优缺点（第 3节），描述我们实现可理解性的一般方法（第4节），介绍Raft共识算法（第5-8节），评估Raft（第9节），并讨论相关工作（第10节）。
2. 副本状态机 共识算法通常出现在副本状态机（replicated state machine）的上下文中。在这个方法中，一组server的状态机计算相同状态的相同副本，能在其中一些server故障时继续服务。副本状态机用于在分布式系统中解决许多容错问题。举个例子，拥有单集群master的大型系统 例如 GFS、HDFS、RAMCloud，通常用一个分离的副本状态机来管理leader选举和存储配置信息，达到leader crash还能继续服务的目的。副本状态机的例子包括Chubby、ZooKeeper。
如图1所示，副本状态机通常用副本日志实现。每个server存储包含一系列命令的日志，他们的状态机按日志顺序执行。每个日志包含同样顺序的同样命令，所以每个状态机按同样的命令处理同样的命令。因此，这些状态机是确定的，每个计算同样的状态，输出同样的序列。
保持副本日志的一致性就是共识算法的工作。server上的共识模块从多个client接收不同命令，并把命令添加到它的日志中。它与其他server上的共识模块交流，来确保，即使某些server故障，每个日志最终包含相同顺序的同样命令。一旦命令被合适的备份，每个server的状态机按日志顺序处理这些命令，输出被返回给那些client。最终结果，server看上去形成一个单一的、高可用的状态机。
实际系统的共识算法通常具有以下特性：
 算法确保在所有非拜占庭（non-Byzantine）条件下的安全性（safety，从不返回不正确的结果）,包括网络延迟、分区（partitions）、丢包、重入和重排序（reordering）等。  拜占庭问题。简单解释是：有间谍（叛徒），跟不同/相同对象返回的决策结果不一致。   只要任意大多数server可执行且能其他server/client通信，算法就是功能完好的（可用的）。因此，通常5台server的集群，可以容忍任意2台server故障。server假设的故障是停止工作；他们也许稍后会从稳定存储中恢复状态并重新加入集群。 算法不能依赖timing来确保日志的一致性：最坏情况下，时钟错误和极端的消息延迟能导致可用性问题。 通常情况下，只要集群的大多数成员响应了一轮RPC，命令就可以完成；少数速度较慢的服务器需要不影响整个系统的性能。  3. Paxos的问题是什么？ 在过去十年中，Leslit Lamport的Paxos协议几乎已经成为共识的同义词：它是在课堂中最常教授的协议，大多数共识的实现都将其作为起点。Paxos首先定义了一种 能够就单个决定达成一致 的协议，例如单个日志条目备份。我们称这个子集为single-decree Paxos。Paxos然后组合该协议的多个实例，以促进一系列决策，如日志(multi-Paxos)。Paxos确保安全性和活性，并且支持集群成员的更改。其正确性已被证明，在通常情况下是有效的。</description>
    </item>
    
    <item>
      <title>MapReduce</title>
      <link>https://engineers.cool/posts/distribute-system/papers-read/mapreduce/</link>
      <pubDate>Wed, 02 Feb 2022 09:50:55 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/distribute-system/papers-read/mapreduce/</guid>
      <description>Simplified Data Processing on Large Clusters.
 1. 介绍 原论文介绍就不翻译了，本文是从这里阅读原文时，为了更好的记忆消化，而做的个人翻译。
2. 编程模型 计算过程以一组key/values对为输入，然后产出一组key/values对输出。MapReduce库的用户使用两个函数表达整个计算过程：Map和Reduce。
 Map以一个key/values对为输入，然后生成一组key/values对中间数据。MapReduce库会统一组织所有Map生成的中间数据，把相同key（say as I）的所有values，传递给Reduce函数。 Reduce以一个key（say as I）以及相关的一组中间数据为入参。把这组数据合并为更小的集合。通常每次Reduce调用只返回0或1个值。中间数据通过一个迭代器传递给Reduce。这使得我们可以处理放不下内存的数据量。  2.1 举例 以统计超大文档集合中各个单词数量的问题为例。用户编写的代码如下（伪码）：
map(String key, String value): // key: 文档名 // value: 文档内容 for each word w in value: EmitIntermedite(w, &amp;quot;1&amp;quot;); reduce(String key, Iterator values): // key: 一个单词 // values：一系列的counts int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); map函数对每一个单词emit一个出现次数的关联数据（该例子中就是1）。reduce函数把这个单词所有emit的数据，加和在一起。
2.2 参数类型 虽然伪代码例子中的入参出参的类型是String，但是从逻辑上看，两个函数的参数类型具有关联性：
map(k1,v1) --------→ list(k2,v2) reduce(k2,list(v2)) --→ list(v2) 也就是说，入参的类型跟出参不是同一领域，中间数据跟出参是同一领域。</description>
    </item>
    
    <item>
      <title>The Google File System</title>
      <link>https://engineers.cool/posts/distribute-system/papers-read/gfs/</link>
      <pubDate>Wed, 02 Feb 2022 09:50:48 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/distribute-system/papers-read/gfs/</guid>
      <description>摘要  原论文在这里
 我们设计并实现了谷歌文件系统（the Google File System, GFS）,一个为大型分布式数据密集型应用设计的可扩展的分布式的文件系统。他运行在不昂贵的商用硬件上，有容错能力，能为大量client提供整体地高性能服务。
与之前设计的分布式文件系统拥有许多相同目标的同时，我们的设计由 应用的负载 和 技术环境的现状与可预见的未来 驱动，这也导致与早先的文件系统的基本假设由显著背离。这使得我们复查历史决策并探讨不同的基本设计要点。
GFS很成功的满足了我们的存储需求。他作为存储平台在Google内部广泛部署，供需要处理或生成大数据集的在线服务、研发工作使用。当前最大的集群，由数千台机器&amp;amp;&amp;amp;磁盘组成，提供数百TB的存储能力，并提供数百的并发访问能力。
在这篇论文中，我们呈现支持分布式应用的分布式文件系统的接口设计，讨论设计的方方面面，并从微观基准和实际使用中报告测量结果。
1. 介绍 我们设计并实现了谷歌文件系统（the Google File System, GFS）,来满足Google数据处理快速增长的需求。与之前设计的分布式文件系统拥有许多相同目标，例如 性能、可扩展性、可靠性、可用性。然而，它的设计由 应用的负载 和 技术环境的现状与可预见的未来 驱动，这也导致与早先的文件系统的基本假设由显著背离。这使得我们复查历史决策并探讨不同的基本设计要点。
第一，系统构成组件的故障被认定是正常情况 而不是异常情况。这个文件系统由数百甚至数千台不昂贵的商品存储设备组成，并被数量可观的客户端访问。组件的数量和质量基本上确认在有限的时间内一些组件一定无法工作，而且一些组件无法从故障中恢复。我已经遇到过的问题有：应用程序bug、操作系统bug、人员操作错误、磁盘故障、内存故障、链接故障、网络故障、供电故障等。因此，持续监控、错误侦测、容错、自动恢复都必须是系统支持的能力。
第二，传统标准下文件是巨大的。几GB大小的文件很常见。每个文件包含许多应用对象，例如web文档。常常，我们处理由数十亿对象组成的快速增长的数据集时，即使文件系统本可以支持，管理数十亿大约KB大小的文件是很笨重的。因此，必须重新考虑 设计假设和参数，例如 I/O 操作和块大小。
第三，大部分文件修改是追加内容，很少是修改原内容。文件内的随机写更是基本没有。一旦写入，文件仅仅用来读，并且常常是顺序读。许多不同的数据都有这种特性。一些可能构成大型仓库供数据分析程序扫描。一些也许是在线程序持续生成的数据流。一些也许是归档数据。一些也许是一台数据生成要立即或以后被另外机器处理的临时数据。在这种大型文件访问模型下，性能优化的重点是追加写和原子保障，而在客户端缓存数据块完全没用。
第四，协同设计应用程序和文件系统API可以提高我们的灵活性，从而使整个系统受益。例如，放宽GFS的一致性模型来极大的简化文件系统，而不会给应用程序带来沉重的负担。我们引入了原子追加写操作，让多个客户端无需互相通信就可以并发的向一个文件追加内容。详细内容会在论文后续中讨论。
为了不同的目的，已经部署了多套GFS集群。最大的有超过1000个存储结点，超过300TB磁盘容量，并连续被不同机器的数百个client频繁访问。
2. 设计概览 2.1 基本假设 在位我们需求设计文件系统时，我们一直被既有挑战又有机遇的假设所引导。我们前面提到了一些关键的观察结果，现在更详细的列出我们的列假设。
 系统有总会故障的许多廉价的产品零部件组成。他必须持续不断的监控自己，检测、容忍并从组件故障中快速恢复。 系统存储适量的大文件。我们预估预估会有几百万个文件，每个文件通常100MB或者更大。几GB大小的文件是通常情况，需要被有效管理。小文件必须支持，但我们不需要针对他们做优化。 工作负荷主要由两种读组成：大文件顺序读，小文件随机读。在大文件顺序读中，每次操作通常读取几百KB或1MB或更多。来自同一客户端的连续操作通常会读取文件的连续区域。小文件随机读，通常在文件的任意位置读几KB。注重性能的应用程序通常对他们的小文件度进行批处理和排序，以便在文件中稳步前进，而不是来回读取。 工作负荷也会有许多大文件追加数据的顺序写。通常来说，操作大小跟读取差不多。一旦写好，数据基本不再修改。小文件的随机写也支持，但是不需要很高效。 系统必须为多客户端同时写同一文件做良好的设计与有效的实现。我们的文件常常用做 生产-消费 队列，或多路合并。多台机器的几百个客户端，会并发的向一个文件写。具有最小同步开销的原子性，必不可少。文件也许稍后读取，消费者也可以立即读取文件内容。 持续高带宽比低延迟更重要。我们的大多数目标应用程序都重视以高速率处理大量数据，而很少有对单个读取或写入的响应时间做严格要求。  2.2 接口 GFS提供了一套熟悉的系统接口，虽然并没有实现类似POSIX的标准API。文件又目录层级组织，并由路径名标识。我们支持了create、delete、open、close、read和write文件的一般接口。
此外，GFS有快照（snapshot）和记录追加（record append）操作。快照可以低成本的给文件或目录创建副本。记录追加可以在保证原子性的同时，支持多个独立客户端并发向同一个文件追加内容。这在实现多路合并 和 支持无需额外锁的多客户端快速追加内容的生产-消费队列。这种类型的文件，在建设分布式系统中非常有用。快照和记录追加会在3.4节和3.3节分别讨论。
2.3 架构 如图1所示，一个GFS集群，由一个master和多个数据服务器（chunkserver）组成，并被多个客户端访问。每一台设备都是商品Linux机器，运行着用户级服务器进程。只要机器资源允许，在同一台机器上运行chunkserver和客户端是OK的，并且由于运行不稳定的应用程序代码导致的地可靠性是可接受的。
文件被分为固定大小的chunk。每个chunk在被创建时都会被master分配一个全局的不可变的64bit的chunk handle。chunkserver在本地磁盘以Linux文件的形式存储chunk，并读取由 chunk handle和字节范围 标识 的chunk数据。为了可靠性，每个chunk在多台chunkserver做了副本。默认情况下，我们存储3份，用户也可以在不通的文件名字空间的区域指定不同级别的副本。
master维护所有文件系统的元数据。包括 名字空间、访问控制信息、文件到chunk的映射、chunk当前的位置等。它也管理系统纬度的活动，例如chunk租约管理、孤儿chunk的垃圾回收、chunkserver间的chunk迁移。master周期性的以HeartBeat信息的形式跟每个chunkserver通信，分发指令以及收集状态。</description>
    </item>
    
    <item>
      <title>CAP</title>
      <link>https://engineers.cool/posts/distribute-system/cap/</link>
      <pubDate>Wed, 02 Feb 2022 09:36:38 +0800</pubDate>
      
      <guid>https://engineers.cool/posts/distribute-system/cap/</guid>
      <description>CAP理论1 在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer&amp;rsquo;s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：
 一致性（Consistency） （等同于所有节点访问同一份最新的数据副本） 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据） 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）  根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项[4]。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。
数据一致性2 分布式系统中，一般为了容错性，会引入多副本，多个副本间需要同步状态，就引入了一致性问题。一致性问题包含数据一致性和事务一致性（指ACID）。
DDIA第五章更详细的给出了集中供暖需要备份数据的情况：
 为了保持需要地理上离用户更近（降低延迟） 为了允许系统在某些部分故障时仍然能持续工作（增加可用性） 为了扩充读服务的机器数量（增加读性能）  其实只有两类数据一致性，强一致性与弱一致性。强一致性也叫做线性一致性，除此以外，所有其他的一致性都是弱一致性的特殊情况。所谓强一致性，即复制是同步的，弱一致性，即复制是异步的。
强一致性 强一致性可以保证从库有与主库一致的数据。如果主库突然宕机，我们仍可以保证数据完整。但如果从库宕机或网络阻塞，主库就无法完成写入操作。
在实践中，我们通常使一个从库是同步的，而其他的则是异步的。如果这个同步的从库出现问题，则使另一个异步从库同步。这可以确保永远有两个节点拥有完整数据：主库和同步从库。 这种配置称为半同步。
弱一致性 最终一致 容忍节点故障只是需要复制的一个原因。另两个原因是可扩展性和降低延迟。
单领导者的主从复制算法要求所有写入都由单个节点处理，但只读查询可以由任何节点处理。对于读多写少的场景，我们往往创建很多从库，并将读请求分散到所有的从库上去。这样能减小主库的负载，并允许向最近的节点发送读请求。当然这只适用于异步复制——如果尝试同步复制，则单个节点故障将使整个系统无法写入。
当用户从异步从库读取时，如果此异步从库落后，他可能会看到过时的信息。这种不一致只是一个暂时的状态——如果等待一段时间，从库最终会赶上并与主库保持一致。这称为最终一致性。
最终两个字用得很微妙，因为从写入主库到反映至从库之间的延迟，可能仅仅是几分之一秒，也可能是几个小时。
读写一致（读己之写一致） 手机刷虎扑的时候经常遇到，回复某人的帖子然后想马上查看，但我刚提交的回复可能尚未到达从库，看起来好像是刚提交的数据丢失了，很不爽。
在这种情况下，我们需要读写一致性，也称为读己之写一致性。它可以保证，如果用户刷新页面，他们总会看到自己刚提交的任何更新。它不会对其他用户的写入做出承诺，其他用户的更新可能稍等才会看到，但它保证用户自己提交的数据能马上被自己看到。
如何实现读写一致性？
最简单的方案，对于某些特定的内容，都从主库读。举个例子，知乎个人主页信息只能由用户本人编辑，而不能由其他人编辑。因此，永远从主库读取用户自己的个人主页，从从库读取其他用户的个人主页。
如果应用中的大部分内容都可能被用户编辑，那这种方法就没用了。在这种情况下可以使用其他标准来决定是否从主库读取，例如可以记录每个用户最后一次写入主库的时间，一分钟内都从主库读，同时监控从库的最后同步时间，任何超过一分钟没有更新的从库不响应查询。
还有一种更好的方法是，客户端可以在本地记住最近一次写入的时间戳，发起请求时带着此时间戳。从库提供任何查询服务前，需确保该时间戳前的变更都已经同步到了本从库中。如果当前从库不够新，则可以从另一个从库读，或者等待从库追赶上来。
单调读 用户从某从库查询到了一条记录，再次刷新后发现此记录不见了，就像遇到时光倒流。如果用户从不同从库进行多次读取，就可能发生这种情况。
单调读可以保证这种异常不会发生。单调读意味着如果一个用户进行多次读取时，绝对不会遇到时光倒流，即如果先前读取到较新的数据，后续读取不会得到更旧的数据。单调读比强一致性更弱，比最终一致性更强。
实现单调读取的一种方式是确保每个用户总是从同一个节点进行读取（不同的用户可以从不同的节点读取），比如可以基于用户ID的哈希值来选择节点，而不是随机选择节点。
因果一致性 在本文中阐述因果一致性可能并不是一个很好的时机，因为它往往发生在分区（也称为分片）的分布式数据库中。
分区后，每个节点并不包含全部数据。不同的节点独立运行，因此不存在全局写入顺序。如果用户A提交一个问题，用户B提交了回答。问题写入了节点A，回答写入了节点B。因为同步延迟，发起查询的用户可能会先看到回答，再看到问题。
为了防止这种异常，需要另一种类型的保证：因果一致性。 即如果一系列写入按某个逻辑顺序发生，那么任何人读取这些写入时，会看见它们以正确的逻辑顺序出现。
这是一个听起来简单，实际却很难解决的问题。一种方案是应用保证将问题和对应的回答写入相同的分区。但并不是所有的数据都能如此轻易地判断因果依赖关系。如果有兴趣可以搜索向量时钟深入此问题。
  CAP定理&amp;#160;&amp;#x21a9;&amp;#xfe0e;
 通俗易懂 强一致性、弱一致性、最终一致性、读写一致性、单调读、因果一致性 的区别与联系&amp;#160;&amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>118. 杨辉三角</title>
      <link>https://engineers.cool/leetcode/leetcode/118/</link>
      <pubDate>Thu, 14 Oct 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/118/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; ret.push_back({1}); int nowRow = 0; while (++nowRow &amp;lt; numRows) { ret.push_back({1}); for (int i = 0; i &amp;lt; ret[nowRow-1].size()-1; ++i) { ret[nowRow].push_back(ret[nowRow-1][i] + ret[nowRow-1][i+1]); } ret[nowRow].push_back(1); } return ret; } }; </description>
    </item>
    
    <item>
      <title>125. 验证回文串</title>
      <link>https://engineers.cool/leetcode/leetcode/125/</link>
      <pubDate>Fri, 08 Oct 2021 10:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/125/</guid>
      <description>原题链接
class Solution { public: bool isPalindrome(string s) { int l = 0, r = s.length()-1; while (l &amp;lt; r) { char lc = _get_next(s, l, 1); if (lc == &amp;#39; &amp;#39;) { return true; } char lr = _get_next(s, r, -1); if (lc != lr) { return false; } } return true; } private: char _get_next(const string&amp;amp; s, int&amp;amp; idx, int dir) { char ret_c = &amp;#39; &amp;#39;; while (true) { if (idx &amp;lt; 0 || idx &amp;gt;= s.</description>
    </item>
    
    <item>
      <title>124. 二叉树中的最大路径和</title>
      <link>https://engineers.cool/leetcode/leetcode/124/</link>
      <pubDate>Fri, 08 Oct 2021 10:29:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/124/</guid>
      <description>原题链接
递归遍历，返回包含该结点的（可能包含该结点左子树或右子树）的子树最大值，遍历过程中更新答案值：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int max_v_ = INT_MIN; public: int maxPathSum(TreeNode* root) { _calc_max_v(root); return max_v_; } private: int _calc_max_v(TreeNode* node) { if (node == nullptr) { return 0; } int left_max = max(_calc_max_v(node-&amp;gt;left), 0); int right_max = max(_calc_max_v(node-&amp;gt;right), 0); max_v_ = max(max_v_, node-&amp;gt;val + left_max + right_max); return node-&amp;gt;val + max(left_max, right_max); } }; </description>
    </item>
    
    <item>
      <title>122. 买卖股票的最佳时机 II</title>
      <link>https://engineers.cool/leetcode/leetcode/122/</link>
      <pubDate>Fri, 08 Oct 2021 10:28:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/122/</guid>
      <description>原题链接
2纬DP：
 dp[i][0]：表示i时没有股票，即i-1时有股票 i时卖出，或 i-1时没有股票 i时也没有操作 dp[i][1]：表示i时有股票，即i-1时有没股票 i时买入，或 i-1时有股票 i时也没有操作  class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size(), vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &amp;lt; prices.size(); ++i) { dp[i][0] = max(dp[i-1][1] + prices[i], dp[i-1][0]); dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]); } return dp[prices.size()-1][0]; } }; 因为只用到上一轮迭代的dp值，故可以优化空间复杂度：
class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int dp_0 = 0; int dp_1 = -prices[0]; for (int i = 1; i &amp;lt; prices.</description>
    </item>
    
    <item>
      <title>121. 买卖股票的最佳时机</title>
      <link>https://engineers.cool/leetcode/leetcode/121/</link>
      <pubDate>Fri, 08 Oct 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/121/</guid>
      <description>原题链接
class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int ret = 0; int min_price = INT_MAX; for (int price : prices) { if (price &amp;lt; min_price) { min_price = price; continue; } ret = max(ret, price-min_price); } return ret; } }; </description>
    </item>
    
    <item>
      <title>128. 最长连续序列</title>
      <link>https://engineers.cool/leetcode/leetcode/128/</link>
      <pubDate>Tue, 28 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/128/</guid>
      <description>原题链接
先把所有数字放到unordered_set（hash集合）中，这样可以：
 去重 能够O(1)的判断某个数字是否在集合中  然后对于每个数字num，如果num-1不在集合中，则依次判断比num大的数字是否在集合中，并更新结果：
class Solution { unordered_map&amp;lt;int, int&amp;gt; nums_color; public: int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; nums_set; for (int num : nums) { nums_set.insert(num); } int max_len = 0; for (int num : nums_set) { if (nums_set.count(num-1)) { continue; } int current_num = num; int current_len = 1; while (nums_set.count(current_num+1)) { current_num += 1; current_len += 1; } max_len = max(max_len, current_len); } return max_len; } }; 另外还可以使用并查集的思路：</description>
    </item>
    
    <item>
      <title>127. 单词接龙</title>
      <link>https://engineers.cool/leetcode/leetcode/127/</link>
      <pubDate>Tue, 28 Sep 2021 10:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/127/</guid>
      <description>原题链接
构造一个邻接矩阵，然后跑Dijistra最短路：
class Solution { public: int ladderLength(string beginWord, string endWord, vector&amp;lt;string&amp;gt;&amp;amp; wordList) { wordList.push_back(beginWord); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; word_map; word_map.resize(wordList.size()); _init_word_map(wordList, word_map); int source_idx = -1, target_idx = -1; vector&amp;lt;int&amp;gt; dist(wordList.size(), INT_MAX); // vector&amp;lt;int&amp;gt; prev(wordList.size(), -1/*UNDEFINED*/);  unordered_set&amp;lt;int&amp;gt; Q; for (int i = 0; i &amp;lt; wordList.size(); ++i) { Q.insert(i); if (beginWord == wordList[i]) source_idx = i; if (endWord == wordList[i]) target_idx = i; } if (target_idx == -1) { return 0; } dist[source_idx] = 0; while (not Q.</description>
    </item>
    
    <item>
      <title>710. 黑名单中的随机数</title>
      <link>https://engineers.cool/leetcode/leetcode/710/</link>
      <pubDate>Thu, 23 Sep 2021 11:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/710/</guid>
      <description>原题链接
首先考虑inner_max_v_ = n - blacklist.size()为实际的随机数个数的范围，如果直接% inner_max_v_那么得到的值[0, inner_max_v_)中会有blacklist的数字，而且[inner_max_v_,n)中的不在blacklist中的数字也拿不到。
一个思路是，用 [inner_max_v_,n)中的不在blacklist中的数字 填充 [0, inner_max_v_)中blacklist的数字，即把前面的“坑”填上，只需记录这个填坑映射即可：
class Solution { public: Solution(int n, vector&amp;lt;int&amp;gt;&amp;amp; blacklist) { inner_max_v_ = n - blacklist.size(); unordered_set&amp;lt;int&amp;gt; blackset; blackset.insert(blacklist.begin(), blacklist.end()); sort(blacklist.begin(), blacklist.end()); for (int num : blacklist) { while (blackset.count(--n)); mapping_[num] = n; } } int pick() { int rand_n = rand() % inner_max_v_; if (mapping_.count(rand_n)) { return mapping_[rand_n]; } return rand_n; } private: unordered_map&amp;lt;int, int&amp;gt; mapping_; int inner_max_v_; }; </description>
    </item>
    
    <item>
      <title>130. 被围绕的区域</title>
      <link>https://engineers.cool/leetcode/leetcode/130/</link>
      <pubDate>Thu, 23 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/130/</guid>
      <description>原题链接
遍历最外围一圈，DFS搜索染色，最后再重涂一边board：
class Solution { vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{1,0},{0,1},{-1,0},{0,-1}}; int m_, n_; public: void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { m_ = board.size(); n_ = board[0].size(); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m_, vector&amp;lt;bool&amp;gt;(n_, false)); // 遍历最外围的&amp;#39;O&amp;#39;，对该&amp;#39;O&amp;#39;做邻接搜索染色：邻接的&amp;#39;O&amp;#39;保持还是&amp;#39;O&amp;#39;  for (int i = 1; i &amp;lt; m_-1; ++i) { _dfs(board, i, 0, vis); _dfs(board, i, n_-1, vis); } for (int j = 0; j &amp;lt; n_; ++j) { _dfs(board, 0, j, vis); _dfs(board, m_-1, j, vis); } // 将所有没有被染色的点，设置为&amp;#39;X&amp;#39;  for (int i = 0; i &amp;lt; m_; ++i) { for (int j = 0; j &amp;lt; n_; ++j) { if (!</description>
    </item>
    
    <item>
      <title>131. 分割回文串</title>
      <link>https://engineers.cool/leetcode/leetcode/131/</link>
      <pubDate>Wed, 22 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/131/</guid>
      <description>原题链接
纯DFS：
class Solution { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solutions_; public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;string&amp;gt; solution; _dfs(solution, s, 0); return solutions_; } private: void _dfs(vector&amp;lt;string&amp;gt;&amp;amp; solution, const string&amp;amp; s, int idx) { if (idx == s.length()) { solutions_.push_back(solution); return; } for (int i = idx+1; i &amp;lt;= s.length(); ++i) { const string&amp;amp; sub_str = s.substr(idx, i-idx); if (_isHuiWen(sub_str)) { solution.push_back(sub_str); _dfs(solution, s, i); solution.pop_back(); } } } bool _isHuiWen(const string&amp;amp; s) { int len = s.</description>
    </item>
    
    <item>
      <title>134. 加油站</title>
      <link>https://engineers.cool/leetcode/leetcode/134/</link>
      <pubDate>Tue, 21 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/134/</guid>
      <description>原题链接
class Solution { public: int canCompleteCircuit(vector&amp;lt;int&amp;gt;&amp;amp; gas, vector&amp;lt;int&amp;gt;&amp;amp; cost) { int total = 0, sub_total = 0, res = 0; int len = gas.size(); for (int i = 0; i &amp;lt; len; ++i) { total += gas[i] - cost[i]; sub_total += gas[i] - cost[i]; if (sub_total &amp;lt; 0) { res = i+1; sub_total = 0; } } if (total &amp;lt; 0) return -1; return res; } }; </description>
    </item>
    
    <item>
      <title>138. 复制带随机指针的链表</title>
      <link>https://engineers.cool/leetcode/leetcode/138/</link>
      <pubDate>Sat, 18 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/138/</guid>
      <description>原题链接
/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } Node dummy_old(0); dummy_old.next = head; Node dummy_new(0); Node* tail_new = &amp;amp;dummy_new; // 根据next新建链表 并记录结点对应关系  unordered_map&amp;lt;unsigned long long, unsigned long long&amp;gt; node_mapping; for (Node* curr = dummy_old.</description>
    </item>
    
    <item>
      <title>136. 只出现一次的数字</title>
      <link>https://engineers.cool/leetcode/leetcode/136/</link>
      <pubDate>Sat, 18 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/136/</guid>
      <description>原题链接
class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int num : nums) { ans ^= num; } return ans; } }; </description>
    </item>
    
    <item>
      <title>139. 单词拆分</title>
      <link>https://engineers.cool/leetcode/leetcode/139/</link>
      <pubDate>Thu, 16 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/139/</guid>
      <description>原题链接
先做的140. 单词拆分 II，所以一上来思路一样，只不过不需要记录所有的可能方案：
class Solution { unordered_map&amp;lt;int, bool&amp;gt; vis; unordered_set&amp;lt;string&amp;gt; words; public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { words.insert(wordDict.begin(), wordDict.end()); return _dfs(s, 0); } private: bool _dfs(const string&amp;amp; s, int idx) { if (vis.count(idx)) { return vis[idx]; } if (idx == s.length()) { vis[idx] = true; return vis[idx]; } for (int i = idx+1; i &amp;lt;= s.length(); ++i) { string sub_str = s.substr(idx, i-idx); if (words.count(sub_str) &amp;amp;&amp;amp; _dfs(s, i)) { vis[idx] = true; return true; } } vis[idx] = false; return false; } }; 另外可以用DP递推的方式：</description>
    </item>
    
    <item>
      <title>149. 直线上最多的点数</title>
      <link>https://engineers.cool/leetcode/leetcode/149/</link>
      <pubDate>Wed, 15 Sep 2021 10:35:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/149/</guid>
      <description>原题链接
暴力的遍历起点、终点计算斜率：
class Solution { public: int maxPoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; points) { if (points.size() &amp;lt;= 2) return points.size(); int ans = 0; for (int i = 0; i &amp;lt; points.size(); ++i) { unordered_map&amp;lt;int, int&amp;gt; cnt; for (int j = i+1; j &amp;lt; points.size(); ++j) { auto xl = _calc_xl(points[i], points[j]); ans = max(ans, ++cnt[_val(xl)]); } } return ans+1; } private: pair&amp;lt;int, int&amp;gt; _calc_xl(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) { pair&amp;lt;int, int&amp;gt; res; int d_x = b[0] - a[0]; int d_y = b[1] - a[1]; if (d_y == 0) { res.</description>
    </item>
    
    <item>
      <title>148. 排序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/148/</link>
      <pubDate>Wed, 15 Sep 2021 10:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/148/</guid>
      <description>原题链接
以O(log n)复杂度，而且不能随机访问的话，可以使用归并排序：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { return _mergeSort(head); } private: ListNode* _mergeSort(ListNode* head) { if (head == nullptr || head-&amp;gt;next == nullptr) { return head; } ListNode* dummy = new ListNode(); ListNode* slow = head; ListNode* quik = head-&amp;gt;next; while (quik &amp;amp;&amp;amp; quik-&amp;gt;next) { slow = slow-&amp;gt;next; quik = quik-&amp;gt;next-&amp;gt;next; } ListNode* last_half = slow-&amp;gt;next; slow-&amp;gt;next = nullptr; head = _mergeSort(head); last_half = _mergeSort(last_half); dummy-&amp;gt;next = nullptr; ListNode* tail = dummy; while (head &amp;amp;&amp;amp; last_half) { if (head-&amp;gt;val &amp;lt; last_half-&amp;gt;val) { tail-&amp;gt;next = head; head = head-&amp;gt;next; } else { tail-&amp;gt;next = last_half; last_half = last_half-&amp;gt;next; } tail = tail-&amp;gt;next; } while (head) { tail-&amp;gt;next = head; head = head-&amp;gt;next; tail = tail-&amp;gt;next; } while (last_half) { tail-&amp;gt;next = last_half; last_half = last_half-&amp;gt;next; tail = tail-&amp;gt;next; } ListNode* merged_head = dummy-&amp;gt;next; delete dummy; return merged_head; } }; 但是空间复杂度不是O(1)，是O(log n)，即栈空间。取消栈空间的方法，是自底向上归并，用循环替代递归：</description>
    </item>
    
    <item>
      <title>140. 单词拆分 II</title>
      <link>https://engineers.cool/leetcode/leetcode/140/</link>
      <pubDate>Wed, 15 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/140/</guid>
      <description>原题链接
字典树 + DFS即可：
class Solution { struct TriNode { TriNode() : children(26, nullptr), is_word(false) {} vector&amp;lt;TriNode*&amp;gt; children; bool is_word; }; TriNode root; vector&amp;lt;string&amp;gt; solutions; public: vector&amp;lt;string&amp;gt; wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { _buildByDict(wordDict); // _printDict();  string solution; _dfs(solution, s, 0); return solutions; } private: void _dfs(string solution, string&amp;amp; s, int idx) { if (idx == s.length()) { solutions.push_back(solution); return; } TriNode* node = &amp;amp;root; for (int i = idx; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>227. 基本计算器 II</title>
      <link>https://engineers.cool/leetcode/leetcode/227/</link>
      <pubDate>Tue, 14 Sep 2021 11:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/227/</guid>
      <description>原题链接
class Solution { public: int calculate(string s) { vector&amp;lt;int&amp;gt; stk; char preSign = &amp;#39;+&amp;#39;; int num = 0; int n = s.length(); for (int i = 0; i &amp;lt; n; ++i) { if (isdigit(s[i])) { num = num * 10 + int(s[i] - &amp;#39;0&amp;#39;); } if (!isdigit(s[i]) &amp;amp;&amp;amp; s[i] != &amp;#39; &amp;#39; || i == n - 1) { switch (preSign) { case &amp;#39;+&amp;#39;: stk.push_back(num); break; case &amp;#39;-&amp;#39;: stk.push_back(-num); break; case &amp;#39;*&amp;#39;: stk.</description>
    </item>
    
    <item>
      <title>162. 寻找峰值</title>
      <link>https://engineers.cool/leetcode/leetcode/162/</link>
      <pubDate>Tue, 14 Sep 2021 10:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/162/</guid>
      <description>原题链接
原题提示O(log n)时间复杂度，就可以考虑二分，结合条件nums[-1] = nums[n] = -∞，可以二分查找时按增长的方向查找
 left &amp;lt; mid &amp;lt; right 则向右找 left &amp;gt; mid &amp;gt; right 则向左找  class Solution { public: int findPeakElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 1) return 0; int s = 0, e = nums.size()-1; while (s &amp;lt;= e) { int mid = s+(e-s)/2; if (_isPeak(mid, nums)) { return mid; } else if (_isSMB(mid, nums)) { s = mid+1; } else { e = mid-1; } } return 0; } private: bool _isPeak(int pos, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max = nums.</description>
    </item>
    
    <item>
      <title>169. 多数元素</title>
      <link>https://engineers.cool/leetcode/leetcode/169/</link>
      <pubDate>Thu, 09 Sep 2021 10:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/169/</guid>
      <description>原题链接
class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int half_n = nums.size()/2; unordered_map&amp;lt;int, int&amp;gt; cnt; for (int num : nums) { if (++cnt[num] &amp;gt; half_n) { return num; } } return -1; } }; 题解中有一个投票算法非常有意思：由于众数的个数大于n/2，即至少比其他数大1，认为每个数组出现一次时 要么表示给自己投一票 要么表示给另外一个数字减一票（如果其他数字票数不为0），那么最终票数为正的就是众数
class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int candidate = -1; int count = 0; for (int num : nums) { if (num == candidate) ++count; else if (--count &amp;lt; 0) { candidate = num; count = 1; } } return candidate; } }; 群里大佬给了一个方案，是用c++标准库中的std::nth_element：</description>
    </item>
    
    <item>
      <title>166. 分数到小数</title>
      <link>https://engineers.cool/leetcode/leetcode/166/</link>
      <pubDate>Thu, 09 Sep 2021 10:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/166/</guid>
      <description>原题链接
主要是要考虑到边界情况
class Solution { public: string fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { return &amp;#34;0&amp;#34;; } long long nn = numerator, dd = denominator; bool is_neg = false; if (nn &amp;lt; 0) { nn = -nn; is_neg = !is_neg; } if (dd &amp;lt; 0) { dd = -dd; is_neg = !is_neg; } long long zs = nn / dd; string ans(to_string(zs)); if (is_neg) { ans = &amp;#34;-&amp;#34; + ans; } nn = nn - zs*dd; if (nn == 0) { return ans; } ans.</description>
    </item>
    
    <item>
      <title>150. 逆波兰表达式求值</title>
      <link>https://engineers.cool/leetcode/leetcode/150/</link>
      <pubDate>Wed, 08 Sep 2021 10:36:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/150/</guid>
      <description>原题链接
class Solution { public: int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) { if (tokens.size() == 1) { return atoi(tokens[0].c_str()); } stack&amp;lt;int&amp;gt; st; int res = 0; for (const string&amp;amp; str : tokens) { if (is_op(str)) { int r = st.top(); st.pop(); int l = st.top(); st.pop(); res = _op(str, l, r); st.push(res); } else { st.push(atoi(str.c_str())); } } return res; } private: bool is_op(const string&amp;amp; str) { if (str == &amp;#34;+&amp;#34; || str == &amp;#34;-&amp;#34; || str == &amp;#34;*&amp;#34; || str == &amp;#34;/&amp;#34;) { return true; } return false; } int _op(const string&amp;amp; op, int l, int r) { if (op == &amp;#34;+&amp;#34;) { return l+r; } else if (op == &amp;#34;-&amp;#34;) { return l-r; } else if (op == &amp;#34;*&amp;#34;) { return l*r; } else { return l/r; } } }; </description>
    </item>
    
    <item>
      <title>155. 最小栈</title>
      <link>https://engineers.cool/leetcode/leetcode/155/</link>
      <pubDate>Tue, 07 Sep 2021 10:38:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/155/</guid>
      <description>原题链接
维护一个辅助栈：
clclass MinStack { public: /** initialize your data structure here. */ MinStack() { min_st.push(numeric_limits&amp;lt;int&amp;gt;::max()); } void push(int val) { st.push(val); min_st.push(min(val, min_st.top())); } void pop() { st.pop(); min_st.pop(); } int top() { return st.top(); } int getMin() { return min_st.top(); } private: private: stack&amp;lt;int&amp;gt; st; stack&amp;lt;int&amp;gt; min_st; }; </description>
    </item>
    
    <item>
      <title>152. 乘积最大子数组</title>
      <link>https://engineers.cool/leetcode/leetcode/152/</link>
      <pubDate>Tue, 07 Sep 2021 10:37:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/152/</guid>
      <description>原题链接
分治计算：
class Solution { public: int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); return _maxProduct(nums, 0, len-1); } private: int _maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums, int s, int e) { if (s == e) { return nums[s]; } int mid = s+(e-s)/2; auto mm1 = _iter_mm(nums, mid, (mid-s), -1); auto mm2 = _iter_mm(nums, mid+1, (e-mid-1), 1); int max_product = max(_maxProduct(nums, s, mid), _maxProduct(nums, mid+1, e)); if (mm1.first &amp;lt; 0 &amp;amp;&amp;amp; mm2.first &amp;lt; 0) { max_product = max(max_product, mm1.</description>
    </item>
    
    <item>
      <title>160. 相交链表</title>
      <link>https://engineers.cool/leetcode/leetcode/160/</link>
      <pubDate>Fri, 27 Aug 2021 10:40:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/160/</guid>
      <description>原题链接
如果可以用O(n)的额外存储，可以先遍历第一个链表，存储所有遍历过的地址，然后遍历第二个链表，看是否有已遍历过的
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { set&amp;lt;ListNode*&amp;gt; vis; for (ListNode* iter = headA; iter != nullptr; iter = iter-&amp;gt;next) vis.insert(iter); for (ListNode* iter = headB; iter != nullptr; iter = iter-&amp;gt;next) if (vis.count(iter)) return iter; return nullptr; } }; 另外一个思路是把其中一个链表反转，并尾部连接到另外一个链表，判断是否有环，有环则有交点。反转的目的是想定位交点的位置</description>
    </item>
    
    <item>
      <title>51. N 皇后</title>
      <link>https://engineers.cool/leetcode/leetcode/51/</link>
      <pubDate>Fri, 27 Aug 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/51/</guid>
      <description>原题链接
DFS搜索即可
class Solution { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; ans; public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int n) { vector&amp;lt;string&amp;gt; q(n, string(n, &amp;#39;.&amp;#39;)); DFS(n, 0, q); // ans.push_back(q);  return ans; } private: void DFS(int n, int d, vector&amp;lt;string&amp;gt;&amp;amp; q) { if (n == d) { ans.push_back(q); return; } int i = d; for (int j = 0; j &amp;lt; n; j++) { if (isValid(n, q, i, j)) { q[i][j] = &amp;#39;Q&amp;#39;; DFS(n, d+1, q); q[i][j] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>172. 阶乘后的零</title>
      <link>https://engineers.cool/leetcode/leetcode/172/</link>
      <pubDate>Thu, 26 Aug 2021 10:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/172/</guid>
      <description>原题链接
问题可以转换为统计阶乘所有数字的质因数分解中2的个数和5的个数，取其最小值。但是这个计数过程直观上是一个O(nlogn)的复杂度：
class Solution { public: int trailingZeroes(int n) { int cnt_2 = counter(n, 2); int cnt_5 = counter(n, 5); return min(cnt_2, cnt_5); } private: int counter(int n, int base) { int cnt = 0; while (n) { if (n % base == 0) { int now_n = n; while (now_n != 0 &amp;amp;&amp;amp; now_n % base == 0) { cnt++; now_n /= base; } n -= base; } else { n -= (n%base); } } return cnt; } }; 一个简单的优化思路是：去掉base为2的计算，因为5总是少于2：</description>
    </item>
    
    <item>
      <title>179. 最大数</title>
      <link>https://engineers.cool/leetcode/leetcode/179/</link>
      <pubDate>Tue, 24 Aug 2021 10:45:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/179/</guid>
      <description>原题链接
排序数组后拼接，排序规则是：两个数拼接的两种情况，哪种情况大 谁就在前
class Solution { public: string largestNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end(), [](long long a, long long b) { long long aa = 10, bb = 10; while (aa &amp;lt;= a) aa *= 10; while (bb &amp;lt;= b) bb *= 10; return b*aa+a &amp;lt; a*bb+b; }); if (nums[0] == 0) return &amp;#34;0&amp;#34;; string ret; for (int i = 0; i &amp;lt; nums.size(); ++i) ret += to_string(nums[i]); return ret; } }; </description>
    </item>
    
    <item>
      <title>190. 颠倒二进制位</title>
      <link>https://engineers.cool/leetcode/leetcode/190/</link>
      <pubDate>Mon, 23 Aug 2021 10:47:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/190/</guid>
      <description>原题链接
注意循环条件不能是n != 0，要遍历32位。
class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ret = 0; for (int i = 0; i &amp;lt; 32; ++i) { uint32_t last_bit = n&amp;amp;1; n &amp;gt;&amp;gt;= 1; ret &amp;lt;&amp;lt;= 1; ret |= last_bit; } return ret; } }; </description>
    </item>
    
    <item>
      <title>189. 旋转数组</title>
      <link>https://engineers.cool/leetcode/leetcode/189/</link>
      <pubDate>Mon, 23 Aug 2021 10:46:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/189/</guid>
      <description>原题链接
直观的思路是使用一个额外数组：
class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;int&amp;gt; ans(nums.size(), 0); for (int i = 0; i &amp;lt; nums.size(); ++i) { ans[nxt(i, k, nums.size())] = nums[i]; } nums = ans; } private: int nxt(int cur, int k, int len) { return (cur+k)%len; } }; 之前学习间接排序时候，有发现它最后有原地替换的方式：环状替换，这里也可以适用，不过 需要一个额外的数组判断是否有替换过（方法三可以省略掉）。
class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;bool&amp;gt; vis(nums.size(), false); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>198. 打家劫舍</title>
      <link>https://engineers.cool/leetcode/leetcode/198/</link>
      <pubDate>Sun, 22 Aug 2021 10:49:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/198/</guid>
      <description>原题链接
简单的二维DP
class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(len, vector&amp;lt;int&amp;gt;(2,0)); dp[0][1] = nums[0]; for (int i = 1; i &amp;lt; len; ++i) { dp[i][0] = dp[i-1][1]; dp[i][1] = max(dp[i-1][1], dp[i-1][0]+nums[i]); } return max(dp[len-1][0], dp[len-1][1]); } }; 因为每次迭代，只与上一次迭代有关，可以优化下存储：
class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); int dp[2][2] = {{0,0},{0,0}}; dp[0][1] = nums[0]; int nxt = 1; for (int i = 1; i &amp;lt; len; ++i) { dp[nxt][0] = dp[nxt^1][1]; dp[nxt][1] = max(dp[nxt^1][1], dp[nxt^1][0]+nums[i]); nxt ^= 1; } return max(dp[nxt^1][0], dp[nxt^1][1]); } }; </description>
    </item>
    
    <item>
      <title>191. 位1的个数</title>
      <link>https://engineers.cool/leetcode/leetcode/191/</link>
      <pubDate>Sun, 22 Aug 2021 10:48:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/191/</guid>
      <description>原题链接
逐位判断即可
class Solution { public: int hammingWeight(uint32_t n) { int ret = 0; while (n) { if (n&amp;amp;1) ret++; n &amp;gt;&amp;gt;= 1; } return ret; } }; </description>
    </item>
    
    <item>
      <title>337. 打家劫舍 III</title>
      <link>https://engineers.cool/leetcode/leetcode/337/</link>
      <pubDate>Fri, 20 Aug 2021 11:13:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/337/</guid>
      <description>原题链接
类似DP过程的DFS，需要记录下已经搜索过的情况，否则会超时。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { unordered_map&amp;lt;TreeNode*, unordered_map&amp;lt;bool, int&amp;gt;&amp;gt; vis; public: int rob(TreeNode* root) { int max_v = 0; DFS(root, false, max_v); return max_v; } private: void DFS(TreeNode* root, bool is_f, int&amp;amp; max_v) { if (root == nullptr) { return; } if (vis[root][is_f]) { max_v = vis[root][is_f]; return; } if (is_f) { int max_v_l = 0, max_v_r = 0; DFS(root-&amp;gt;left, false, max_v_l); DFS(root-&amp;gt;right, false, max_v_r); max_v += max_v_l + max_v_r; } else { int max_v_l_1 = 0, max_v_r_1 = 0; DFS(root-&amp;gt;left, false, max_v_l_1); DFS(root-&amp;gt;right, false, max_v_r_1); int max_v_l_2 = 0, max_v_r_2 = 0; DFS(root-&amp;gt;left, true, max_v_l_2); DFS(root-&amp;gt;right, true, max_v_r_2); max_v += max(max_v_l_1 + max_v_r_1, max_v_l_2 + max_v_r_2 + root-&amp;gt;val); } vis[root][is_f] = max_v; } }; 题解的DFS过程简化了很多！</description>
    </item>
    
    <item>
      <title>200. 岛屿数量</title>
      <link>https://engineers.cool/leetcode/leetcode/200/</link>
      <pubDate>Thu, 19 Aug 2021 10:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/200/</guid>
      <description>原题链接
用DFS遍历一边即可，每发起一次DFS岛屿数量就加1。
class Solution { vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{1,0},{0,1},{-1,0},{0,-1}}; int m_, n_; public: int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { m_ = grid.size(); n_ = grid[0].size(); int ret = 0; vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m_, vector&amp;lt;bool&amp;gt;(n_, false)); for (int i = 0; i &amp;lt; m_; i++) { for (int j = 0; j &amp;lt; n_; j++) { if (grid[i][j] == &amp;#39;1&amp;#39; &amp;amp;&amp;amp; !vis[i][j]) { DFS(grid, i, j, vis); ret += 1; } } } return ret; } private: void DFS(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int i, int j, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt;&amp;amp; vis) { for (int d = 0; d &amp;lt; 4; d++) { int nxt_i = i + dirs_[d].</description>
    </item>
    
    <item>
      <title>202. 快乐数</title>
      <link>https://engineers.cool/leetcode/leetcode/202/</link>
      <pubDate>Wed, 18 Aug 2021 10:51:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/202/</guid>
      <description>原题链接
直接模拟接口，另外拿一个容器记录已遍历的数字：
class Solution { public: bool isHappy(int n) { set&amp;lt;int&amp;gt; vis; while (true) { int nxt_n = powN(n); cout &amp;lt;&amp;lt; nxt_n &amp;lt;&amp;lt; endl; if (nxt_n == 1) { return true; } else if (vis.count(nxt_n)) { return false; } else { vis.insert(nxt_n); n = nxt_n; } } return false; } private: int powN(int n) { int nxt = 0; while (n) { int sub_n = n%10; n /= 10; nxt += sub_n*sub_n; } return nxt; } }; </description>
    </item>
    
    <item>
      <title>204. 计数质数</title>
      <link>https://engineers.cool/leetcode/leetcode/204/</link>
      <pubDate>Tue, 17 Aug 2021 10:52:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/204/</guid>
      <description>原题链接
素数筛，注意题目中“统计所有小于非负整数 n 的质数的数量”的小于。
class Solution { public: int countPrimes(int n) { int max_v = n-1; if (max_v &amp;lt; 2) return 0; vector&amp;lt;bool&amp;gt; is_prime(max_v, true); int ret = max_v-1; for (int i = 2; i &amp;lt; max_v; i++) { if (not is_prime[i]) { continue; } int bc = 2; int bs = i*bc; for (int bs =i*bc; bs &amp;lt;= max_v; bs = i*(++bc)) { if (not is_prime[bs]) { continue; } is_prime[bs] = false; ret -= 1; } } return ret; } }; 我这里是用减法统计，题解用加法统计：</description>
    </item>
    
    <item>
      <title>210. 课程表 II</title>
      <link>https://engineers.cool/leetcode/leetcode/210/</link>
      <pubDate>Mon, 16 Aug 2021 10:56:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/210/</guid>
      <description>原题链接
标准的拓扑排序：
class Solution { public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;int&amp;gt; indegree(numCourses, 0); unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; out_to; for (int i = 0; i &amp;lt; prerequisites.size(); i++) { indegree[ prerequisites[i][0] ] ++; out_to[ prerequisites[i][1] ].push_back(prerequisites[i][0]); } queue&amp;lt;int&amp;gt; q; for (int i = 0; i &amp;lt; numCourses; i++) { if (indegree[i] == 0) { q.push(i); } } vector&amp;lt;int&amp;gt; ans; while (!q.empty()) { int course = q.front(); q.pop(); ans.push_back(course); for (int to_course : out_to[course]) { if (-- indegree[to_course] == 0) { q.</description>
    </item>
    
    <item>
      <title>208. 实现 Trie (前缀树)</title>
      <link>https://engineers.cool/leetcode/leetcode/208/</link>
      <pubDate>Mon, 16 Aug 2021 10:55:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/208/</guid>
      <description>原题链接
class Trie { private: struct TrieNode { bool is_word; vector&amp;lt;TrieNode*&amp;gt; children; TrieNode() : is_word(false), children(26, nullptr) {} }; TrieNode* root; public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { int idx = 0; TrieNode* curnode = root; while (idx &amp;lt; word.length()) { int c_idx = word[idx] - &amp;#39;a&amp;#39;; if (curnode-&amp;gt;children[c_idx] == nullptr) { curnode-&amp;gt;children[c_idx] = new TrieNode(); } curnode = curnode-&amp;gt;children[c_idx]; idx++; } curnode-&amp;gt;is_word = true; // string str;  // print_trie(root, str);  } void print_trie(TrieNode* node, const string&amp;amp; str) { if (node == nullptr) { return; } if (node-&amp;gt;is_word) { cout &amp;lt;&amp;lt; &amp;#34;iter word:&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; } for (int i = 0; i &amp;lt; 26; i++) { char c = &amp;#39;a&amp;#39;+i; print_trie(node-&amp;gt;children[i], str+string(1,c)); } } /** Returns if the word is in the trie.</description>
    </item>
    
    <item>
      <title>470. 用 Rand7() 实现 Rand10()</title>
      <link>https://engineers.cool/leetcode/leetcode/470/</link>
      <pubDate>Sun, 15 Aug 2021 11:14:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/470/</guid>
      <description>原题链接
数学题比较头大。
首先我们用两次rand7()可以生成1～49的数字，而生成1～10的随机数，需要10整数倍的数字来采样，那么可以丢弃大于40的数字，重新生成（拒绝采样）：
class Solution { public: int rand10() { int sample = 0; do { int r1 = rand7(); int r2 = rand7(); sample = r1 + (r2-1)*7; } while (sample &amp;gt; 40); return sample%10+1; } }; 我本来的思路，还是用这49个数字，用除法做归一化，然后再映射到1～10，不知道为啥过不了。。。:
class Solution { public: int rand10() { static int r1 = rand7(); int r2 = rand7(); int sample = r1 + (r2-1)*7; r1 = r2; int tmp = sample/49.0*10 + 1; if (tmp == 11) tmp = 1; return tmp; } }; 实际上，除法虽然是归一化，但是因为值域不是10的倍数 or 不是连续的，归一化后仍然不均匀</description>
    </item>
    
    <item>
      <title>112. 路径总和</title>
      <link>https://engineers.cool/leetcode/leetcode/112/</link>
      <pubDate>Sun, 15 Aug 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/112/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if (root == nullptr) { return false; } targetSum = targetSum - root-&amp;gt;val; if (root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return targetSum == 0; } return (root-&amp;gt;left &amp;amp;&amp;amp; hasPathSum(root-&amp;gt;left, targetSum)) || (root-&amp;gt;right &amp;amp;&amp;amp; hasPathSum(root-&amp;gt;right, targetSum)); } }; </description>
    </item>
    
    <item>
      <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
      <link>https://engineers.cool/leetcode/%E5%89%91%E6%8C%87offer/jz_54/</link>
      <pubDate>Sun, 15 Aug 2021 08:13:53 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/%E5%89%91%E6%8C%87offer/jz_54/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int kthLargest(TreeNode* root, int k) { int cnt = 0, v; kthLargest(root, k, cnt, v); return v; } private: bool kthLargest(TreeNode* root, int k, int&amp;amp; cnt, int&amp;amp; v) { if (root == nullptr) return false; bool found = kthLargest(root-&amp;gt;right, k, cnt, v); if (found) { return true; } cnt += 1; if (cnt == k) { v = root-&amp;gt;val; return true; } return kthLargest(root-&amp;gt;left, k, cnt, v); } }; </description>
    </item>
    
    <item>
      <title>300. 最长递增子序列</title>
      <link>https://engineers.cool/leetcode/leetcode/300/</link>
      <pubDate>Sat, 14 Aug 2021 11:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/300/</guid>
      <description>原题链接
令dp[i]表示以数字nums[i]结尾的串的最长递增子序列，容易写出O(n^2)的代码：
class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int dp[2500]; for (int i = 0; i &amp;lt; nums.size(); i++) { dp[i] = 1; } int ans = 1; for (int j = 1; j &amp;lt; nums.size(); j++) { for (int i = 0; i &amp;lt; j; i++) { if (nums[j] &amp;gt; nums[i]) { dp[j] = max(dp[j], dp[i]+1); ans = max(ans, dp[j]); } } } return ans; } }; 官方给出了一个O(nlogn)的方法：贪心 + 二分查找。</description>
    </item>
    
    <item>
      <title>206. 反转链表</title>
      <link>https://engineers.cool/leetcode/leetcode/206/</link>
      <pubDate>Sat, 14 Aug 2021 10:54:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/206/</guid>
      <description>原题链接
注意输入为nullptr的情况。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr) return head; ListNode* pre_node = nullptr; ListNode* cur_node = head; while (cur_node-&amp;gt;next) { ListNode* nxt = cur_node-&amp;gt;next; cur_node-&amp;gt;next = pre_node; pre_node = cur_node; cur_node = nxt; } cur_node-&amp;gt;next = pre_node; return cur_node; } }; </description>
    </item>
    
    <item>
      <title>153. 寻找旋转排序数组中的最小值</title>
      <link>https://engineers.cool/leetcode/leetcode/153/</link>
      <pubDate>Sat, 14 Aug 2021 10:39:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/153/</guid>
      <description>原题链接
class Solution { public: int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int low = 0; int high = nums.size() - 1; while (low &amp;lt; high) { int pivot = low + (high - low) / 2; if (nums[pivot] &amp;lt; nums[high]) { high = pivot; } else { low = pivot + 1; } } return nums[low]; } }; </description>
    </item>
    
    <item>
      <title>146. LRU 缓存机制</title>
      <link>https://engineers.cool/leetcode/leetcode/146/</link>
      <pubDate>Sat, 14 Aug 2021 10:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/146/</guid>
      <description>原题链接
整体思路是：
 unordered_map&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; cache_ 维护键值对，以及键的引用计数  引用计数：从第一次put进去后，（包括第一次put的）put/get的次数   queue&amp;lt;int&amp;gt; pop_queue_ 记录每次操作的键  当缓存大小大于capacity后，按pop_queue_的顺序对键做引用计数减1，直到遇到减1后计数为0的键，然后删除它即可：
class LRUCache { public: LRUCache(int capacity) : capacity_(capacity) {} int get(int key) { if (cache_.count(key) != 0) { cache_[key].second++; pop_queue_.push(key); return cache_[key].first; } return -1; } void put(int key, int value) { if (cache_.size() == capacity_ &amp;amp;&amp;amp; cache_.count(key) == 0) { pop_one(); } if (cache_.count(key) == 0) { cache_[key] = {value, 1}; } else { cache_[key].</description>
    </item>
    
    <item>
      <title>217. 存在重复元素</title>
      <link>https://engineers.cool/leetcode/leetcode/217/</link>
      <pubDate>Thu, 12 Aug 2021 10:58:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/217/</guid>
      <description>原题链接
排序后，检查是否有连续的相等数字即可：
class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() &amp;lt; 2) return false; sort(nums.begin(), nums.end()); for (int i = 1; i &amp;lt; nums.size(); i++) if (nums[i] == nums[i-1]) return true; return false; } }; 或者不排序，拿一个容器记录已经遍历过的数字也可以：
class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // 官方题解这里是unordered_set  set&amp;lt;int&amp;gt; vis; for (int i = 0; i &amp;lt; nums.size(); i++) { if (vis.count(nums[i])) { return true; } vis.insert(nums[i]); } return false; } }; class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_map&amp;lt;int, bool&amp;gt; vis; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>212. 单词搜索 II</title>
      <link>https://engineers.cool/leetcode/leetcode/212/</link>
      <pubDate>Thu, 12 Aug 2021 10:57:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/212/</guid>
      <description>原题链接
构造字典树，暴力搜索即可：
class Solution { struct TriNode { TriNode() : children_(26, nullptr), empty_(true), is_word_(false) {} bool empty_; bool is_word_; vector&amp;lt;TriNode*&amp;gt; children_; }; TriNode* words_tree_ = new TriNode(); vector&amp;lt;string&amp;gt; ans_; bool vis_[12][12]; int n_; int m_; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{0,1},{1,0},{-1,0},{0,-1}}; public: vector&amp;lt;string&amp;gt; findWords(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, vector&amp;lt;string&amp;gt;&amp;amp; words) { buildWordsTree(words); memset(vis_, false, sizeof(bool)*12*12); n_ = board.size(); m_ = board[0].size(); for (int i = 0; i &amp;lt; n_; i++) { for (int j = 0; j &amp;lt; m_; j++) { int child_idx = board[i][j]-&amp;#39;a&amp;#39;; if (words_tree_-&amp;gt;children_[child_idx] !</description>
    </item>
    
    <item>
      <title>218. 天际线问题</title>
      <link>https://engineers.cool/leetcode/leetcode/218/</link>
      <pubDate>Wed, 11 Aug 2021 11:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/218/</guid>
      <description>原题链接
没思路，题解太厉害了
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; getSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; buildings) { auto cmp = [](const pair&amp;lt;int, int&amp;gt;&amp;amp; a, const pair&amp;lt;int, int&amp;gt;&amp;amp; b) -&amp;gt; bool { return a.second &amp;lt; b.second; }; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, decltype(cmp)&amp;gt; que(cmp); vector&amp;lt;int&amp;gt; boundaries; for (auto&amp;amp; building : buildings) { boundaries.emplace_back(building[0]); boundaries.emplace_back(building[1]); } sort(boundaries.begin(), boundaries.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; int n = buildings.size(), idx = 0; for (auto&amp;amp; boundary : boundaries) { while (idx &amp;lt; n &amp;amp;&amp;amp; buildings[idx][0] &amp;lt;= boundary) { que.</description>
    </item>
    
    <item>
      <title>863. 二叉树中所有距离为 K 的结点</title>
      <link>https://engineers.cool/leetcode/leetcode/863/</link>
      <pubDate>Tue, 10 Aug 2021 11:16:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/863/</guid>
      <description>原题链接
 首先要找到该结点，然后再考虑距离的问题 找到该结点后，需要向两个方向查找  向下，每向下一层k-1 向上，每向上一层k-1   但是注意向上后还需要再次向下找。特别的，如果DFS时是先左子树再右子树的遍历，那么右子树找到target，向上再向下找的时候，还需要再遍历下左子树。  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&amp;lt;int&amp;gt; ans_; bool find_target_ = false; public: vector&amp;lt;int&amp;gt; distanceK(TreeNode* root, TreeNode* target, int k) { searchTAndDistanceK(root, target, k); return ans_; } private: void searchTAndDistanceK(TreeNode* node, TreeNode* target, int&amp;amp; k) { if (node == nullptr) return; if (k &amp;lt; 0) return; if (find_target_) { if (k == 0) { ans_.</description>
    </item>
    
    <item>
      <title>230. 二叉搜索树中第K小的元素</title>
      <link>https://engineers.cool/leetcode/leetcode/230/</link>
      <pubDate>Mon, 09 Aug 2021 11:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/230/</guid>
      <description>原题链接
深度优先遍历，遍历的时候携带要找第几小即可：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int kthSmallest(TreeNode* root, int k) { int child_cnt; return kthSmallest(root, k, child_cnt); } private: int kthSmallest(TreeNode* root, int k, int&amp;amp; child_cnt) { if (root == nullptr) { child_cnt = 0; return -1; } int l_child_cnt = 0, r_child_cnt = 0; int l_ret = kthSmallest(root-&amp;gt;left, k, l_child_cnt); if (l_ret !</description>
    </item>
    
    <item>
      <title>234. 回文链表</title>
      <link>https://engineers.cool/leetcode/leetcode/234/</link>
      <pubDate>Sun, 08 Aug 2021 11:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/234/</guid>
      <description>原题链接
题目要求O(n)时间复杂度 而且 O(1) 空间复杂度，那么可以想到思路是反转后半段链表，比较完在反转回来。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { // 计算长度  int len = 0; ListNode* iter = head; while (iter) { ++len; iter = iter-&amp;gt;next; } if (len == 0 || len == 1) return true; // 反转后半段  int reverse_pos = len/2 + len%2; ListNode* pre_node = nullptr; iter = head; while (reverse_pos--) { pre_node = iter; iter = iter-&amp;gt;next; } pre_node-&amp;gt;next = nullptr; // 开始反转  while(iter) { ListNode* next = iter-&amp;gt;next; iter-&amp;gt;next = pre_node; pre_node = iter; iter = next; } iter = pre_node; bool ans = true; // 反转完开始对比  while (head) { if (head-&amp;gt;val !</description>
    </item>
    
    <item>
      <title>236. 二叉树的最近公共祖先</title>
      <link>https://engineers.cool/leetcode/leetcode/236/</link>
      <pubDate>Sat, 07 Aug 2021 11:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/236/</guid>
      <description>原题链接
深度遍历整棵树：
 遍历到该结点时，两个结点都还没找到，该结点可能是答案  如果该结点的值是其中一个搜索结点，从左右子树搜另外一个搜索结点  如果找到则该结点就是大单 如果没则返回nullptr   迭代遍历左子树和右子树   遍历到该结点时，两个结点已经找到了至少一个，那么该结点可能是答案，继续遍历即可  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { set&amp;lt;int&amp;gt; to_find_val; to_find_val.insert(p-&amp;gt;val); to_find_val.insert(q-&amp;gt;val); return DFS(root, to_find_val); } private: TreeNode* DFS(TreeNode* root, set&amp;lt;int&amp;gt;&amp;amp; to_find_val) { if (!</description>
    </item>
    
    <item>
      <title>237. 删除链表中的节点</title>
      <link>https://engineers.cool/leetcode/leetcode/237/</link>
      <pubDate>Fri, 06 Aug 2021 11:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/237/</guid>
      <description>原题链接
这题输入方式挺有意思的
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; // ListNode* delete_node = node-&amp;gt;next;  node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; // delete delete_node;  } }; </description>
    </item>
    
    <item>
      <title>239. 滑动窗口最大值</title>
      <link>https://engineers.cool/leetcode/leetcode/239/</link>
      <pubDate>Thu, 05 Aug 2021 11:06:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/239/</guid>
      <description>原题链接
持续维护最值，最开始的想法是维护一个大顶堆，窗口内的都加进来；以后每次移动窗口时，就POP出不在窗口的数字，PUSH刚进窗口的数字。
但是有一个问题，在堆POP时，不知道该POP的数字在堆的哪个位置。
针对这个问题，考虑了两个思路：
 额外维护数据结构记录位置，比如用map&amp;lt;int,vector&amp;lt;size_t&amp;gt;&amp;gt;，记录每个数字的位置  但是这个数据结构会导致堆实现复杂化（挪动元素时需要修改这个结构）   记录需要POP的数字，但是先不着急POP，如果堆顶等于 需要POP的数字的最大值 才POP（堆顶），以及把这个数字从 需要POP的数字 中去除。  这个方法的话 需要POP的数字 也需要一个堆来维护。    以下使用第二个方法：
class BigHeap { public: BigHeap() : size_(0) { memset(heap_, INT_MIN, sizeof(int)*100000); } ~BigHeap() = default; void Push(int val) { heap_[size_++] = val; // push last val up  size_t cur_pos = size_-1; while (cur_pos != 0) { size_t father = (cur_pos+1)/2-1; if (heap_[father] &amp;lt; heap_[cur_pos]) { swap(heap_[father], heap_[cur_pos]); cur_pos = father; } else { break; } } } void Pop() { heap_[0] = heap_[size_-- -1]; // push first val down  size_t cur_pos = 0; while (true) { size_t child_l = cur_pos*2+1; size_t child_r = cur_pos*2+2; if (child_l &amp;lt; size_ &amp;amp;&amp;amp; child_r &amp;lt; size_) { // 有左 有右  size_t tmp_swap_child = heap_[child_l] &amp;gt; heap_[child_r] ?</description>
    </item>
    
    <item>
      <title>238. 除自身以外数组的乘积</title>
      <link>https://engineers.cool/leetcode/leetcode/238/</link>
      <pubDate>Thu, 05 Aug 2021 11:05:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/238/</guid>
      <description>原题链接
预处理一遍后缀乘积，存储在输出数组中；然后一边维护前缀乘积，一边更新结果数组（前缀乘积 * 预处理的后缀乘积）：
class Solution { public: vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;int&amp;gt; ans(len, 0); ans[len-1] = nums[len-1]; for (int i = len-2; i &amp;gt;= 0; i--) ans[i] = ans[i+1]*nums[i]; ans[0] = ans[1]; int pre_product = nums[0]; for (int i = 1; i &amp;lt; len-1; i++) { ans[i] = pre_product * ans[i+1]; pre_product *= nums[i]; } ans[len-1] = pre_product; return ans; } }; </description>
    </item>
    
    <item>
      <title>242. 有效的字母异位词</title>
      <link>https://engineers.cool/leetcode/leetcode/242/</link>
      <pubDate>Tue, 03 Aug 2021 11:08:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/242/</guid>
      <description>原题链接
class Solution { public: bool isAnagram(string s, string t) { if (s.length() != t.length()) return false; vector&amp;lt;int&amp;gt; s_cnt(26, 0); vector&amp;lt;int&amp;gt; t_cnt(26, 0); for (int i = 0; i &amp;lt; s.length(); i++) { s_cnt[s[i]-&amp;#39;a&amp;#39;]++; t_cnt[t[i]-&amp;#39;a&amp;#39;]++; } for (int i = 0; i &amp;lt; 26; i++) { if (s_cnt[i] != t_cnt[i]) return false; } return true; } }; </description>
    </item>
    
    <item>
      <title>240. 搜索二维矩阵 II</title>
      <link>https://engineers.cool/leetcode/leetcode/240/</link>
      <pubDate>Tue, 03 Aug 2021 11:07:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/240/</guid>
      <description>原题链接
直观（错误）思路 最开始的思路是先首行二分，然后找一列二分：
 首行二分，找到等于 或者 不大于target的最后一个 如果首行没有等于target的，就二分首行 不大于target的最后一个 的列  class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int l = 0, r = matrix[0].size()-1; int col = -1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (matrix[0][mid] == target) { return true; } else if (matrix[0][mid] &amp;gt; target) { r = mid-1; } else { l = mid+1; } } col = r; if (col == -1) return false; l = 0; r = matrix.</description>
    </item>
    
    <item>
      <title>268. 丢失的数字</title>
      <link>https://engineers.cool/leetcode/leetcode/268/</link>
      <pubDate>Mon, 02 Aug 2021 11:09:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/268/</guid>
      <description>原题链接
一上来会想到之前看过一个题：每个数字包含2遍 只有一个数字包含一遍，找这个数字。这题只是遍数都少了一次，那可以自己叠加上去：
class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { ans ^= (i+1); ans ^= nums[i]; } return ans; } }; 另外还有一个思路，可以一边加合一边减掉数组中的数字，最后的值就是缺的数字：
class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { ans += i+1; ans -= nums[i]; } return ans; } }; 另外，求和可以用数学公式替代，减少计算次数。</description>
    </item>
    
    <item>
      <title>279. 完全平方数</title>
      <link>https://engineers.cool/leetcode/leetcode/279/</link>
      <pubDate>Sun, 01 Aug 2021 11:10:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/279/</guid>
      <description>原题链接
预处理所有（小于等于10000）的完全平方数都有哪些。然后就是类似零钱问题的DP。
class Solution { int num_sqs[101]; public: Solution() { for (int i = 0; i &amp;lt;= 100; i++) num_sqs[i] = i*i; } public: int numSquares(int n) { int dp[10001]; memset(dp, 0, sizeof(int)*10001); for (int i = 0; i &amp;lt;= 100; i++) { dp[num_sqs[i]] = 1; } for (int i = 1; i &amp;lt; n; i++) { if (dp[i] == 0) continue; int sqs_idx = 1; while (i+num_sqs[sqs_idx] &amp;lt;= n &amp;amp;&amp;amp; sqs_idx &amp;lt;= 100) { int sum = i+num_sqs[sqs_idx]; dp[sum] == 0 ?</description>
    </item>
    
    <item>
      <title>283. 移动零</title>
      <link>https://engineers.cool/leetcode/leetcode/283/</link>
      <pubDate>Fri, 30 Jul 2021 11:11:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/283/</guid>
      <description>原题链接
两个指针，一个指向非零写入位置，一个指向当前位置。
遍历当前位置，如果当前非0，则把该数字swap到非零写入位置，并把非零写入位置向后挪1。
class Solution { public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(), no_zero_pos = 0, cur_pos = 0; while (cur_pos &amp;lt; n) { if (nums[cur_pos]) { swap(nums[no_zero_pos], nums[cur_pos]); no_zero_pos++; } cur_pos++; } } }; </description>
    </item>
    
    <item>
      <title>102. 二叉树的层序遍历</title>
      <link>https://engineers.cool/leetcode/leetcode/102/</link>
      <pubDate>Thu, 29 Jul 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/102/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; if (!root) return ans; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while (!</description>
    </item>
    
    <item>
      <title>101. 对称二叉树</title>
      <link>https://engineers.cool/leetcode/leetcode/101/</link>
      <pubDate>Thu, 29 Jul 2021 10:26:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/101/</guid>
      <description>原题链接
直观的思路，递归的判断左子树和右子树是否镜像一致，即 左子树的右子子树与右子树的左子子树 与 左子树的左子子树与右子树的右右子树:
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; return isSymmetric(root-&amp;gt;left, root-&amp;gt;right); } private: bool isSymmetric(TreeNode* left, TreeNode* right) { if (left == nullptr &amp;amp;&amp;amp; right == nullptr) { return true; } else if (left == nullptr || right == nullptr) { return false; } else { if (left-&amp;gt;val == right-&amp;gt;val) { return isSymmetric(left-&amp;gt;left, right-&amp;gt;right) &amp;amp;&amp;amp; isSymmetric(left-&amp;gt;right, right-&amp;gt;left); } else { return false; } } } }; 上面可以把if (!</description>
    </item>
    
    <item>
      <title>100. 相同的树</title>
      <link>https://engineers.cool/leetcode/leetcode/100/</link>
      <pubDate>Wed, 28 Jul 2021 10:26:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/100/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == nullptr &amp;amp;&amp;amp; q == nullptr) { return true; } else if ((p !</description>
    </item>
    
    <item>
      <title>99. 恢复二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/99/</link>
      <pubDate>Wed, 28 Jul 2021 10:25:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/99/</guid>
      <description>原题链接
先中序遍历一边，拿到中序遍历的顺序，然后遍历数组找到需要交换的位置；最后再遍历树并对相应的结点赋值。
如果不想遍历两边树的话，感觉可以在第一次遍历的时候，存下结点地址，而不是结点值。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void recoverTree(TreeNode* root) { vector&amp;lt;int&amp;gt; nums; inorder(root, nums); pair&amp;lt;int, int&amp;gt; swapped = findTwoSwapped(nums); int re_cnt = 2; recover(root, re_cnt, swapped.</description>
    </item>
    
    <item>
      <title>98. 验证二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/98/</link>
      <pubDate>Sun, 25 Jul 2021 10:25:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/98/</guid>
      <description>原题链接
拿到中序遍历，检查中序遍历是否是递增即可：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { vector&amp;lt;int&amp;gt; trip_vis; tripTree(root, trip_vis); for (int i = 1; i &amp;lt; trip_vis.</description>
    </item>
    
    <item>
      <title>97. 交错字符串</title>
      <link>https://engineers.cool/leetcode/leetcode/97/</link>
      <pubDate>Sun, 25 Jul 2021 10:24:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/97/</guid>
      <description>原题链接
1次通过100%击败的动态规划。dp[i][j]表示 s1的前i个字符 加上 s2的前j个字符 能不能组成s3的前i+j个字符串，然后递推即可：
ass Solution { public: bool isInterleave(string s1, string s2, string s3) { if (s3.length() != s1.length() + s2.length()) return false; if (s3.length() == 0) return true; bool dp[101][101]; memset(dp, false, sizeof(bool)*101*101); dp[0][0] = true; for (int i = 0; i &amp;lt;= s1.length(); i++) { for (int j = 0; j &amp;lt;= s2.length(); j++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; dp[i-1][j] &amp;amp;&amp;amp; s1[i-1] == s3[i+j-1]) dp[i][j] = true; if (j &amp;gt; 0 &amp;amp;&amp;amp; dp[i][j-1] &amp;amp;&amp;amp; s2[j-1] == s3[i+j-1]) dp[i][j] = true; } } return dp[s1.</description>
    </item>
    
    <item>
      <title>96. 不同的二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/96/</link>
      <pubDate>Sun, 25 Jul 2021 10:23:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/96/</guid>
      <description>原题链接
跟上一题的思路一样，再加一个vis矩阵记录计算过的数字：
class Solution { // unordered_map&amp;lt;int, unordered_map&amp;lt;int, int&amp;gt;&amp;gt; vis;  int vis[20][20]; public: int numTrees(int n) { memset(vis, 0, sizeof(int)*20*20); return numTrees(1, n); } private: int numTrees(int s, int e) { if (s &amp;gt; e) return 1; if (vis[s][e] != 0) return vis[s][e]; int ans = 0; for (int i = s; i &amp;lt;= e; i++) { int ltrees_n = numTrees(s, i-1); int rtrees_n = numTrees(i+1, e); ans += ltrees_n*rtrees_n; } vis[s][e] = ans; return ans; } }; 第一次vis矩阵用unordered_map实现，速度有点慢，换int二维数组，击败100%。</description>
    </item>
    
    <item>
      <title>95. 不同的二叉搜索树 II</title>
      <link>https://engineers.cool/leetcode/leetcode/95/</link>
      <pubDate>Sat, 24 Jul 2021 10:23:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/95/</guid>
      <description>原题链接
回溯+枚举，枚举父结点的值+递归构造子树，最后把子树拼接起来:
class Solution { public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { return MakeTrees(1, n); } private: vector&amp;lt;TreeNode*&amp;gt; MakeTrees(int s, int e) { if (s &amp;gt; e) return {nullptr}; // 这里要有一个nullptr  vector&amp;lt;TreeNode*&amp;gt; trees; for (int i = s; i &amp;lt;= e; ++i) { vector&amp;lt;TreeNode*&amp;gt; l_trees = MakeTrees(s, i-1); vector&amp;lt;TreeNode*&amp;gt; r_trees = MakeTrees(i+1, e); for (auto&amp;amp; l_tree : l_trees) for (auto&amp;amp; r_tree: r_trees) { TreeNode* father = new TreeNode(i); father-&amp;gt;left = l_tree; father-&amp;gt;right = r_tree; trees.</description>
    </item>
    
    <item>
      <title>94. 二叉树的中序遍历</title>
      <link>https://engineers.cool/leetcode/leetcode/94/</link>
      <pubDate>Sat, 24 Jul 2021 10:22:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/94/</guid>
      <description>原题链接
二叉树中序遍历，即先左子树 再本结点 再又子树：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; ans; MidTrip(root, ans); return ans; } private: void MidTrip(TreeNode* node, vector&amp;lt;int&amp;gt;&amp;amp; ans) { if (node == nullptr) return; if (node-&amp;gt;left) MidTrip(node-&amp;gt;left, ans); ans.</description>
    </item>
    
    <item>
      <title>93. 复原 IP 地址</title>
      <link>https://engineers.cool/leetcode/leetcode/93/</link>
      <pubDate>Sat, 24 Jul 2021 10:21:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/93/</guid>
      <description>原题链接
又是一道DFS搜索：
class Solution { public: vector&amp;lt;string&amp;gt; restoreIpAddresses(string s) { if (s.length() &amp;lt; 4 || s.length() &amp;gt; 12) return {}; vector&amp;lt;string&amp;gt; ans; string ip_now; DFS(s, 0, 0, ip_now, ans); return ans; } private: void DFS(string&amp;amp; s, int s_f_s, int pot_cnt, const string&amp;amp; ip_now, vector&amp;lt;string&amp;gt;&amp;amp; ans) { if (pot_cnt == 4 &amp;amp;&amp;amp; s_f_s == s.length()) { ans.push_back(ip_now); return; } else if (pot_cnt == 4 || s_f_s == s.length()) { return; } for (int i = s_f_s; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>92. 反转链表 II</title>
      <link>https://engineers.cool/leetcode/leetcode/92/</link>
      <pubDate>Sat, 24 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/92/</guid>
      <description>原题链接
找到相应位置，反转再链接即可：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { if (left == right) return head; ListNode* dummy = new ListNode(0, head); ListNode* pre_reverse = nullptr; ListNode* aft_reverse = nullptr; ListNode* dummy_reverse = new ListNode(0); ListNode* reverse_tail = dummy_reverse; int idx = 1; ListNode* cur_node = dummy; while (idx &amp;lt; left) { cur_node = cur_node-&amp;gt;next; ++ idx; } pre_reverse = cur_node; cur_node = cur_node-&amp;gt;next; while (idx &amp;lt;= right) { // 插入cur_node  ListNode* next = cur_node-&amp;gt;next; cur_node-&amp;gt;next = dummy_reverse-&amp;gt;next; dummy_reverse-&amp;gt;next = cur_node; if (cur_node-&amp;gt;next == nullptr) { reverse_tail = cur_node; } cur_node = next; ++ idx; } aft_reverse = cur_node; pre_reverse-&amp;gt;next = dummy_reverse-&amp;gt;next; reverse_tail-&amp;gt;next = aft_reverse; ListNode* ans = dummy-&amp;gt;next; delete dummy; delete dummy_reverse; return ans; } }; </description>
    </item>
    
    <item>
      <title>91. 解码方法</title>
      <link>https://engineers.cool/leetcode/leetcode/91/</link>
      <pubDate>Fri, 23 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/91/</guid>
      <description>原题链接
前面几题都是DFS搜索，这题一开始也想DFS来着，但是越写越不对劲，换思路用DP。
class Solution { public: int numDecodings(string s) { if (s.length() == 0) return 0; if (s[0] == &amp;#39;0&amp;#39;) return 0; int dp[100]; memset(dp, 0, sizeof(int)*100); dp[0] = 1; for (int i = 1; i &amp;lt; s.length(); ++i) { int dp_m1 = 0, dp_m2 = 0; if (isValid(s.substr(i,1))) dp_m1 = dp[i-1]; if (isValid(s.substr(i-1, 2))) dp_m2 = i &amp;gt; 1 ? dp[i-2] : 1; if (dp_m1 == 0 &amp;amp;&amp;amp; dp_m2 == 0) return 0; dp[i] = dp_m1 + dp_m2; } return dp[s.</description>
    </item>
    
    <item>
      <title>90. 子集 II</title>
      <link>https://engineers.cool/leetcode/leetcode/90/</link>
      <pubDate>Thu, 22 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/90/</guid>
      <description>原题链接
DFS搜索，一个额外数据记录不再使用的数字，搜索时遇到不再使用的数字直接进入下一层:
ass Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;bool&amp;gt; drop(21, false); vector&amp;lt;int&amp;gt; comb; DFS(nums, 0, comb, drop); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, int idx, vector&amp;lt;int&amp;gt;&amp;amp; comb, vector&amp;lt;bool&amp;gt;&amp;amp; drop) { if (idx == nums.size()) { ans.push_back(comb); return; } if (drop[nums[idx]+10]) { DFS(nums, idx+1, comb, drop); } else { comb.push_back(nums[idx]); DFS(nums, idx+1, comb, drop); comb.pop_back(); drop[nums[idx]+10] = true; DFS(nums, idx+1, comb, drop); drop[nums[idx]+10] = false; } } }; 有一个优化点，可以用while循环减少递归的层数:</description>
    </item>
    
    <item>
      <title>89. 格雷编码</title>
      <link>https://engineers.cool/leetcode/leetcode/89/</link>
      <pubDate>Thu, 22 Jul 2021 10:19:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/89/</guid>
      <description>原题链接
有点找规律的意思，先初始化1位的格雷码，循环增加位，反向遍历已有的格雷码数组 分别在新增位设置为1:
class Solution { public: vector&amp;lt;int&amp;gt; grayCode(int n) { if (n == 0) return {0}; vector&amp;lt;int&amp;gt; ans = {0, 1}; bool zx = false; for (int b = 1; b &amp;lt; n; b++) { int pre_len = ans.size(); int p = zx ? 0 : ans.size()-1; int d = zx ? 1 : -1; while (p &amp;gt;= 0 &amp;amp;&amp;amp; p &amp;lt; pre_len) { int n = ans[p] | 1&amp;lt;&amp;lt;b; ans.</description>
    </item>
    
    <item>
      <title>88. 合并两个有序数组</title>
      <link>https://engineers.cool/leetcode/leetcode/88/</link>
      <pubDate>Thu, 22 Jul 2021 10:18:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/88/</guid>
      <description>原题链接
一般思路可以通过，但时耗只击败60% 而且nums1原大小就是m+n这个条件没用到，感觉会有更优的算法
class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { vector&amp;lt;int&amp;gt; ans(m+n, 0); int ans_idx = 0; int n1_idx = 0, n2_idx = 0; while (n1_idx &amp;lt; m || n2_idx &amp;lt; n) { int n1 = n1_idx &amp;lt; m ? nums1[n1_idx] : INT_MAX; int n2 = n2_idx &amp;lt; n ? nums2[n2_idx] : INT_MAX; if (n1 &amp;lt; n2) { ans[ans_idx++] = n1; n1_idx++; } else { ans[ans_idx++] = n2; n2_idx++; } } nums1 = ans; } }; 再想了一下，只要从后往前填num1，就不会有覆盖原数组的问题，也不用再建一个中加数组了:</description>
    </item>
    
    <item>
      <title>86. 分隔链表</title>
      <link>https://engineers.cool/leetcode/leetcode/86/</link>
      <pubDate>Thu, 22 Jul 2021 10:17:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/86/</guid>
      <description>原题链接
遍历一遍拆成两个链表，然后把两个链表合并即可:
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { if (!head) return head; ListNode* part_1_dummy = new ListNode(0); ListNode* part_1_tail = part_1_dummy; ListNode* part_2_dummy = new ListNode(0); ListNode* part_2_tail = part_2_dummy; ListNode* cur = head; while (cur) { if (cur-&amp;gt;val &amp;lt; x) { part_1_tail-&amp;gt;next = cur; part_1_tail = part_1_tail-&amp;gt;next; } else { part_2_tail-&amp;gt;next = cur; part_2_tail = part_2_tail-&amp;gt;next; } cur = cur-&amp;gt;next; } part_2_tail-&amp;gt;next = nullptr; part_1_tail-&amp;gt;next = part_2_dummy-&amp;gt;next; return part_1_dummy-&amp;gt;next; } }; </description>
    </item>
    
    <item>
      <title>83. 删除排序链表中的重复元素</title>
      <link>https://engineers.cool/leetcode/leetcode/83/</link>
      <pubDate>Tue, 20 Jul 2021 10:17:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/83/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return head; ListNode* cur = head; while (cur-&amp;gt;next) { if (cur-&amp;gt;val == cur-&amp;gt;next-&amp;gt;val) { cur-&amp;gt;next = cur-&amp;gt;next-&amp;gt;next; } else { cur = cur-&amp;gt;next; } } return head; } }; </description>
    </item>
    
    <item>
      <title>82. 删除排序链表中的重复元素 II</title>
      <link>https://engineers.cool/leetcode/leetcode/82/</link>
      <pubDate>Tue, 20 Jul 2021 10:16:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/82/</guid>
      <description>原题链接
双指针遍历，第一个指针指向写入的位置，第二个指针指向遍历的位置，额外增加变量 记录上一个遍历的结点 以及 是否重复。
 遍历到相同值时，标记重复，然后continue 遍历到不同值时，查看标记是否重复  如果之前没有重复，就把记录的结点写到第一个指针的位置 如果之前有重复，则忽略，重新continue    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return head; ListNode* dummy = new ListNode(); ListNode* n_write = dummy; ListNode* t_node = head; bool conflicted = false; for (ListNode* node = head-&amp;gt;next; node; node = node-&amp;gt;next) { if (node-&amp;gt;val == t_node-&amp;gt;val) { conflicted = true; continue; } else { if (!</description>
    </item>
    
    <item>
      <title>81. 搜索旋转排序数组 II</title>
      <link>https://engineers.cool/leetcode/leetcode/81/</link>
      <pubDate>Tue, 20 Jul 2021 10:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/81/</guid>
      <description>原题链接
前面有一道类似的题，只不过没有相等的数字。单纯按之前的方法的话(18~39行)，会判断错误位置，原因是两半边的基准数字可能一样，那么我这里的解决方案是，先绕过相等的数字，剔除掉后，再做逻辑:
class Solution { public: bool search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int last = nums.size()-1; if (nums[0] == target || nums[last] == target) { return true; } while (last &amp;gt;= 0 &amp;amp;&amp;amp; nums[last] == nums[0])last--; int l = 0, r = last; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (nums[mid] == target) { return true; } else if (nums[mid] &amp;lt;= nums[last]) { // mid 在右半边  if (nums[mid] &amp;lt; target &amp;amp;&amp;amp; target &amp;lt;= nums[last]) { l = mid+1; } else { r = mid-1; } } else { // mid 在左半边  if (target &amp;lt; nums[mid] &amp;amp;&amp;amp; target &amp;gt;= nums[0]) { r = mid-1; } else { l = mid+1; } } } return false; } }; 整体时耗较高，只优于60%提交。</description>
    </item>
    
    <item>
      <title>80. 删除序有序数组中的重复项 II</title>
      <link>https://engineers.cool/leetcode/leetcode/80/</link>
      <pubDate>Sun, 18 Jul 2021 10:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/80/</guid>
      <description>原题链接
双指针，一个指向写入位置，一个指向遍历位置:
class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int cur_num = nums[0]; int cur_cnt = 1; int write_pos = 1; for (int i = 1; i &amp;lt; nums.size(); ++i) { if (nums[i] == cur_num) { cur_cnt += 1; if (cur_cnt &amp;lt;= 2) { nums[write_pos++] = nums[i]; } } else { cur_cnt = 1; cur_num = nums[i]; nums[write_pos++] = cur_num; } } return write_pos; } }; </description>
    </item>
    
    <item>
      <title>79. 单词搜索</title>
      <link>https://engineers.cool/leetcode/leetcode/79/</link>
      <pubDate>Sun, 18 Jul 2021 10:14:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/79/</guid>
      <description>原题链接
枚举+DFS，一开始提交的时候有cout打印，然后就超时了&amp;hellip;还以为是有剪枝没想到 or 思路不对&amp;hellip;很久想不到看题解才发现一摸一样，是cout导致超时😂：
class Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{1,0},{-1,0},{0,1},{0,-1}}; public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { int m = board.size(); int n = board[0].size(); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m, vector&amp;lt;bool&amp;gt;(n, false)); for (int i = 0; i &amp;lt; m; ++i) for (int j = 0; j &amp;lt; n; ++j) { if (DFS(board, word, i, j, 0, vis)) { return true; } } return false; } private: bool DFS(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string&amp;amp; word, int x, int y, int cur, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt;&amp;amp; vis) { if (x &amp;gt;= board.</description>
    </item>
    
    <item>
      <title>78. 子集</title>
      <link>https://engineers.cool/leetcode/leetcode/78/</link>
      <pubDate>Sun, 18 Jul 2021 10:13:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/78/</guid>
      <description>原题链接
跟上一题一样，回溯的思路，枚举k的大小，然后分别回溯一边：
class Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_result; public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int k = 0; k &amp;lt;= nums.size(); k++) { DFS(nums, 0, k); } return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, int s, int k) { if (dfs_result.size() == k) { ans.push_back(dfs_result); return; } if (nums.size()-s+dfs_result.size() &amp;lt; k) return; for (int i = s; i &amp;lt; nums.size(); ++i) { dfs_result.push_back(nums[i]); DFS(nums, i+1, k); dfs_result.pop_back(); } } }; 还是回溯，换一个思路会更快：不用枚举k的大小，只要枚举是否选回溯结点即可：</description>
    </item>
    
    <item>
      <title>77. 组合</title>
      <link>https://engineers.cool/leetcode/leetcode/77/</link>
      <pubDate>Sun, 18 Jul 2021 10:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/77/</guid>
      <description>原题链接
简单回溯算法搜索答案，可以有个剪枝小优化：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_result; DFS(1, n, k, dfs_result, ans); return ans; } private: void DFS(int s, int e, int k, vector&amp;lt;int&amp;gt;&amp;amp; dfs_result, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (dfs_result.size() == k) { ans.push_back(dfs_result); return; } if (e-s+1+dfs_result.size() &amp;lt; k) return; for (int i = s; i &amp;lt;= e; ++i) { dfs_result.push_back(i); DFS(i+1, e, k, dfs_result, ans); dfs_result.pop_back(); } } }; 官方给出了一种&amp;quot;非递归（字典序法）实现组合型枚举&amp;quot;的方法，本质上是找规律然后直接枚举出（字典序的）下一个组合。</description>
    </item>
    
    <item>
      <title>75. 颜色分类</title>
      <link>https://engineers.cool/leetcode/leetcode/75/</link>
      <pubDate>Sat, 17 Jul 2021 10:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/75/</guid>
      <description>原题链接
统计每个值的个数，然后再赋值回原数组即可:
class Solution { public: void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; count(3, 0); for (int num : nums) count[num]++; int idx = 0; for (int i = 0; i &amp;lt; 3; i++) { while (count[i]--) { nums[idx++] = i; } } } }; 官方题解给出了几个使用指针的方法:
 单指针  两次遍历，第一次把0置换到头部(指针维护0的末尾)，第二次把1置换到0后面的空间(指针维护1的末尾)   双置针  方案1，一次性维护上面两个指针，需要注意的是，遇到0时，换到0末尾后，如果置换出来的是1，还需要再放回1的末尾。(相当于先把0末尾置换到1末尾，再把0置换到0末尾) 方案2，维护0末尾、2开头两个置针，类似快排一样操作。    </description>
    </item>
    
    <item>
      <title>74. 搜索二维矩阵</title>
      <link>https://engineers.cool/leetcode/leetcode/74/</link>
      <pubDate>Sat, 17 Jul 2021 10:11:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/74/</guid>
      <description>原题链接
就是标准的二分搜索:
class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int l = 0, r = m*n-1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; int i = mid/n, j = mid%n; if (matrix[i][j] == target) { return true; } else if (matrix[i][j] &amp;gt; target) { r = mid-1; } else { l = mid+1; } } return false; } }; </description>
    </item>
    
    <item>
      <title>73. 矩阵置零</title>
      <link>https://engineers.cool/leetcode/leetcode/73/</link>
      <pubDate>Sat, 17 Jul 2021 10:10:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/73/</guid>
      <description>原题链接
题目要求仅能使用常数级额外存储空间，那么我们不能单独维护需要设置为0的行与列。 可以把这个标记维护在行首和列首。但是这样会影响行首和列首本身的数值，一个解决方案是，先单独遍历行首列首，单独维护其是否要置0:
class Solution { public: void setZeroes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int m = matrix.size(); int n = matrix[0].size(); bool m_all_zero = false, n_all_zero = false; for (int i = 0; i &amp;lt; m; ++i) if (matrix[i][0] == 0) m_all_zero = true; for (int j = 0; j &amp;lt; n; ++j) if (matrix[0][j] == 0) n_all_zero = true; for (int i = 1; i &amp;lt; m; ++i) { for (int j = 1; j &amp;lt; n; ++j) { if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; cout &amp;lt;&amp;lt; &amp;#34;mark &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl; } } } for (int i = 1; i &amp;lt; m; ++i) { for (int j = 1; j &amp;lt; n; ++j) { if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; } } if (m_all_zero) { for (int i = 0; i &amp;lt; m; ++i) matrix[i][0] = 0; } if (n_all_zero) { for (int j = 0; j &amp;lt; n; ++j) matrix[0][j] = 0; } } }; 官方给出了进一步的优化，上面方法中行首与列首交叉的元素被浪费掉了，这个元素可以用来标记首行(或首列)，就可以再省一个额外存储。 值得注意的是，因为在首行仍然表示本列是否置0，所以在遍历置0时，需要最后处理首行。</description>
    </item>
    
    <item>
      <title>71. 简化路径</title>
      <link>https://engineers.cool/leetcode/leetcode/71/</link>
      <pubDate>Sat, 17 Jul 2021 10:08:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/71/</guid>
      <description>原题链接
基本思路是遍历解析原始字符串，记录遍历到的目录名，如果遇到了..就把缓存的目录名删除一个。最后，再拼接成完整路径:
class Solution { public: string simplifyPath(string path) { vector&amp;lt;string&amp;gt; dirs; for (int i = 0; i &amp;lt; path.length();) { while (i &amp;lt; path.length() &amp;amp;&amp;amp; path[i] != &amp;#39;/&amp;#39;) ++i; int s = ++i; while (i &amp;lt; path.length() &amp;amp;&amp;amp; path[i] != &amp;#39;/&amp;#39;) ++i; int e = i; string dir = path.substr(s, e-s); if (dir == &amp;#34;.&amp;#34;) { continue; } else if (dir == &amp;#34;..&amp;#34;) { if (dirs.size() &amp;gt; 0) dirs.resize(dirs.size()-1); } else if (!</description>
    </item>
    
    <item>
      <title>70. 爬楼梯</title>
      <link>https://engineers.cool/leetcode/leetcode/70/</link>
      <pubDate>Sat, 17 Jul 2021 10:07:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/70/</guid>
      <description>原题链接
class Solution { public: int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int p1 = 1, p2 = 2; int p3 = p1 + p2; while(n--&amp;gt; 3) { p1 = p2; p2 = p3; p3 = p1 + p2; } return p3; } }; 官方题解果然还是有数学方法&amp;hellip;不管他了&amp;hellip;</description>
    </item>
    
    <item>
      <title>69. x 的平方根</title>
      <link>https://engineers.cool/leetcode/leetcode/69/</link>
      <pubDate>Sat, 17 Jul 2021 10:06:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/69/</guid>
      <description>原题链接
看上去是数学题，但是并不知道数学上求平方根的方法。可以使用二分法进行搜索：
class Solution { public: int mySqrt(int x) { if (x == 0 || x == 1) return x; int l = 1, r = x/2; int ans = 1; while (l &amp;lt;= r) { long long mid = l+(r-l)/2; long long mul = mid*mid; if (mul == x) { return mid; } else if (mul &amp;gt; x) { r = mid-1; } else { ans = mid; l = mid+1; } } return ans !</description>
    </item>
    
    <item>
      <title>67. 二进制求和</title>
      <link>https://engineers.cool/leetcode/leetcode/67/</link>
      <pubDate>Sat, 17 Jul 2021 10:05:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/67/</guid>
      <description>原题链接
模拟即可，值得注意的一点是，不用每次往ans的头部加字符，可以先往尾部加字符，最后再reverse一下：
class Solution { public: string addBinary(string a, string b) { string ans; int idx_a = a.length()-1, idx_b = b.length()-1; int carry = 0; while (idx_a &amp;gt;= 0 || idx_b &amp;gt;= 0) { int v_a = idx_a &amp;gt;= 0 ? a[idx_a] - &amp;#39;0&amp;#39;: 0; int v_b = idx_b &amp;gt;= 0 ? b[idx_b] - &amp;#39;0&amp;#39;: 0; int v_n = v_a + v_b + carry; carry = v_n / 2; ans.push_back(&amp;#39;0&amp;#39;+ (v_n%2)); idx_a--; idx_b--; } if (carry) { ans.</description>
    </item>
    
    <item>
      <title>66. 加一</title>
      <link>https://engineers.cool/leetcode/leetcode/66/</link>
      <pubDate>Sat, 17 Jul 2021 10:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/66/</guid>
      <description>原题链接
从后向前遍历，做加一操作即可：
class Solution { public: vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) { int idx = digits.size()-1; while (idx &amp;gt;= 0) { digits[idx]++; if (digits[idx]/10 == 0) // 不能进位直接返回  return digits; // 进位到下一轮  digits[idx--] %= 10; } reverse(digits.begin(), digits.end()); digits.push_back(1); reverse(digits.begin(), digits.end()); return digits; } }; </description>
    </item>
    
    <item>
      <title>64. 最小路径和</title>
      <link>https://engineers.cool/leetcode/leetcode/64/</link>
      <pubDate>Sat, 17 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/64/</guid>
      <description>原题链接
又是动态规划，连姿势都跟前两道一样：
class Solution { public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); for (int i = 1; i &amp;lt; m; i++) grid[i][0] += grid[i-1][0]; for (int j = 1; j &amp;lt; n; j++) grid[0][j] += grid[0][j-1]; for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); return grid[m-1][n-1]; } }; </description>
    </item>
    
    <item>
      <title>63. 不同路径 II</title>
      <link>https://engineers.cool/leetcode/leetcode/63/</link>
      <pubDate>Sat, 17 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/63/</guid>
      <description>原题链接
这回真的要用动态规划了：
class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { int dp[100][100]; memset(dp, 0, sizeof(int)*100*100); int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0; for (int i = 1; i &amp;lt; m; ++i) dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i-1][0] : 0; for (int j = 1; j &amp;lt; n; ++j) dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j-1] : 0; for (int i = 1; i &amp;lt; m; ++i) for (int j = 1; j &amp;lt; n; ++j) if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } }; </description>
    </item>
    
    <item>
      <title>62. 不同路径</title>
      <link>https://engineers.cool/leetcode/leetcode/62/</link>
      <pubDate>Sat, 17 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/62/</guid>
      <description>原题链接
一开始是想用数学的思路解题，奈何数学太差。。。最后换思路用动态规划（入参m,n足够小）：
 dp[i][j]表示从点0,0到点i,j的所有可能路径数 初始化dp[0][0~n-1]与dp[0~m-1][0] 循环计算其他点，dp[i][j] = dp[i-1][j] + dp[i][j-1]  class Solution { public: int uniquePaths(int m, int n) { int dp[100][100]; memset(dp, 0, sizeof(int)*100*100); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; ++i) dp[i][0] = 1; for (int j = 0; j &amp;lt; n; ++j) dp[0][j] = 1; for (int i = 1; i &amp;lt; m; ++i) for (int j = 1; j &amp;lt; n; ++j) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } }; 官方题解中有数学解法的思路：</description>
    </item>
    
    <item>
      <title>61. 旋转链表</title>
      <link>https://engineers.cool/leetcode/leetcode/61/</link>
      <pubDate>Sat, 17 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/61/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode* dummy = new ListNode(0, head); ListNode* tail = nullptr; int len = 0; for (auto iter = dummy-&amp;gt;next; iter !</description>
    </item>
    
    <item>
      <title>59. 螺旋矩阵 II</title>
      <link>https://engineers.cool/leetcode/leetcode/59/</link>
      <pubDate>Fri, 16 Jul 2021 10:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/59/</guid>
      <description>原题链接
思路跟前面54题一样，我最开始写的是逐步模拟:
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans(n, vector&amp;lt;int&amp;gt;(n, 0)); int pos_i = 0, pos_j = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{0,1},{1,0},{0,-1},{-1,0}}; int dir = 0; int idx = 1, max_idx = n*n; while (idx &amp;lt;= max_idx) { ans[pos_i][pos_j] = idx; int nxt_i = pos_i + dirs[dir][0]; int nxt_j = pos_j + dirs[dir][1]; if (nxt_i &amp;gt;= n || nxt_i &amp;lt; 0 || nxt_j &amp;gt;= n || nxt_j &amp;lt; 0 || ans[nxt_i][nxt_j] !</description>
    </item>
    
    <item>
      <title>58. 最后一个单词的长度</title>
      <link>https://engineers.cool/leetcode/leetcode/58/</link>
      <pubDate>Fri, 16 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/58/</guid>
      <description>原题链接
总是喜欢用一个大循环解决问题:
class Solution { public: int lengthOfLastWord(string s) { int ans = 0; bool start_word = false; for (int i = s.length()-1; i &amp;gt;= 0; --i) { if (start_word) { if (s[i] != &amp;#39; &amp;#39;) { ans++; } else { break; } } else { if (s[i] == &amp;#39; &amp;#39;) continue; else { start_word = true; ans++; } } } return ans; } }; 看了别人的代码才发现有更好的编码实现:
class Solution { public: int lengthOfLastWord(string s) { int ans = 0; int end = s.</description>
    </item>
    
    <item>
      <title>57. 插入区间</title>
      <link>https://engineers.cool/leetcode/leetcode/57/</link>
      <pubDate>Thu, 15 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/57/</guid>
      <description>原题链接
先二分查找，找到插入的位置，然后把插入位置前的interval复制到ans，最后按56题的样子把newInterval和剩余的intervals插入到ans:
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; insert(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, vector&amp;lt;int&amp;gt;&amp;amp; newInterval) { if (intervals.size() == 0) { return {newInterval}; } int left = 0, right = intervals.size()-1; int insert_pos = -1; while (left &amp;lt;= right) { int mid = left + (right-left)/2; insert_pos = mid; if (intervals[mid][0] == newInterval[0]) { break; } else if (intervals[mid][0] &amp;gt; newInterval[0]) { right = mid-1; cout &amp;lt;&amp;lt; &amp;#34;big &amp;#34; &amp;lt;&amp;lt; endl; } else { left = mid+1; insert_pos = left; cout &amp;lt;&amp;lt; &amp;#34;little &amp;#34; &amp;lt;&amp;lt; endl; } } cout &amp;lt;&amp;lt; insert_pos &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; right &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; left &amp;lt;&amp;lt; endl; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; int intervals_start = 0; if (insert_pos == 0) ans.</description>
    </item>
    
    <item>
      <title>56. 区间合并</title>
      <link>https://engineers.cool/leetcode/leetcode/56/</link>
      <pubDate>Tue, 13 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/56/</guid>
      <description>原题链接
bool cmp(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] &amp;lt; b[0]) return true; else if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return false; } class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { sort(intervals.begin(), intervals.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; int start_now = intervals[0][0]; int end_now = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.size(); ++i) { auto&amp;amp; interval = intervals[i]; if (end_now &amp;gt;= interval[0]) { end_now = max(end_now, interval[1]); } else { ans.</description>
    </item>
    
    <item>
      <title>55. 跳跃游戏</title>
      <link>https://engineers.cool/leetcode/leetcode/55/</link>
      <pubDate>Tue, 13 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/55/</guid>
      <description>原题链接
简单的贪心即可，前面有一道类似的题（45. 跳跃游戏 II）：
class Solution { public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max_pos = 0; for (int i = 0; i &amp;lt;= max_pos; i++) { max_pos = max(max_pos, i+nums[i]); if (max_pos &amp;gt;= nums.size()-1) { return true; } } return false; } }; </description>
    </item>
    
    <item>
      <title>54. 螺旋矩阵</title>
      <link>https://engineers.cool/leetcode/leetcode/54/</link>
      <pubDate>Tue, 13 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/54/</guid>
      <description>原题链接
逐层模拟输出，边界条件比较难：
class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int n = matrix.size()-1; int m = matrix[0].size()-1; vector&amp;lt;int&amp;gt; ans; int i = 0; while (i &amp;lt; min((m+1)/2, (n+1)/2)) { for (int y = i; y &amp;lt;= m-i; ++y) { int x = i; ans.push_back(matrix[x][y]); } for (int x = i+1; x &amp;lt;= n-i; ++x) { int y = m-i; ans.push_back(matrix[x][y]); } for (int y = m-1-i; y &amp;gt;= i; --y) { int x = n-i; ans.</description>
    </item>
    
    <item>
      <title>53. 最大子序和</title>
      <link>https://engineers.cool/leetcode/leetcode/53/</link>
      <pubDate>Mon, 12 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/53/</guid>
      <description>原题链接
贪心思路:
class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = INT_MIN; int sum = 0; for (int i = 0; i &amp;lt; nums.size(); ++i) { if (sum + nums[i] &amp;lt; 0) { sum = max(nums[i], 0); ans = max(ans, nums[i]); } else { sum += nums[i]; ans = max(sum, ans); } } return ans; } }; 官方的方法一思路一样，但是简洁很多
class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = nums[0]; int sum = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>50. Pow(x, n)</title>
      <link>https://engineers.cool/leetcode/leetcode/50/</link>
      <pubDate>Sun, 11 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/50/</guid>
      <description>原题链接
快速幂，只是有这个概念，记得前面有一题的写法如下，按印象搬出：
class Solution { // unordered_map&amp;lt;int, double&amp;gt; power_vis; public: double myPow(double x, int n) { bool neg_power = n &amp;lt; 0 ? true : false; long long power = n &amp;lt; 0 ? -(long long)n : n; double powered = quickPower(x, power); return neg_power ? 1/powered : powered; } private: double quickPower(double x, int n) { if (n == 0) { return 1; } else if (n == 1) { return x; } long long now_n = 1; double now_x = x; while (now_n+now_n &amp;lt;= n) { now_n += now_n; now_x *= now_x; } return now_x * quickPower(x, n-now_n); } }; 官方提供的标准快速幂（递归）：</description>
    </item>
    
    <item>
      <title>49. 字母异位词分组</title>
      <link>https://engineers.cool/leetcode/leetcode/49/</link>
      <pubDate>Sun, 11 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/49/</guid>
      <description>原题链接
给每个字符串计算特征值，字母异位词的特征值要一样，然后把特征值一样的放在一起。
计算方法有两种：
 给字符串排序，排序后的字符串即为特征值 给字符串做字符统计，统计后转换成字符串（或者hash值）即为特征值  class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; ans; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; cated_strs; for (auto&amp;amp; str: strs) { string cate = calcCate(str); cated_strs[cate].emplace_back(str); } for (auto&amp;amp; item : cated_strs) ans.emplace_back(item.second); return ans; } private: string calcCate(string&amp;amp; str) { string cate; vector&amp;lt;int&amp;gt; count(26, 0); for (auto&amp;amp; c : str) { count[c-&amp;#39;a&amp;#39;]++; } for (int i = 0; i &amp;lt; 26; ++i) { cate.push_back(count[i]); } return cate; } }; </description>
    </item>
    
    <item>
      <title>48. 旋转图像</title>
      <link>https://engineers.cool/leetcode/leetcode/48/</link>
      <pubDate>Sun, 11 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/48/</guid>
      <description>原题链接
模拟即可AC：
class Solution { public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int scan_len = matrix.size() -1; while (scan_len &amp;gt;= 1) { int x = (matrix.size()-scan_len-1)/2; for (int i = 0; i &amp;lt; scan_len; ++i) { int y = x+i; spanMatrix(x, y, matrix); } scan_len -= 2; } } private: void spanMatrix(int x, int y, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int len = matrix.size(); int tmp = matrix[x][y]; matrix[x][y] = matrix[len-y-1][x]; matrix[len-y-1][x] = matrix[len-x-1][len-y-1]; matrix[len-x-1][len-y-1] = matrix[y][len-x-1]; matrix[y][len-x-1] = tmp; } }; </description>
    </item>
    
    <item>
      <title>47. 全排列 II</title>
      <link>https://engineers.cool/leetcode/leetcode/47/</link>
      <pubDate>Sun, 11 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/47/</guid>
      <description>原题链接
跟46. 全排列大体一样的思路，只是在选当前位置的数字时，增加一个visited存储，防止重复：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; DFS(0, nums, ans); return ans; } private: void DFS(int idx, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (idx == nums.size()) { ans.push_back(nums); return; } set&amp;lt;int&amp;gt; vis; for (int i = idx; i &amp;lt; nums.size(); ++i) { if (vis.count(nums[i])) { continue; } vis.insert(nums[i]); swap(nums[i], nums[idx]); DFS(idx+1, nums, ans); swap(nums[i], nums[idx]); } } }; 官方题解：因为需要保持有序（为了不重复），单独维护了组合结果数字，填充组合数组时，同样的数字确保顺序填入，这样就防止了重复的组合：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.</description>
    </item>
    
    <item>
      <title>46. 全排列</title>
      <link>https://engineers.cool/leetcode/leetcode/46/</link>
      <pubDate>Sun, 11 Jul 2021 09:59:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/46/</guid>
      <description>原题链接
回溯（DFS）即可：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;bool&amp;gt; vis(6, false); vector&amp;lt;int&amp;gt; dfs_state; DFS(nums, vis, dfs_state, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;bool&amp;gt; &amp;amp; vis, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (dfs_state.size() == nums.size()) { ans.push_back(dfs_state); return; } for (int i = 0; i &amp;lt; nums.size(); ++i) { if (vis[i]) continue; dfs_state.push_back(nums[i]); vis[i] = true; DFS(nums, vis, dfs_state, ans); dfs_state.pop_back(); vis[i] = false; } } }; 官方题解思路一样，但是代码更干净，不用独立维护当前状态（原入参维护即可）：</description>
    </item>
    
    <item>
      <title>45. 跳跃游戏 II</title>
      <link>https://engineers.cool/leetcode/leetcode/45/</link>
      <pubDate>Sun, 11 Jul 2021 09:58:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/45/</guid>
      <description>原题链接
直观的思路，DP思想，用dp[i]表示跳到i的最小跳数，然后用i结点更新能跳到的位置的dp值：
// 368ms class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;int&amp;gt; dp(len, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; len; ++i) { int steps = nums[i]; for (int j = 1; j &amp;lt;= steps &amp;amp;&amp;amp; i+j &amp;lt; len; ++j) { dp[i+j] = min(dp[i+j], dp[i]+1); } } return dp[len-1]; } }; 上述代码执行时耗368ms，有一个简单的优化：如果这个结点跳的最远点的dp值不能被本次优化，这次就不用遍历优化了：
// 36ms class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.</description>
    </item>
    
    <item>
      <title>43. 字符串相乘</title>
      <link>https://engineers.cool/leetcode/leetcode/43/</link>
      <pubDate>Sun, 11 Jul 2021 09:57:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/43/</guid>
      <description>原题链接
直观的思路是模拟乘法竖式，乘数的从右到左的每一位与被乘数相乘，然后相加，得到答案；注意不要漏了进位：
class Solution { public: string multiply(string num1, string num2) { if (num1 == &amp;#34;0&amp;#34; || num2 == &amp;#34;0&amp;#34;) return &amp;#34;0&amp;#34;; if (num2.length() &amp;gt; num1.length()) swap(num1, num2); string ans; int idx1 = num1.length()-1, idx2 = num2.length()-1; int carry = 0; for (int idx2 = num2.length()-1; idx2 &amp;gt;= 0; --idx2) { int step = num2.length()-1-idx2; string step_product = stepProduct(num1, num2[idx2], step); ans = sumStepProduct(ans, step_product); } return ans; } private: string stepProduct(string num1, char factor, int step) { string ans; int factor_n = factor-&amp;#39;0&amp;#39;; if (factor_n == 0) return &amp;#34;0&amp;#34;; if (factor_n == 1) return num1 + string(step, &amp;#39;0&amp;#39;); int idx1 = num1.</description>
    </item>
    
    <item>
      <title>40. 组合总和 II</title>
      <link>https://engineers.cool/leetcode/leetcode/40/</link>
      <pubDate>Sun, 11 Jul 2021 09:56:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/40/</guid>
      <description>原题链接
又是一道DFS题，注意点是不选idx是要不选所有idx一样的数字，否则会有重复的组合出现：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_state; DFS(candidates, 0, dfs_state, target, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int idx, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, int target, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (target == 0) { ans.push_back(dfs_state); return; } else if (idx &amp;gt;= candidates.size()) { return; } // 选idx  if (candidates[idx] &amp;lt;= target) { dfs_state.push_back(candidates[idx]); DFS(candidates, idx+1, dfs_state, target-candidates[idx], ans); dfs_state.pop_back(); } // 不选idx  while (++idx &amp;lt; candidates.</description>
    </item>
    
    <item>
      <title>39. 组合总和</title>
      <link>https://engineers.cool/leetcode/leetcode/39/</link>
      <pubDate>Sun, 11 Jul 2021 09:55:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/39/</guid>
      <description>原题链接
标准的回溯算法：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_state; DFS(candidates, 0, dfs_state, target, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int start, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, int target, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (target == 0) { ans.push_back(dfs_state); return; } else if (start &amp;gt;= candidates.size()) { return; } for (int i = start; i &amp;lt; candidates.size(); ++i) { if (candidates[i] &amp;gt; target) break; dfs_state.</description>
    </item>
    
    <item>
      <title>38. 外观数列</title>
      <link>https://engineers.cool/leetcode/leetcode/38/</link>
      <pubDate>Sun, 11 Jul 2021 09:54:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/38/</guid>
      <description>原题链接
朴素的模拟思想：
class Solution { public: string countAndSay(int n) { int now_cnt = 1; string now_str = &amp;#34;1&amp;#34;; while (now_cnt &amp;lt; n) { now_cnt++; now_str = readstr(now_str); } return now_str; } private: string readstr(string&amp;amp; s) { string read_str = &amp;#34;&amp;#34;; char now_c = s[0]; int now_cnt = 1; for (int i = 1; i &amp;lt; s.length(); ++i) { if (s[i] == now_c) { now_cnt++; continue; } read_str.append(to_string(now_cnt)).push_back(now_c); now_c = s[i]; now_cnt = 1; } read_str.</description>
    </item>
    
    <item>
      <title>36. 有效的数独</title>
      <link>https://engineers.cool/leetcode/leetcode/36/</link>
      <pubDate>Sun, 11 Jul 2021 09:53:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/36/</guid>
      <description>原题链接
 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）  数独部分空格内已填入了数字，空白格用 &amp;lsquo;.&amp;rsquo; 表示。
 顺序遍历每个格子，检查&amp;amp;&amp;amp;更新这个格子分别在三种情况维护的状态即可：
class Solution { vector&amp;lt;long long&amp;gt; vis = vector&amp;lt;long long&amp;gt;(27); public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int n = board.size(); for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) { if (board[i][j] == &amp;#39;.&amp;#39;) continue; if (updateNum(i, j, board[i][j]-&amp;#39;0&amp;#39;)) continue; return false; } } return true; } private: bool updateNum(int x, int y, int num) { vector&amp;lt;int&amp;gt; update_pos = {x, y+9, x/3+(y/3)*3+18}; long long base = 1; for (int pos : update_pos) { if (vis[pos] &amp;amp; (base&amp;lt;&amp;lt;num)) return false; vis[pos] |= (base&amp;lt;&amp;lt;num); } return true; } }; </description>
    </item>
    
    <item>
      <title>35. 搜索插入位置</title>
      <link>https://engineers.cool/leetcode/leetcode/35/</link>
      <pubDate>Sun, 11 Jul 2021 09:52:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/35/</guid>
      <description>原题链接
 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
 标准的二分查找
class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size()-1; while (l &amp;lt;= r) { int mid = l+(r-l)/2; if (nums[mid] == target) { return mid; } else if (nums[mid] &amp;lt; target) { l = mid+1; } else if (nums[mid] &amp;gt; target) { r = mid-1; } } return l; } }; </description>
    </item>
    
    <item>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://engineers.cool/leetcode/leetcode/34/</link>
      <pubDate>Sun, 11 Jul 2021 09:51:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/34/</guid>
      <description>原题链接
 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
 class Solution { public: vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { return {leftBound(nums, target), rightBound(nums, target)}; } private: int leftBound(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size()-1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (nums[mid] == target) { r = mid-1; } else if (nums[mid] &amp;lt; target) { l = mid+1; } else { // nums[mid] &amp;gt; target  r = mid-1; } } if (l &amp;gt;= nums.</description>
    </item>
    
    <item>
      <title>33. 搜索旋转排序数组</title>
      <link>https://engineers.cool/leetcode/leetcode/33/</link>
      <pubDate>Sun, 11 Jul 2021 09:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/33/</guid>
      <description>原题描述
先找到最小的数字，然后截成两节做二分查找：
class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int len = nums.size(); if (len == 1) return nums[0] == target ? 0 : -1; // 先找到最小值  int s = 0, e = len-1; int smallest_idx = -1; while (s &amp;lt;= e) { int mid = (s+e)/2; if (isSmallest(nums, mid)) { smallest_idx = mid; break; } if (s == mid) { ++s; } else if (e == mid) { ++e; } else if (nums[s] &amp;lt; nums[mid] &amp;amp;&amp;amp; nums[e] &amp;lt; nums[mid]) { s = mid+1; } else { e = mid-1; } } int result = binarySearch(nums, 0, smallest_idx-1, target); if (result !</description>
    </item>
    
    <item>
      <title>31. 下一个排列</title>
      <link>https://engineers.cool/leetcode/leetcode/31/</link>
      <pubDate>Sat, 10 Jul 2021 09:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/31/</guid>
      <description>原题描述
两层循环遍历：
 第一层倒叙枚举 会被冒泡到的位置（P1）(即第一个顺序的元素) 第二层倒叙枚举 冒泡的元素的位置（即第一个大于位置P1元素的位置P2） 然后交换，并重排 P1~结尾 的元素（从小大大）  class Solution { public: void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); // 枚举冒到的位置  for (int up_tartget = len-2; up_tartget &amp;gt;= 0; --up_tartget) { // 找可以冒上去的数字  for (int up_idx = len-1; up_idx &amp;gt; up_tartget; --up_idx) { if (nums[up_idx] &amp;lt;= nums[up_tartget]) continue; // 找到了！  // 交换 然后后面那段重新排序  int tmp = nums[up_idx]; nums[up_idx] = nums[up_tartget]; nums[up_tartget] = tmp; sort(nums.</description>
    </item>
    
    <item>
      <title>29. 两数相除</title>
      <link>https://engineers.cool/leetcode/leetcode/29/</link>
      <pubDate>Sat, 10 Jul 2021 09:45:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/29/</guid>
      <description>原题描述
下面是一开始的朴素思想：
 判断结果是整数还是负数 循环 对被除数 减去（加上） 除数，直到被除数绝对值小于除数绝对值  class Solution { public: int divide(int dividend, int divisor) { if (dividend == INT_MIN &amp;amp;&amp;amp; divisor == -1) return INT_MAX; bool is_not_same_sign = (dividend&amp;amp;(1&amp;lt;&amp;lt;31)) ^ (divisor&amp;amp;(1&amp;lt;&amp;lt;31)); int ans = 0; int big_divisor = divisor; while (fabs(dividend) &amp;gt; fabs(divisor)) { if (is_not_same_sign) dividend += divisor; else dividend -= divisor; ++ans; } return ans; } }; 问题在于，在除数比较小的时候，步骤2效率太低。需要对这个步骤增速，由于限制了乘法那么一个好的增速方法是加法，加法翻倍，指数级增速：
class Solution { public: int divide(int dividend, int divisor) { // 边界情况  if (divisor == 1) return dividend; if (divisor == -1) { if (dividend == INT_MIN) return INT_MAX; return -dividend; } bool is_not_same_sign = (dividend&amp;amp;(1&amp;lt;&amp;lt;31)) ^ (divisor&amp;amp;(1&amp;lt;&amp;lt;31)); int sign = is_not_same_sign ?</description>
    </item>
    
    <item>
      <title>28. 实现strStr()</title>
      <link>https://engineers.cool/leetcode/leetcode/28/</link>
      <pubDate>Sat, 10 Jul 2021 09:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/28/</guid>
      <description>原题描述
?&amp;gt; 为什么这道题是&amp;quot;简单&amp;quot;&amp;hellip;没学过的话 肯定完全搞不出来吧！
class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; vector&amp;lt;int&amp;gt; next(needle.length()); gen_next(needle, next); int m = 0; int p = 0; while (m &amp;lt; haystack.length() &amp;amp;&amp;amp; p &amp;lt; needle.length()) { if (haystack[m] == needle[p]) { ++m; ++p; } else if (p) { p = next[p-1]; } else { ++m; } } if (p == needle.length()) { return m-p; } return -1; } private: void gen_next(string&amp;amp; pattern, vector&amp;lt;int&amp;gt;&amp;amp; next) { next[0] = 0; int p = 1; int now = 0; while (p &amp;lt; pattern.</description>
    </item>
    
    <item>
      <title>27. 移除元素</title>
      <link>https://engineers.cool/leetcode/leetcode/27/</link>
      <pubDate>Sat, 10 Jul 2021 09:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/27/</guid>
      <description>原题描述
跟上一题一样，快慢&amp;quot;指针&amp;quot;：
class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int slow = 0, fast = 0; while(fast &amp;lt; nums.size()) { if (nums[fast] != val) nums[slow++] = nums[fast]; ++ fast; } return slow; } }; 优化思路：操作数据结构是数据，假设极端情况只有第一个元素要删除，这样还用方法一做顺序遍历的话，会有很多次Copy。那么，优化思路就是第二个&amp;quot;指针&amp;quot;从后向前遍历：
class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int start = 0, end = nums.size()-1; while(start &amp;lt;= end) { if (nums[start] != val) { ++start; continue; } if (nums[end] != val) nums[start++] = nums[end]; --end; } return start; } }; </description>
    </item>
    
    <item>
      <title>26. 删除有序数组中的重复项</title>
      <link>https://engineers.cool/leetcode/leetcode/26/</link>
      <pubDate>Sat, 10 Jul 2021 09:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/26/</guid>
      <description>原题描述
双指针：
class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); if (len == 0) { return 0; } int slow = 0, fast = 0; while (++fast &amp;lt; len) { if (nums[fast] == nums[slow]) continue; nums[++slow] = nums[fast]; } return slow+1; } }; </description>
    </item>
    
    <item>
      <title>24. 两两交换链表中的结点</title>
      <link>https://engineers.cool/leetcode/leetcode/24/</link>
      <pubDate>Sat, 10 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/24/</guid>
      <description>原题描述
思路：
 定义两个指针，指向要交换的两个结点签名 如果可以交换，则操作first-&amp;gt;next / second-&amp;gt;next-&amp;gt;next指针进行交换，以及递推 如果不可以交换，则保持现状  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0, head); ListNode* first = head; ListNode* second = dummy; while(first) { second-&amp;gt;next = first-&amp;gt;next; if (second-&amp;gt;next) { first-&amp;gt;next = second-&amp;gt;next-&amp;gt;next; second-&amp;gt;next-&amp;gt;next = first; } else { second-&amp;gt;next = first; } second = first; first = first-&amp;gt;next; } ListNode* ans = dummy-&amp;gt;next; delete dummy; return ans; } }; 跟上题一样，我的思路总是递推，官方题解还有一种递归思路（写起来更简单 也更容易理解）：</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/22/</link>
      <pubDate>Sat, 10 Jul 2021 09:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/22/</guid>
      <description>原题描述
标准的回溯（DFS）算法：
class Solution { public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) { vector&amp;lt;string&amp;gt; gen_brackets; string dfs_str; DFS(dfs_str, 0, 0, n, gen_brackets); return gen_brackets; } private: void DFS(string&amp;amp; dfs_str, int left, int right, int n, vector&amp;lt;string&amp;gt;&amp;amp; gen_brackets) { if (left == n &amp;amp;&amp;amp; right == n) { // 或者判断 dfs_str.size() ==n*2  gen_brackets.push_back(dfs_str); return; } if (left &amp;lt; n) { dfs_str.push_back(&amp;#39;(&amp;#39;); DFS(dfs_str, left+1, right, n, gen_brackets); dfs_str.pop_back(); } if (right &amp;lt; left) { dfs_str.</description>
    </item>
    
    <item>
      <title>20. 有效的括号</title>
      <link>https://engineers.cool/leetcode/leetcode/20/</link>
      <pubDate>Sat, 10 Jul 2021 09:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/20/</guid>
      <description>原题描述
用栈辅助配对即可，注意获取栈顶前要先判断是否为空。
class Solution { unordered_map&amp;lt;char, char&amp;gt; right_to_left = { {&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;}, {&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;}, {&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;}, }; bool isRightBracket(const char c) const{ return right_to_left.count(c); } public: bool isValid(string s) { if (s.length()%2) return false; stack&amp;lt;char&amp;gt; brackets; for (auto c : s) { if (isRightBracket(c)) { if (brackets.empty() || brackets.top() != right_to_left[c]) { return false; } else { brackets.pop(); } } else { brackets.push(c); } } return brackets.empty(); } }; </description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/21/</link>
      <pubDate>Sat, 10 Jul 2021 09:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/21/</guid>
      <description>原题描述
基于归并排序的思想，merge两个链表即可：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0, nullptr); ListNode* merge_tail = dummy; while (l1 || l2) { int v1 = l1 ?</description>
    </item>
    
    <item>
      <title>19. 删除链表的倒数第N个结点</title>
      <link>https://engineers.cool/leetcode/leetcode/19/</link>
      <pubDate>Sat, 10 Jul 2021 09:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/19/</guid>
      <description>原题描述
链表，无法下表访问，只能遍历，那么删除倒数第N个结点，只需要遍历两边就好了：
 第一次遍历，得到链表的长度 第二次遍历，删除第（len-n+1）个结点  但是题目表示中有表示：
?&amp;gt; 进阶：你能尝试使用一趟扫描实现吗？
看过题解后才发现，官方是想让我们继续强化双指针的思路：
 设计两个指针，第一个先行N个结点 随后两个指针一起遍历，第一个指针遍历到结尾的时候，删除第二个指针的next元素  另外题解中有两个比较好的建议：
  设计dummy结点，指向head，随后对链表的操作就不用特殊处理head结点了 因为要删除结点，这里确认下是否要求删除改结点的内存   /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0, head); ListNode* first = head; ListNode* second = dummy; for (int i = 0; i &amp;lt; n &amp;amp;&amp;amp; first; ++i) { first = first-&amp;gt;next; } while (first) { first = first-&amp;gt;next; second = second-&amp;gt;next; } //ListNode* delete_node = second-&amp;gt;next  second-&amp;gt;next = second-&amp;gt;next-&amp;gt;next; // delete delete_node;  ListNode* ans = dummy-&amp;gt;next; delete dummy; return ans; } }; </description>
    </item>
    
    <item>
      <title>18. 四数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/18/</link>
      <pubDate>Sat, 10 Jul 2021 09:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/18/</guid>
      <description>原题描述
完全类比15. 三数之和与16. 最接近的三数之和，排序然后双指针遍历最后两个：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinations; if (nums.size() &amp;lt; 4) return combinations; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i!=0 &amp;amp;&amp;amp; nums[i]==nums[i-1]) continue; for (int j = i+1; j &amp;lt; nums.size(); ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j]==nums[j-1]) continue; int k = j+1, l = nums.size()-1; while (k &amp;lt; l) { long long sum_now = (long long)nums[i]+(long long)nums[j]+(long long)nums[k]+(long long)nums[l]; if (sum_now == (long long)target) { combinations.</description>
    </item>
    
    <item>
      <title>17. 电话号码的字母组合</title>
      <link>https://engineers.cool/leetcode/leetcode/17/</link>
      <pubDate>Sat, 10 Jul 2021 09:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/17/</guid>
      <description>原题描述
简单回溯（DFS）题目，预先构建好数字到可选字幕的映射：
class Solution { const vector&amp;lt;string&amp;gt; num_to_chars = { &amp;#34;&amp;#34;/*0*/,&amp;#34;&amp;#34;/*1*/,&amp;#34;abc&amp;#34;,&amp;#34;def&amp;#34;,&amp;#34;ghi&amp;#34;,&amp;#34;jkl&amp;#34;,&amp;#34;mno&amp;#34;,&amp;#34;pqrs&amp;#34;,&amp;#34;tuv&amp;#34;,&amp;#34;wxyz&amp;#34; }; public: vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if (digits.size() == 0) { return {}; } vector&amp;lt;string&amp;gt; ans; string dfs_str; DFS(digits, 0, dfs_str, ans); return ans; } private: void DFS(string digits, int deep, string dfs_str, vector&amp;lt;string&amp;gt;&amp;amp; ans) { if (deep &amp;gt;= digits.size()) { ans.push_back(dfs_str); return; } char now_deep_char = digits[deep]; for (auto c : num_to_chars[now_deep_char-&amp;#39;0&amp;#39;]) { dfs_str.push_back(c); DFS(digits, deep+1, dfs_str, ans); dfs_str.</description>
    </item>
    
    <item>
      <title>16. 最接近的三数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/16/</link>
      <pubDate>Fri, 09 Jul 2021 09:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/16/</guid>
      <description>原题链接
class Solution { public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int ans = INT_MAX; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i!=0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; for (int j = i+1; j &amp;lt; nums.size()-1; ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1]) continue; // search k  int target_k_val = target -(nums[i]+nums[j]); int nearest_k_val = findNearest(nums, j+1, nums.size(), target_k_val); int nearest_val = nums[i]+nums[j]+nearest_k_val; ans = selectNearest(target, nearest_val, ans); } } return ans; } private: int findNearest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int idx_s, int idx_e, int target) { // hack improve  if (nums[idx_s] &amp;gt; target) return nums[idx_s]; if (nums[idx_e-1] &amp;lt; target) return nums[idx_e-1]; int nearest_val = INT_MAX; while(idx_s &amp;lt; idx_e) { int mid = (idx_s+idx_e)/2; nearest_val = selectNearest(target, nearest_val, nums[idx_s]); nearest_val = selectNearest(target, nearest_val, nums[mid]); if (nums[mid] == target) { return nums[mid]; } else if (nums[mid] &amp;gt; target) { idx_e = mid; } else if (nums[mid] &amp;lt; target) { idx_s = mid+1; } }; return nearest_val; } int selectNearest(int target, int v1, int v2) { return fabs((target-v1) &amp;lt; fabs((long long)target-(long long)v2) ?</description>
    </item>
    
    <item>
      <title>15. 三数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/15/</link>
      <pubDate>Fri, 09 Jul 2021 09:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/15/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i != 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; int k = nums.size()-1; for (int j = i+1; j &amp;lt; nums.size()-1; ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1]) continue; int sum = -1; while(j&amp;lt;k &amp;amp;&amp;amp; (sum = nums[i]+nums[j]+nums[k]) &amp;gt; 0) { --k; } if (j == k) break; if (sum == 0) { ans.</description>
    </item>
    
    <item>
      <title>14. 最长公共前缀</title>
      <link>https://engineers.cool/leetcode/leetcode/14/</link>
      <pubDate>Wed, 07 Jul 2021 09:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/14/</guid>
      <description>原题链接
class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if (strs.size() == 0) return &amp;#34;&amp;#34;; string comm_prefix; int idx = 0; while (true) { if (idx &amp;gt;= strs[0].size()) { break; } bool all_same_char = true; char this_char = strs[0][idx]; for (auto str : strs) { if (idx &amp;gt;= str.size() || this_char != str[idx]) { all_same_char = false; break; } } if (all_same_char) comm_prefix.push_back(this_char); else break; idx++; } return comm_prefix; } }; </description>
    </item>
    
    <item>
      <title>13. 罗马数字转整数</title>
      <link>https://engineers.cool/leetcode/leetcode/13/</link>
      <pubDate>Wed, 07 Jul 2021 09:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/13/</guid>
      <description>原题链接
class Solution { public: int romanToInt(string s) { unordered_map&amp;lt;char, int&amp;gt; roman_val = { {&amp;#39;I&amp;#39;, 1}, {&amp;#39;V&amp;#39;, 5}, {&amp;#39;X&amp;#39;, 10}, {&amp;#39;L&amp;#39;, 50}, {&amp;#39;C&amp;#39;, 100}, {&amp;#39;D&amp;#39;, 500}, {&amp;#39;M&amp;#39;, 1000}, }; int val = 0; int last_roman_val = 1000; for (auto c : s) { int v = roman_val[c]; val += v &amp;lt;= last_roman_val ? v : (last_roman_val*-2+v); last_roman_val = v; } return val; } }; </description>
    </item>
    
    <item>
      <title>12. 整数转罗马数字</title>
      <link>https://engineers.cool/leetcode/leetcode/12/</link>
      <pubDate>Wed, 07 Jul 2021 09:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/12/</guid>
      <description>原题链接
class Solution { public: string intToRoman(int num) { string roman; vector&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; case_reps = { {1000, &amp;#34;M&amp;#34;}, {900, &amp;#34;CM&amp;#34;}, {500, &amp;#34;D&amp;#34;}, {400, &amp;#34;CD&amp;#34;}, {100, &amp;#34;C&amp;#34;}, {90, &amp;#34;XC&amp;#34;}, {50, &amp;#34;L&amp;#34;}, {40, &amp;#34;XL&amp;#34;}, {10, &amp;#34;X&amp;#34;}, {9, &amp;#34;IX&amp;#34;}, {5, &amp;#34;V&amp;#34;}, {4, &amp;#34;IV&amp;#34;}, {1, &amp;#34;I&amp;#34;} }; for (auto case_rep : case_reps) { while(num &amp;gt;= case_rep.first) { num -= case_rep.first; roman += case_rep.second; } } return roman; } }; </description>
    </item>
    
    <item>
      <title>11. 盛最多水的容器</title>
      <link>https://engineers.cool/leetcode/leetcode/11/</link>
      <pubDate>Wed, 07 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/11/</guid>
      <description>原题链接
核心思路：减少搜索空间。指针每一次移动，都意味着排除掉了一个柱子。
为什么可以安全排除这跟柱子呢？
从最两端的柱子考虑，如果固定较短的柱子不动，那么不管怎么动另外一根，都不会有更大的答案出现；那么较短的柱子在剩余问题（剩余可能结果）的解决就完全没有作用了，可以丢弃；
class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int start = 0, end = height.size()-1; int area = 0; while(start &amp;lt; end) { area = max(area, (end-start)*min(height[start], height[end])); if (height[start] &amp;gt; height[end]) { end--; } else { start++; } } return area; } }; </description>
    </item>
    
    <item>
      <title>9. 回文数</title>
      <link>https://engineers.cool/leetcode/leetcode/9/</link>
      <pubDate>Wed, 07 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/9/</guid>
      <description>原题链接
class Solution { public: bool isPalindrome(int x) { if (x &amp;lt; 0) return 0; string l_r, r_l; while(x) { int v = x%10; x /= 10; string s(1, &amp;#39;0&amp;#39;+v); l_r = s + l_r; r_l = r_l + s; } return r_l == l_r; } }; 还是太年轻了。官方方法是反转一半数字然后跟剩余未反转部分做比较：
class Solution { public: bool isPalindrome(int x) { // 特殊情况增加，末尾是0的非零输入 直接返回false  if (x &amp;lt; 0 || (x%10 == 0 &amp;amp;&amp;amp; x !</description>
    </item>
    
    <item>
      <title>8. 字符串转换整数 (atoi) </title>
      <link>https://engineers.cool/leetcode/leetcode/8/</link>
      <pubDate>Tue, 06 Jul 2021 21:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/8/</guid>
      <description>原题链接
按描述编码的模拟题，貌似没有什么要注意的点。
class Solution { public: int myAtoi(string s) { int ans = 0; int idx = 0; // 丢弃无用的前导空格  while(idx &amp;lt; s.size() &amp;amp;&amp;amp; s[idx] == &amp;#39; &amp;#39;) idx++; if (idx &amp;gt;= s.size()) { return 0; } // 扫描正负符号  bool is_neg = false; if (s[idx] == &amp;#39;-&amp;#39;) { is_neg = true; idx++; } else if (s[idx] == &amp;#39;+&amp;#39;) { idx++; } // 扫描接下来的数字  while(idx &amp;lt; s.size() &amp;amp;&amp;amp; isdigit(s[idx])) { int v = s[idx] - &amp;#39;0&amp;#39;; v = is_neg ?</description>
    </item>
    
    <item>
      <title>7. 整数反转</title>
      <link>https://engineers.cool/leetcode/leetcode/7/</link>
      <pubDate>Tue, 06 Jul 2021 21:40:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/7/</guid>
      <description>原题链接
整体思路比较明确：循环取数字的最后一位，加到反转数字的后面（预先判断加上去会不会溢出，溢出则返回0）。
class Solution { public: int reverse(int x) { int new_val = 0; while (x) { int n = x%10; // 取到case数字的最后一位  x /= 10; // case数字去掉最后一位  // 加往新数字前，判断是否会溢出  if (new_val &amp;lt; nearly_overflow_min || new_val &amp;gt; nearly_overflow_max) { return 0; // } else if (new_val == nearly_overflow_min &amp;amp;&amp;amp; n &amp;lt; nearly_overflow_min_append) {  // return 0;  // } else if (new_val == nearly_overflow_max &amp;amp;&amp;amp; n &amp;gt; nearly_overflow_max_append) {  // return 0;  } new_val = new_val*10+n; // 加到反转数字上  } return new_val; } private: int nearly_overflow_min = (1&amp;lt;&amp;lt;31)/10; // int nearly_overflow_min_append = (1&amp;lt;&amp;lt;31)%10;  int nearly_overflow_max = (~(1&amp;lt;&amp;lt;31))/10; // int nearly_overflow_max_append = (~(1&amp;lt;&amp;lt;31))%10;  }; 比较有意思的是判断溢出，我原本的想法是，有以下三种溢出的情况：</description>
    </item>
    
    <item>
      <title>6. Z 字形变换</title>
      <link>https://engineers.cool/leetcode/leetcode/6/</link>
      <pubDate>Tue, 06 Jul 2021 21:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/6/</guid>
      <description>原题链接
读完题后，首先把题示的例子手算一下，然后就想着找规律。确实也有规律，但是代码写出来难懂。
class Solution { public: string convert(string s, int numRows) { if (numRows == 1) return s; int delta = numRows*2-2; string ans; for (int i = 0; i &amp;lt; numRows; ++i) { for (int j = 0; j + i &amp;lt; s.size(); j += delta) { ans += s[j + i]; if (i == 0 || i == numRows-1) continue; if (j + delta - i &amp;lt; s.size()) ans += s[j + delta - i]; } } return ans; } }; 看了题解后，其实有一个朴素的思路，就是按题目的描述，遍历字符串按Z字形拼接到各行，最后再把所有行拼接起来即可。</description>
    </item>
    
    <item>
      <title>5. 最长回文子串</title>
      <link>https://engineers.cool/leetcode/leetcode/5/</link>
      <pubDate>Tue, 06 Jul 2021 20:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/5/</guid>
      <description>原题链接
朴素的，从回文串的定义考虑，中心对称的串，那么从中心向外扩张遍历即可；枚举每个中心（考虑 奇偶），向外遍历即可。
唯一要注意的点是，回文串可以是偶数长度，即中心的两个字符一样，一起为中心。
class Solution { public: string longestPalindrome(string s) { int start = 0, end = 0; for (int p = 0; p &amp;lt; s.size(); ++p) { auto [start1, end1] = expandStr(p, p, s); auto [start2, end2] = expandStr(p, p+1, s); if (end1-start1 &amp;gt; end-start) { start = start1; end = end1; } if (end2-start2 &amp;gt; end-start) { start = start2; end = end2; } } return s.substr(start, end-start+1); } private: pair&amp;lt;int, int&amp;gt; expandStr(int l, int r, const string&amp;amp; s) { while(l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; s.</description>
    </item>
    
    <item>
      <title>3. 无重复字符的最长子串</title>
      <link>https://engineers.cool/leetcode/leetcode/3/</link>
      <pubDate>Sun, 04 Jul 2021 20:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/3/</guid>
      <description>原题链接
官方的解法 &amp;amp;&amp;amp; 我的思路，滑动窗口，稍微有些不同：
 官方解法是遍历起点，额外记录终点；  在遍历中，把前一字符从集合去掉，然后while扩展终点，直到有重复字符；   我的思路是遍历终点，额外记录起点；  在遍历中，把当前字符加到集合，while从起点缩减字符，直到没有重复字符；    本质一样，都是滑动窗口，
class Solution { public: int lengthOfLongestSubstring(string s) { int max_substr_len = 0; unordered_set&amp;lt;char&amp;gt; flag; int s_len = s.length(); int cur_substr_start_pos = 0; // 当前无重复字符子串的起点  for (int i = 0; i &amp;lt; s_len; ++i) { // 遍历终点  while (flag.find(s[i]) != flag.end()) { // 以当前字符为重点，缩减起点开始的字符，直到没有重复字符  flag.erase(s[cur_substr_start_pos]); cur_substr_start_pos += 1; } // 记录当前字符到集合，并更新答案  flag.</description>
    </item>
    
    <item>
      <title>2. 两数相加</title>
      <link>https://engineers.cool/leetcode/leetcode/2/</link>
      <pubDate>Sun, 04 Jul 2021 10:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/2/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode * head = nullptr, * tail = nullptr; int carry = 0; // 加法进位  while(l1 || l2) { int val1 = l1 ?</description>
    </item>
    
    <item>
      <title>1. 两数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/1/</link>
      <pubDate>Mon, 21 Jun 2021 09:49:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/1/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int, int&amp;gt; hashtable; int nums_size = nums.size(); for (int idx = 0; idx &amp;lt; nums_size; ++idx) { int other_value = target - nums[idx]; if (hashtable.count(other_value) == 1) { return {hashtable[other_value], idx}; } hashtable[nums[idx]] = idx; } return {}; } }; </description>
    </item>
    
    <item>
      <title>总结</title>
      <link>https://engineers.cool/leetcode/summery/</link>
      <pubDate>Fri, 03 Jul 2020 08:13:53 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/summery/</guid>
      <description>随便找的一个面试题出现次数  206. 反转链表 146. LRU缓存机制 8. 字符串转换整数（atoi） 153. 寻找旋转排序数组中的最小值 3. 无重复自负的最长子串 剑指Offer 54. 二叉搜索树的第k大结点 300. 最长上升子序列 2. 两数相加 470. 用Rand7()实现Rand10() 112. 路径总和  旋转数据查找 二分查找框架 int binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left &amp;lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] &amp;lt; target) { left = mid + 1; } else if (nums[mid] &amp;gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回  return mid; } } // 直接返回  return -1; } int left_bound(int[] nums, int target) { int left = 0, right = nums.</description>
    </item>
    
    <item>
      <title>Resume</title>
      <link>https://engineers.cool/resume/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://engineers.cool/resume/</guid>
      <description>About Me  This is a Hugo based resume template. You can find the full source code on GitHub.
Research Interest Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam finibus ipsum ac erat aliquam dapibus. Vestibulum vehicula placerat ex, a consectetur odio pharetra quis1. Mauris id urna ante.
Fusce pharetra diam ac nisi aliquet, velegestas ex iaculis. Pellentesque laoreet cursus tellus sed pellentesque. Praesent a rhoncus elit2. Nunc ipsum nisl, consequat sit amet pretium quis, gravida id ipsum.</description>
    </item>
    
  </channel>
</rss>
