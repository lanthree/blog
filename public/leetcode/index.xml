<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on Engineers Cool</title>
    <link>https://engineers.cool/leetcode/</link>
    <description>Recent content in Leetcodes on Engineers Cool</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Oct 2021 10:27:00 +0800</lastBuildDate><atom:link href="https://engineers.cool/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>118. 杨辉三角</title>
      <link>https://engineers.cool/leetcode/leetcode/118/</link>
      <pubDate>Thu, 14 Oct 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/118/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; ret.push_back({1}); int nowRow = 0; while (++nowRow &amp;lt; numRows) { ret.push_back({1}); for (int i = 0; i &amp;lt; ret[nowRow-1].size()-1; ++i) { ret[nowRow].push_back(ret[nowRow-1][i] + ret[nowRow-1][i+1]); } ret[nowRow].push_back(1); } return ret; } }; </description>
    </item>
    
    <item>
      <title>125. 验证回文串</title>
      <link>https://engineers.cool/leetcode/leetcode/125/</link>
      <pubDate>Fri, 08 Oct 2021 10:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/125/</guid>
      <description>原题链接
class Solution { public: bool isPalindrome(string s) { int l = 0, r = s.length()-1; while (l &amp;lt; r) { char lc = _get_next(s, l, 1); if (lc == &amp;#39; &amp;#39;) { return true; } char lr = _get_next(s, r, -1); if (lc != lr) { return false; } } return true; } private: char _get_next(const string&amp;amp; s, int&amp;amp; idx, int dir) { char ret_c = &amp;#39; &amp;#39;; while (true) { if (idx &amp;lt; 0 || idx &amp;gt;= s.</description>
    </item>
    
    <item>
      <title>124. 二叉树中的最大路径和</title>
      <link>https://engineers.cool/leetcode/leetcode/124/</link>
      <pubDate>Fri, 08 Oct 2021 10:29:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/124/</guid>
      <description>原题链接
递归遍历，返回包含该结点的（可能包含该结点左子树或右子树）的子树最大值，遍历过程中更新答案值：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { int max_v_ = INT_MIN; public: int maxPathSum(TreeNode* root) { _calc_max_v(root); return max_v_; } private: int _calc_max_v(TreeNode* node) { if (node == nullptr) { return 0; } int left_max = max(_calc_max_v(node-&amp;gt;left), 0); int right_max = max(_calc_max_v(node-&amp;gt;right), 0); max_v_ = max(max_v_, node-&amp;gt;val + left_max + right_max); return node-&amp;gt;val + max(left_max, right_max); } }; </description>
    </item>
    
    <item>
      <title>122. 买卖股票的最佳时机 II</title>
      <link>https://engineers.cool/leetcode/leetcode/122/</link>
      <pubDate>Fri, 08 Oct 2021 10:28:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/122/</guid>
      <description>原题链接
2纬DP：
 dp[i][0]：表示i时没有股票，即i-1时有股票 i时卖出，或 i-1时没有股票 i时也没有操作 dp[i][1]：表示i时有股票，即i-1时有没股票 i时买入，或 i-1时有股票 i时也没有操作  class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(prices.size(), vector&amp;lt;int&amp;gt;(2, 0)); dp[0][0] = 0; dp[0][1] = -prices[0]; for (int i = 1; i &amp;lt; prices.size(); ++i) { dp[i][0] = max(dp[i-1][1] + prices[i], dp[i-1][0]); dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]); } return dp[prices.size()-1][0]; } }; 因为只用到上一轮迭代的dp值，故可以优化空间复杂度：
class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int dp_0 = 0; int dp_1 = -prices[0]; for (int i = 1; i &amp;lt; prices.</description>
    </item>
    
    <item>
      <title>121. 买卖股票的最佳时机</title>
      <link>https://engineers.cool/leetcode/leetcode/121/</link>
      <pubDate>Fri, 08 Oct 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/121/</guid>
      <description>原题链接
class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int ret = 0; int min_price = INT_MAX; for (int price : prices) { if (price &amp;lt; min_price) { min_price = price; continue; } ret = max(ret, price-min_price); } return ret; } }; </description>
    </item>
    
    <item>
      <title>128. 最长连续序列</title>
      <link>https://engineers.cool/leetcode/leetcode/128/</link>
      <pubDate>Tue, 28 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/128/</guid>
      <description>原题链接
先把所有数字放到unordered_set（hash集合）中，这样可以：
 去重 能够O(1)的判断某个数字是否在集合中  然后对于每个数字num，如果num-1不在集合中，则依次判断比num大的数字是否在集合中，并更新结果：
class Solution { unordered_map&amp;lt;int, int&amp;gt; nums_color; public: int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; nums_set; for (int num : nums) { nums_set.insert(num); } int max_len = 0; for (int num : nums_set) { if (nums_set.count(num-1)) { continue; } int current_num = num; int current_len = 1; while (nums_set.count(current_num+1)) { current_num += 1; current_len += 1; } max_len = max(max_len, current_len); } return max_len; } }; 另外还可以使用并查集的思路：</description>
    </item>
    
    <item>
      <title>127. 单词接龙</title>
      <link>https://engineers.cool/leetcode/leetcode/127/</link>
      <pubDate>Tue, 28 Sep 2021 10:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/127/</guid>
      <description>原题链接
构造一个邻接矩阵，然后跑Dijistra最短路：
class Solution { public: int ladderLength(string beginWord, string endWord, vector&amp;lt;string&amp;gt;&amp;amp; wordList) { wordList.push_back(beginWord); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; word_map; word_map.resize(wordList.size()); _init_word_map(wordList, word_map); int source_idx = -1, target_idx = -1; vector&amp;lt;int&amp;gt; dist(wordList.size(), INT_MAX); // vector&amp;lt;int&amp;gt; prev(wordList.size(), -1/*UNDEFINED*/);  unordered_set&amp;lt;int&amp;gt; Q; for (int i = 0; i &amp;lt; wordList.size(); ++i) { Q.insert(i); if (beginWord == wordList[i]) source_idx = i; if (endWord == wordList[i]) target_idx = i; } if (target_idx == -1) { return 0; } dist[source_idx] = 0; while (not Q.</description>
    </item>
    
    <item>
      <title>710. 黑名单中的随机数</title>
      <link>https://engineers.cool/leetcode/leetcode/710/</link>
      <pubDate>Thu, 23 Sep 2021 11:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/710/</guid>
      <description>原题链接
首先考虑inner_max_v_ = n - blacklist.size()为实际的随机数个数的范围，如果直接% inner_max_v_那么得到的值[0, inner_max_v_)中会有blacklist的数字，而且[inner_max_v_,n)中的不在blacklist中的数字也拿不到。
一个思路是，用 [inner_max_v_,n)中的不在blacklist中的数字 填充 [0, inner_max_v_)中blacklist的数字，即把前面的“坑”填上，只需记录这个填坑映射即可：
class Solution { public: Solution(int n, vector&amp;lt;int&amp;gt;&amp;amp; blacklist) { inner_max_v_ = n - blacklist.size(); unordered_set&amp;lt;int&amp;gt; blackset; blackset.insert(blacklist.begin(), blacklist.end()); sort(blacklist.begin(), blacklist.end()); for (int num : blacklist) { while (blackset.count(--n)); mapping_[num] = n; } } int pick() { int rand_n = rand() % inner_max_v_; if (mapping_.count(rand_n)) { return mapping_[rand_n]; } return rand_n; } private: unordered_map&amp;lt;int, int&amp;gt; mapping_; int inner_max_v_; }; </description>
    </item>
    
    <item>
      <title>130. 被围绕的区域</title>
      <link>https://engineers.cool/leetcode/leetcode/130/</link>
      <pubDate>Thu, 23 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/130/</guid>
      <description>原题链接
遍历最外围一圈，DFS搜索染色，最后再重涂一边board：
class Solution { vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{1,0},{0,1},{-1,0},{0,-1}}; int m_, n_; public: void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { m_ = board.size(); n_ = board[0].size(); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m_, vector&amp;lt;bool&amp;gt;(n_, false)); // 遍历最外围的&amp;#39;O&amp;#39;，对该&amp;#39;O&amp;#39;做邻接搜索染色：邻接的&amp;#39;O&amp;#39;保持还是&amp;#39;O&amp;#39;  for (int i = 1; i &amp;lt; m_-1; ++i) { _dfs(board, i, 0, vis); _dfs(board, i, n_-1, vis); } for (int j = 0; j &amp;lt; n_; ++j) { _dfs(board, 0, j, vis); _dfs(board, m_-1, j, vis); } // 将所有没有被染色的点，设置为&amp;#39;X&amp;#39;  for (int i = 0; i &amp;lt; m_; ++i) { for (int j = 0; j &amp;lt; n_; ++j) { if (!</description>
    </item>
    
    <item>
      <title>131. 分割回文串</title>
      <link>https://engineers.cool/leetcode/leetcode/131/</link>
      <pubDate>Wed, 22 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/131/</guid>
      <description>原题链接
纯DFS：
class Solution { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solutions_; public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; partition(string s) { vector&amp;lt;string&amp;gt; solution; _dfs(solution, s, 0); return solutions_; } private: void _dfs(vector&amp;lt;string&amp;gt;&amp;amp; solution, const string&amp;amp; s, int idx) { if (idx == s.length()) { solutions_.push_back(solution); return; } for (int i = idx+1; i &amp;lt;= s.length(); ++i) { const string&amp;amp; sub_str = s.substr(idx, i-idx); if (_isHuiWen(sub_str)) { solution.push_back(sub_str); _dfs(solution, s, i); solution.pop_back(); } } } bool _isHuiWen(const string&amp;amp; s) { int len = s.</description>
    </item>
    
    <item>
      <title>134. 加油站</title>
      <link>https://engineers.cool/leetcode/leetcode/134/</link>
      <pubDate>Tue, 21 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/134/</guid>
      <description>原题链接
class Solution { public: int canCompleteCircuit(vector&amp;lt;int&amp;gt;&amp;amp; gas, vector&amp;lt;int&amp;gt;&amp;amp; cost) { int total = 0, sub_total = 0, res = 0; int len = gas.size(); for (int i = 0; i &amp;lt; len; ++i) { total += gas[i] - cost[i]; sub_total += gas[i] - cost[i]; if (sub_total &amp;lt; 0) { res = i+1; sub_total = 0; } } if (total &amp;lt; 0) return -1; return res; } }; </description>
    </item>
    
    <item>
      <title>138. 复制带随机指针的链表</title>
      <link>https://engineers.cool/leetcode/leetcode/138/</link>
      <pubDate>Sat, 18 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/138/</guid>
      <description>原题链接
/* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { if (head == nullptr) { return nullptr; } Node dummy_old(0); dummy_old.next = head; Node dummy_new(0); Node* tail_new = &amp;amp;dummy_new; // 根据next新建链表 并记录结点对应关系  unordered_map&amp;lt;unsigned long long, unsigned long long&amp;gt; node_mapping; for (Node* curr = dummy_old.</description>
    </item>
    
    <item>
      <title>136. 只出现一次的数字</title>
      <link>https://engineers.cool/leetcode/leetcode/136/</link>
      <pubDate>Sat, 18 Sep 2021 10:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/136/</guid>
      <description>原题链接
class Solution { public: int singleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int num : nums) { ans ^= num; } return ans; } }; </description>
    </item>
    
    <item>
      <title>139. 单词拆分</title>
      <link>https://engineers.cool/leetcode/leetcode/139/</link>
      <pubDate>Thu, 16 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/139/</guid>
      <description>原题链接
先做的140. 单词拆分 II，所以一上来思路一样，只不过不需要记录所有的可能方案：
class Solution { unordered_map&amp;lt;int, bool&amp;gt; vis; unordered_set&amp;lt;string&amp;gt; words; public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { words.insert(wordDict.begin(), wordDict.end()); return _dfs(s, 0); } private: bool _dfs(const string&amp;amp; s, int idx) { if (vis.count(idx)) { return vis[idx]; } if (idx == s.length()) { vis[idx] = true; return vis[idx]; } for (int i = idx+1; i &amp;lt;= s.length(); ++i) { string sub_str = s.substr(idx, i-idx); if (words.count(sub_str) &amp;amp;&amp;amp; _dfs(s, i)) { vis[idx] = true; return true; } } vis[idx] = false; return false; } }; 另外可以用DP递推的方式：</description>
    </item>
    
    <item>
      <title>149. 直线上最多的点数</title>
      <link>https://engineers.cool/leetcode/leetcode/149/</link>
      <pubDate>Wed, 15 Sep 2021 10:35:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/149/</guid>
      <description>原题链接
暴力的遍历起点、终点计算斜率：
class Solution { public: int maxPoints(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; points) { if (points.size() &amp;lt;= 2) return points.size(); int ans = 0; for (int i = 0; i &amp;lt; points.size(); ++i) { unordered_map&amp;lt;int, int&amp;gt; cnt; for (int j = i+1; j &amp;lt; points.size(); ++j) { auto xl = _calc_xl(points[i], points[j]); ans = max(ans, ++cnt[_val(xl)]); } } return ans+1; } private: pair&amp;lt;int, int&amp;gt; _calc_xl(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) { pair&amp;lt;int, int&amp;gt; res; int d_x = b[0] - a[0]; int d_y = b[1] - a[1]; if (d_y == 0) { res.</description>
    </item>
    
    <item>
      <title>148. 排序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/148/</link>
      <pubDate>Wed, 15 Sep 2021 10:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/148/</guid>
      <description>原题链接
以O(log n)复杂度，而且不能随机访问的话，可以使用归并排序：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { return _mergeSort(head); } private: ListNode* _mergeSort(ListNode* head) { if (head == nullptr || head-&amp;gt;next == nullptr) { return head; } ListNode* dummy = new ListNode(); ListNode* slow = head; ListNode* quik = head-&amp;gt;next; while (quik &amp;amp;&amp;amp; quik-&amp;gt;next) { slow = slow-&amp;gt;next; quik = quik-&amp;gt;next-&amp;gt;next; } ListNode* last_half = slow-&amp;gt;next; slow-&amp;gt;next = nullptr; head = _mergeSort(head); last_half = _mergeSort(last_half); dummy-&amp;gt;next = nullptr; ListNode* tail = dummy; while (head &amp;amp;&amp;amp; last_half) { if (head-&amp;gt;val &amp;lt; last_half-&amp;gt;val) { tail-&amp;gt;next = head; head = head-&amp;gt;next; } else { tail-&amp;gt;next = last_half; last_half = last_half-&amp;gt;next; } tail = tail-&amp;gt;next; } while (head) { tail-&amp;gt;next = head; head = head-&amp;gt;next; tail = tail-&amp;gt;next; } while (last_half) { tail-&amp;gt;next = last_half; last_half = last_half-&amp;gt;next; tail = tail-&amp;gt;next; } ListNode* merged_head = dummy-&amp;gt;next; delete dummy; return merged_head; } }; 但是空间复杂度不是O(1)，是O(log n)，即栈空间。取消栈空间的方法，是自底向上归并，用循环替代递归：</description>
    </item>
    
    <item>
      <title>140. 单词拆分 II</title>
      <link>https://engineers.cool/leetcode/leetcode/140/</link>
      <pubDate>Wed, 15 Sep 2021 10:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/140/</guid>
      <description>原题链接
字典树 + DFS即可：
class Solution { struct TriNode { TriNode() : children(26, nullptr), is_word(false) {} vector&amp;lt;TriNode*&amp;gt; children; bool is_word; }; TriNode root; vector&amp;lt;string&amp;gt; solutions; public: vector&amp;lt;string&amp;gt; wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { _buildByDict(wordDict); // _printDict();  string solution; _dfs(solution, s, 0); return solutions; } private: void _dfs(string solution, string&amp;amp; s, int idx) { if (idx == s.length()) { solutions.push_back(solution); return; } TriNode* node = &amp;amp;root; for (int i = idx; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>227. 基本计算器 II</title>
      <link>https://engineers.cool/leetcode/leetcode/227/</link>
      <pubDate>Tue, 14 Sep 2021 11:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/227/</guid>
      <description>原题链接
class Solution { public: int calculate(string s) { vector&amp;lt;int&amp;gt; stk; char preSign = &amp;#39;+&amp;#39;; int num = 0; int n = s.length(); for (int i = 0; i &amp;lt; n; ++i) { if (isdigit(s[i])) { num = num * 10 + int(s[i] - &amp;#39;0&amp;#39;); } if (!isdigit(s[i]) &amp;amp;&amp;amp; s[i] != &amp;#39; &amp;#39; || i == n - 1) { switch (preSign) { case &amp;#39;+&amp;#39;: stk.push_back(num); break; case &amp;#39;-&amp;#39;: stk.push_back(-num); break; case &amp;#39;*&amp;#39;: stk.</description>
    </item>
    
    <item>
      <title>162. 寻找峰值</title>
      <link>https://engineers.cool/leetcode/leetcode/162/</link>
      <pubDate>Tue, 14 Sep 2021 10:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/162/</guid>
      <description>原题链接
原题提示O(log n)时间复杂度，就可以考虑二分，结合条件nums[-1] = nums[n] = -∞，可以二分查找时按增长的方向查找
 left &amp;lt; mid &amp;lt; right 则向右找 left &amp;gt; mid &amp;gt; right 则向左找  class Solution { public: int findPeakElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() == 1) return 0; int s = 0, e = nums.size()-1; while (s &amp;lt;= e) { int mid = s+(e-s)/2; if (_isPeak(mid, nums)) { return mid; } else if (_isSMB(mid, nums)) { s = mid+1; } else { e = mid-1; } } return 0; } private: bool _isPeak(int pos, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max = nums.</description>
    </item>
    
    <item>
      <title>169. 多数元素</title>
      <link>https://engineers.cool/leetcode/leetcode/169/</link>
      <pubDate>Thu, 09 Sep 2021 10:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/169/</guid>
      <description>原题链接
class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int half_n = nums.size()/2; unordered_map&amp;lt;int, int&amp;gt; cnt; for (int num : nums) { if (++cnt[num] &amp;gt; half_n) { return num; } } return -1; } }; 题解中有一个投票算法非常有意思：由于众数的个数大于n/2，即至少比其他数大1，认为每个数组出现一次时 要么表示给自己投一票 要么表示给另外一个数字减一票（如果其他数字票数不为0），那么最终票数为正的就是众数
class Solution { public: int majorityElement(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int candidate = -1; int count = 0; for (int num : nums) { if (num == candidate) ++count; else if (--count &amp;lt; 0) { candidate = num; count = 1; } } return candidate; } }; 群里大佬给了一个方案，是用c++标准库中的std::nth_element：</description>
    </item>
    
    <item>
      <title>166. 分数到小数</title>
      <link>https://engineers.cool/leetcode/leetcode/166/</link>
      <pubDate>Thu, 09 Sep 2021 10:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/166/</guid>
      <description>原题链接
主要是要考虑到边界情况
class Solution { public: string fractionToDecimal(int numerator, int denominator) { if (numerator == 0) { return &amp;#34;0&amp;#34;; } long long nn = numerator, dd = denominator; bool is_neg = false; if (nn &amp;lt; 0) { nn = -nn; is_neg = !is_neg; } if (dd &amp;lt; 0) { dd = -dd; is_neg = !is_neg; } long long zs = nn / dd; string ans(to_string(zs)); if (is_neg) { ans = &amp;#34;-&amp;#34; + ans; } nn = nn - zs*dd; if (nn == 0) { return ans; } ans.</description>
    </item>
    
    <item>
      <title>150. 逆波兰表达式求值</title>
      <link>https://engineers.cool/leetcode/leetcode/150/</link>
      <pubDate>Wed, 08 Sep 2021 10:36:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/150/</guid>
      <description>原题链接
class Solution { public: int evalRPN(vector&amp;lt;string&amp;gt;&amp;amp; tokens) { if (tokens.size() == 1) { return atoi(tokens[0].c_str()); } stack&amp;lt;int&amp;gt; st; int res = 0; for (const string&amp;amp; str : tokens) { if (is_op(str)) { int r = st.top(); st.pop(); int l = st.top(); st.pop(); res = _op(str, l, r); st.push(res); } else { st.push(atoi(str.c_str())); } } return res; } private: bool is_op(const string&amp;amp; str) { if (str == &amp;#34;+&amp;#34; || str == &amp;#34;-&amp;#34; || str == &amp;#34;*&amp;#34; || str == &amp;#34;/&amp;#34;) { return true; } return false; } int _op(const string&amp;amp; op, int l, int r) { if (op == &amp;#34;+&amp;#34;) { return l+r; } else if (op == &amp;#34;-&amp;#34;) { return l-r; } else if (op == &amp;#34;*&amp;#34;) { return l*r; } else { return l/r; } } }; </description>
    </item>
    
    <item>
      <title>155. 最小栈</title>
      <link>https://engineers.cool/leetcode/leetcode/155/</link>
      <pubDate>Tue, 07 Sep 2021 10:38:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/155/</guid>
      <description>原题链接
维护一个辅助栈：
clclass MinStack { public: /** initialize your data structure here. */ MinStack() { min_st.push(numeric_limits&amp;lt;int&amp;gt;::max()); } void push(int val) { st.push(val); min_st.push(min(val, min_st.top())); } void pop() { st.pop(); min_st.pop(); } int top() { return st.top(); } int getMin() { return min_st.top(); } private: private: stack&amp;lt;int&amp;gt; st; stack&amp;lt;int&amp;gt; min_st; }; </description>
    </item>
    
    <item>
      <title>152. 乘积最大子数组</title>
      <link>https://engineers.cool/leetcode/leetcode/152/</link>
      <pubDate>Tue, 07 Sep 2021 10:37:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/152/</guid>
      <description>原题链接
分治计算：
class Solution { public: int maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); return _maxProduct(nums, 0, len-1); } private: int _maxProduct(vector&amp;lt;int&amp;gt;&amp;amp; nums, int s, int e) { if (s == e) { return nums[s]; } int mid = s+(e-s)/2; auto mm1 = _iter_mm(nums, mid, (mid-s), -1); auto mm2 = _iter_mm(nums, mid+1, (e-mid-1), 1); int max_product = max(_maxProduct(nums, s, mid), _maxProduct(nums, mid+1, e)); if (mm1.first &amp;lt; 0 &amp;amp;&amp;amp; mm2.first &amp;lt; 0) { max_product = max(max_product, mm1.</description>
    </item>
    
    <item>
      <title>160. 相交链表</title>
      <link>https://engineers.cool/leetcode/leetcode/160/</link>
      <pubDate>Fri, 27 Aug 2021 10:40:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/160/</guid>
      <description>原题链接
如果可以用O(n)的额外存储，可以先遍历第一个链表，存储所有遍历过的地址，然后遍历第二个链表，看是否有已遍历过的
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { set&amp;lt;ListNode*&amp;gt; vis; for (ListNode* iter = headA; iter != nullptr; iter = iter-&amp;gt;next) vis.insert(iter); for (ListNode* iter = headB; iter != nullptr; iter = iter-&amp;gt;next) if (vis.count(iter)) return iter; return nullptr; } }; 另外一个思路是把其中一个链表反转，并尾部连接到另外一个链表，判断是否有环，有环则有交点。反转的目的是想定位交点的位置</description>
    </item>
    
    <item>
      <title>51. N 皇后</title>
      <link>https://engineers.cool/leetcode/leetcode/51/</link>
      <pubDate>Fri, 27 Aug 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/51/</guid>
      <description>原题链接
DFS搜索即可
class Solution { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; ans; public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int n) { vector&amp;lt;string&amp;gt; q(n, string(n, &amp;#39;.&amp;#39;)); DFS(n, 0, q); // ans.push_back(q);  return ans; } private: void DFS(int n, int d, vector&amp;lt;string&amp;gt;&amp;amp; q) { if (n == d) { ans.push_back(q); return; } int i = d; for (int j = 0; j &amp;lt; n; j++) { if (isValid(n, q, i, j)) { q[i][j] = &amp;#39;Q&amp;#39;; DFS(n, d+1, q); q[i][j] = &amp;#39;.</description>
    </item>
    
    <item>
      <title>172. 阶乘后的零</title>
      <link>https://engineers.cool/leetcode/leetcode/172/</link>
      <pubDate>Thu, 26 Aug 2021 10:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/172/</guid>
      <description>原题链接
问题可以转换为统计阶乘所有数字的质因数分解中2的个数和5的个数，取其最小值。但是这个计数过程直观上是一个O(nlogn)的复杂度：
class Solution { public: int trailingZeroes(int n) { int cnt_2 = counter(n, 2); int cnt_5 = counter(n, 5); return min(cnt_2, cnt_5); } private: int counter(int n, int base) { int cnt = 0; while (n) { if (n % base == 0) { int now_n = n; while (now_n != 0 &amp;amp;&amp;amp; now_n % base == 0) { cnt++; now_n /= base; } n -= base; } else { n -= (n%base); } } return cnt; } }; 一个简单的优化思路是：去掉base为2的计算，因为5总是少于2：</description>
    </item>
    
    <item>
      <title>179. 最大数</title>
      <link>https://engineers.cool/leetcode/leetcode/179/</link>
      <pubDate>Tue, 24 Aug 2021 10:45:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/179/</guid>
      <description>原题链接
排序数组后拼接，排序规则是：两个数拼接的两种情况，哪种情况大 谁就在前
class Solution { public: string largestNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end(), [](long long a, long long b) { long long aa = 10, bb = 10; while (aa &amp;lt;= a) aa *= 10; while (bb &amp;lt;= b) bb *= 10; return b*aa+a &amp;lt; a*bb+b; }); if (nums[0] == 0) return &amp;#34;0&amp;#34;; string ret; for (int i = 0; i &amp;lt; nums.size(); ++i) ret += to_string(nums[i]); return ret; } }; </description>
    </item>
    
    <item>
      <title>190. 颠倒二进制位</title>
      <link>https://engineers.cool/leetcode/leetcode/190/</link>
      <pubDate>Mon, 23 Aug 2021 10:47:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/190/</guid>
      <description>原题链接
注意循环条件不能是n != 0，要遍历32位。
class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t ret = 0; for (int i = 0; i &amp;lt; 32; ++i) { uint32_t last_bit = n&amp;amp;1; n &amp;gt;&amp;gt;= 1; ret &amp;lt;&amp;lt;= 1; ret |= last_bit; } return ret; } }; </description>
    </item>
    
    <item>
      <title>189. 旋转数组</title>
      <link>https://engineers.cool/leetcode/leetcode/189/</link>
      <pubDate>Mon, 23 Aug 2021 10:46:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/189/</guid>
      <description>原题链接
直观的思路是使用一个额外数组：
class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;int&amp;gt; ans(nums.size(), 0); for (int i = 0; i &amp;lt; nums.size(); ++i) { ans[nxt(i, k, nums.size())] = nums[i]; } nums = ans; } private: int nxt(int cur, int k, int len) { return (cur+k)%len; } }; 之前学习间接排序时候，有发现它最后有原地替换的方式：环状替换，这里也可以适用，不过 需要一个额外的数组判断是否有替换过（方法三可以省略掉）。
class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { vector&amp;lt;bool&amp;gt; vis(nums.size(), false); for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>198. 打家劫舍</title>
      <link>https://engineers.cool/leetcode/leetcode/198/</link>
      <pubDate>Sun, 22 Aug 2021 10:49:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/198/</guid>
      <description>原题链接
简单的二维DP
class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(len, vector&amp;lt;int&amp;gt;(2,0)); dp[0][1] = nums[0]; for (int i = 1; i &amp;lt; len; ++i) { dp[i][0] = dp[i-1][1]; dp[i][1] = max(dp[i-1][1], dp[i-1][0]+nums[i]); } return max(dp[len-1][0], dp[len-1][1]); } }; 因为每次迭代，只与上一次迭代有关，可以优化下存储：
class Solution { public: int rob(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); int dp[2][2] = {{0,0},{0,0}}; dp[0][1] = nums[0]; int nxt = 1; for (int i = 1; i &amp;lt; len; ++i) { dp[nxt][0] = dp[nxt^1][1]; dp[nxt][1] = max(dp[nxt^1][1], dp[nxt^1][0]+nums[i]); nxt ^= 1; } return max(dp[nxt^1][0], dp[nxt^1][1]); } }; </description>
    </item>
    
    <item>
      <title>191. 位1的个数</title>
      <link>https://engineers.cool/leetcode/leetcode/191/</link>
      <pubDate>Sun, 22 Aug 2021 10:48:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/191/</guid>
      <description>原题链接
逐位判断即可
class Solution { public: int hammingWeight(uint32_t n) { int ret = 0; while (n) { if (n&amp;amp;1) ret++; n &amp;gt;&amp;gt;= 1; } return ret; } }; </description>
    </item>
    
    <item>
      <title>337. 打家劫舍 III</title>
      <link>https://engineers.cool/leetcode/leetcode/337/</link>
      <pubDate>Fri, 20 Aug 2021 11:13:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/337/</guid>
      <description>原题链接
类似DP过程的DFS，需要记录下已经搜索过的情况，否则会超时。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { unordered_map&amp;lt;TreeNode*, unordered_map&amp;lt;bool, int&amp;gt;&amp;gt; vis; public: int rob(TreeNode* root) { int max_v = 0; DFS(root, false, max_v); return max_v; } private: void DFS(TreeNode* root, bool is_f, int&amp;amp; max_v) { if (root == nullptr) { return; } if (vis[root][is_f]) { max_v = vis[root][is_f]; return; } if (is_f) { int max_v_l = 0, max_v_r = 0; DFS(root-&amp;gt;left, false, max_v_l); DFS(root-&amp;gt;right, false, max_v_r); max_v += max_v_l + max_v_r; } else { int max_v_l_1 = 0, max_v_r_1 = 0; DFS(root-&amp;gt;left, false, max_v_l_1); DFS(root-&amp;gt;right, false, max_v_r_1); int max_v_l_2 = 0, max_v_r_2 = 0; DFS(root-&amp;gt;left, true, max_v_l_2); DFS(root-&amp;gt;right, true, max_v_r_2); max_v += max(max_v_l_1 + max_v_r_1, max_v_l_2 + max_v_r_2 + root-&amp;gt;val); } vis[root][is_f] = max_v; } }; 题解的DFS过程简化了很多！</description>
    </item>
    
    <item>
      <title>200. 岛屿数量</title>
      <link>https://engineers.cool/leetcode/leetcode/200/</link>
      <pubDate>Thu, 19 Aug 2021 10:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/200/</guid>
      <description>原题链接
用DFS遍历一边即可，每发起一次DFS岛屿数量就加1。
class Solution { vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{1,0},{0,1},{-1,0},{0,-1}}; int m_, n_; public: int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { m_ = grid.size(); n_ = grid[0].size(); int ret = 0; vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m_, vector&amp;lt;bool&amp;gt;(n_, false)); for (int i = 0; i &amp;lt; m_; i++) { for (int j = 0; j &amp;lt; n_; j++) { if (grid[i][j] == &amp;#39;1&amp;#39; &amp;amp;&amp;amp; !vis[i][j]) { DFS(grid, i, j, vis); ret += 1; } } } return ret; } private: void DFS(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int i, int j, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt;&amp;amp; vis) { for (int d = 0; d &amp;lt; 4; d++) { int nxt_i = i + dirs_[d].</description>
    </item>
    
    <item>
      <title>202. 快乐数</title>
      <link>https://engineers.cool/leetcode/leetcode/202/</link>
      <pubDate>Wed, 18 Aug 2021 10:51:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/202/</guid>
      <description>原题链接
直接模拟接口，另外拿一个容器记录已遍历的数字：
class Solution { public: bool isHappy(int n) { set&amp;lt;int&amp;gt; vis; while (true) { int nxt_n = powN(n); cout &amp;lt;&amp;lt; nxt_n &amp;lt;&amp;lt; endl; if (nxt_n == 1) { return true; } else if (vis.count(nxt_n)) { return false; } else { vis.insert(nxt_n); n = nxt_n; } } return false; } private: int powN(int n) { int nxt = 0; while (n) { int sub_n = n%10; n /= 10; nxt += sub_n*sub_n; } return nxt; } }; </description>
    </item>
    
    <item>
      <title>204. 计数质数</title>
      <link>https://engineers.cool/leetcode/leetcode/204/</link>
      <pubDate>Tue, 17 Aug 2021 10:52:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/204/</guid>
      <description>原题链接
素数筛，注意题目中“统计所有小于非负整数 n 的质数的数量”的小于。
class Solution { public: int countPrimes(int n) { int max_v = n-1; if (max_v &amp;lt; 2) return 0; vector&amp;lt;bool&amp;gt; is_prime(max_v, true); int ret = max_v-1; for (int i = 2; i &amp;lt; max_v; i++) { if (not is_prime[i]) { continue; } int bc = 2; int bs = i*bc; for (int bs =i*bc; bs &amp;lt;= max_v; bs = i*(++bc)) { if (not is_prime[bs]) { continue; } is_prime[bs] = false; ret -= 1; } } return ret; } }; 我这里是用减法统计，题解用加法统计：</description>
    </item>
    
    <item>
      <title>210. 课程表 II</title>
      <link>https://engineers.cool/leetcode/leetcode/210/</link>
      <pubDate>Mon, 16 Aug 2021 10:56:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/210/</guid>
      <description>原题链接
标准的拓扑排序：
class Solution { public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;int&amp;gt; indegree(numCourses, 0); unordered_map&amp;lt;int, vector&amp;lt;int&amp;gt;&amp;gt; out_to; for (int i = 0; i &amp;lt; prerequisites.size(); i++) { indegree[ prerequisites[i][0] ] ++; out_to[ prerequisites[i][1] ].push_back(prerequisites[i][0]); } queue&amp;lt;int&amp;gt; q; for (int i = 0; i &amp;lt; numCourses; i++) { if (indegree[i] == 0) { q.push(i); } } vector&amp;lt;int&amp;gt; ans; while (!q.empty()) { int course = q.front(); q.pop(); ans.push_back(course); for (int to_course : out_to[course]) { if (-- indegree[to_course] == 0) { q.</description>
    </item>
    
    <item>
      <title>208. 实现 Trie (前缀树)</title>
      <link>https://engineers.cool/leetcode/leetcode/208/</link>
      <pubDate>Mon, 16 Aug 2021 10:55:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/208/</guid>
      <description>原题链接
class Trie { private: struct TrieNode { bool is_word; vector&amp;lt;TrieNode*&amp;gt; children; TrieNode() : is_word(false), children(26, nullptr) {} }; TrieNode* root; public: /** Initialize your data structure here. */ Trie() { root = new TrieNode(); } /** Inserts a word into the trie. */ void insert(string word) { int idx = 0; TrieNode* curnode = root; while (idx &amp;lt; word.length()) { int c_idx = word[idx] - &amp;#39;a&amp;#39;; if (curnode-&amp;gt;children[c_idx] == nullptr) { curnode-&amp;gt;children[c_idx] = new TrieNode(); } curnode = curnode-&amp;gt;children[c_idx]; idx++; } curnode-&amp;gt;is_word = true; // string str;  // print_trie(root, str);  } void print_trie(TrieNode* node, const string&amp;amp; str) { if (node == nullptr) { return; } if (node-&amp;gt;is_word) { cout &amp;lt;&amp;lt; &amp;#34;iter word:&amp;#34; &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; } for (int i = 0; i &amp;lt; 26; i++) { char c = &amp;#39;a&amp;#39;+i; print_trie(node-&amp;gt;children[i], str+string(1,c)); } } /** Returns if the word is in the trie.</description>
    </item>
    
    <item>
      <title>470. 用 Rand7() 实现 Rand10()</title>
      <link>https://engineers.cool/leetcode/leetcode/470/</link>
      <pubDate>Sun, 15 Aug 2021 11:14:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/470/</guid>
      <description>原题链接
数学题比较头大。
首先我们用两次rand7()可以生成1～49的数字，而生成1～10的随机数，需要10整数倍的数字来采样，那么可以丢弃大于40的数字，重新生成（拒绝采样）：
class Solution { public: int rand10() { int sample = 0; do { int r1 = rand7(); int r2 = rand7(); sample = r1 + (r2-1)*7; } while (sample &amp;gt; 40); return sample%10+1; } }; 我本来的思路，还是用这49个数字，用除法做归一化，然后再映射到1～10，不知道为啥过不了。。。:
class Solution { public: int rand10() { static int r1 = rand7(); int r2 = rand7(); int sample = r1 + (r2-1)*7; r1 = r2; int tmp = sample/49.0*10 + 1; if (tmp == 11) tmp = 1; return tmp; } }; 实际上，除法虽然是归一化，但是因为值域不是10的倍数 or 不是连续的，归一化后仍然不均匀</description>
    </item>
    
    <item>
      <title>112. 路径总和</title>
      <link>https://engineers.cool/leetcode/leetcode/112/</link>
      <pubDate>Sun, 15 Aug 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/112/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if (root == nullptr) { return false; } targetSum = targetSum - root-&amp;gt;val; if (root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return targetSum == 0; } return (root-&amp;gt;left &amp;amp;&amp;amp; hasPathSum(root-&amp;gt;left, targetSum)) || (root-&amp;gt;right &amp;amp;&amp;amp; hasPathSum(root-&amp;gt;right, targetSum)); } }; </description>
    </item>
    
    <item>
      <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
      <link>https://engineers.cool/leetcode/%E5%89%91%E6%8C%87offer/jz_54/</link>
      <pubDate>Sun, 15 Aug 2021 08:13:53 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/%E5%89%91%E6%8C%87offer/jz_54/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int kthLargest(TreeNode* root, int k) { int cnt = 0, v; kthLargest(root, k, cnt, v); return v; } private: bool kthLargest(TreeNode* root, int k, int&amp;amp; cnt, int&amp;amp; v) { if (root == nullptr) return false; bool found = kthLargest(root-&amp;gt;right, k, cnt, v); if (found) { return true; } cnt += 1; if (cnt == k) { v = root-&amp;gt;val; return true; } return kthLargest(root-&amp;gt;left, k, cnt, v); } }; </description>
    </item>
    
    <item>
      <title>300. 最长递增子序列</title>
      <link>https://engineers.cool/leetcode/leetcode/300/</link>
      <pubDate>Sat, 14 Aug 2021 11:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/300/</guid>
      <description>原题链接
令dp[i]表示以数字nums[i]结尾的串的最长递增子序列，容易写出O(n^2)的代码：
class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int dp[2500]; for (int i = 0; i &amp;lt; nums.size(); i++) { dp[i] = 1; } int ans = 1; for (int j = 1; j &amp;lt; nums.size(); j++) { for (int i = 0; i &amp;lt; j; i++) { if (nums[j] &amp;gt; nums[i]) { dp[j] = max(dp[j], dp[i]+1); ans = max(ans, dp[j]); } } } return ans; } }; 官方给出了一个O(nlogn)的方法：贪心 + 二分查找。</description>
    </item>
    
    <item>
      <title>206. 反转链表</title>
      <link>https://engineers.cool/leetcode/leetcode/206/</link>
      <pubDate>Sat, 14 Aug 2021 10:54:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/206/</guid>
      <description>原题链接
注意输入为nullptr的情况。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if (head == nullptr) return head; ListNode* pre_node = nullptr; ListNode* cur_node = head; while (cur_node-&amp;gt;next) { ListNode* nxt = cur_node-&amp;gt;next; cur_node-&amp;gt;next = pre_node; pre_node = cur_node; cur_node = nxt; } cur_node-&amp;gt;next = pre_node; return cur_node; } }; </description>
    </item>
    
    <item>
      <title>153. 寻找旋转排序数组中的最小值</title>
      <link>https://engineers.cool/leetcode/leetcode/153/</link>
      <pubDate>Sat, 14 Aug 2021 10:39:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/153/</guid>
      <description>原题链接
class Solution { public: int findMin(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int low = 0; int high = nums.size() - 1; while (low &amp;lt; high) { int pivot = low + (high - low) / 2; if (nums[pivot] &amp;lt; nums[high]) { high = pivot; } else { low = pivot + 1; } } return nums[low]; } }; </description>
    </item>
    
    <item>
      <title>146. LRU 缓存机制</title>
      <link>https://engineers.cool/leetcode/leetcode/146/</link>
      <pubDate>Sat, 14 Aug 2021 10:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/146/</guid>
      <description>原题链接
整体思路是：
 unordered_map&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; cache_ 维护键值对，以及键的引用计数  引用计数：从第一次put进去后，（包括第一次put的）put/get的次数   queue&amp;lt;int&amp;gt; pop_queue_ 记录每次操作的键  当缓存大小大于capacity后，按pop_queue_的顺序对键做引用计数减1，直到遇到减1后计数为0的键，然后删除它即可：
class LRUCache { public: LRUCache(int capacity) : capacity_(capacity) {} int get(int key) { if (cache_.count(key) != 0) { cache_[key].second++; pop_queue_.push(key); return cache_[key].first; } return -1; } void put(int key, int value) { if (cache_.size() == capacity_ &amp;amp;&amp;amp; cache_.count(key) == 0) { pop_one(); } if (cache_.count(key) == 0) { cache_[key] = {value, 1}; } else { cache_[key].</description>
    </item>
    
    <item>
      <title>217. 存在重复元素</title>
      <link>https://engineers.cool/leetcode/leetcode/217/</link>
      <pubDate>Thu, 12 Aug 2021 10:58:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/217/</guid>
      <description>原题链接
排序后，检查是否有连续的相等数字即可：
class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if (nums.size() &amp;lt; 2) return false; sort(nums.begin(), nums.end()); for (int i = 1; i &amp;lt; nums.size(); i++) if (nums[i] == nums[i-1]) return true; return false; } }; 或者不排序，拿一个容器记录已经遍历过的数字也可以：
class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // 官方题解这里是unordered_set  set&amp;lt;int&amp;gt; vis; for (int i = 0; i &amp;lt; nums.size(); i++) { if (vis.count(nums[i])) { return true; } vis.insert(nums[i]); } return false; } }; class Solution { public: bool containsDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_map&amp;lt;int, bool&amp;gt; vis; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>212. 单词搜索 II</title>
      <link>https://engineers.cool/leetcode/leetcode/212/</link>
      <pubDate>Thu, 12 Aug 2021 10:57:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/212/</guid>
      <description>原题链接
构造字典树，暴力搜索即可：
class Solution { struct TriNode { TriNode() : children_(26, nullptr), empty_(true), is_word_(false) {} bool empty_; bool is_word_; vector&amp;lt;TriNode*&amp;gt; children_; }; TriNode* words_tree_ = new TriNode(); vector&amp;lt;string&amp;gt; ans_; bool vis_[12][12]; int n_; int m_; vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt; dirs_ = {{0,1},{1,0},{-1,0},{0,-1}}; public: vector&amp;lt;string&amp;gt; findWords(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, vector&amp;lt;string&amp;gt;&amp;amp; words) { buildWordsTree(words); memset(vis_, false, sizeof(bool)*12*12); n_ = board.size(); m_ = board[0].size(); for (int i = 0; i &amp;lt; n_; i++) { for (int j = 0; j &amp;lt; m_; j++) { int child_idx = board[i][j]-&amp;#39;a&amp;#39;; if (words_tree_-&amp;gt;children_[child_idx] !</description>
    </item>
    
    <item>
      <title>218. 天际线问题</title>
      <link>https://engineers.cool/leetcode/leetcode/218/</link>
      <pubDate>Wed, 11 Aug 2021 11:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/218/</guid>
      <description>原题链接
没思路，题解太厉害了
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; getSkyline(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; buildings) { auto cmp = [](const pair&amp;lt;int, int&amp;gt;&amp;amp; a, const pair&amp;lt;int, int&amp;gt;&amp;amp; b) -&amp;gt; bool { return a.second &amp;lt; b.second; }; priority_queue&amp;lt;pair&amp;lt;int, int&amp;gt;, vector&amp;lt;pair&amp;lt;int, int&amp;gt;&amp;gt;, decltype(cmp)&amp;gt; que(cmp); vector&amp;lt;int&amp;gt; boundaries; for (auto&amp;amp; building : buildings) { boundaries.emplace_back(building[0]); boundaries.emplace_back(building[1]); } sort(boundaries.begin(), boundaries.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ret; int n = buildings.size(), idx = 0; for (auto&amp;amp; boundary : boundaries) { while (idx &amp;lt; n &amp;amp;&amp;amp; buildings[idx][0] &amp;lt;= boundary) { que.</description>
    </item>
    
    <item>
      <title>863. 二叉树中所有距离为 K 的结点</title>
      <link>https://engineers.cool/leetcode/leetcode/863/</link>
      <pubDate>Tue, 10 Aug 2021 11:16:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/863/</guid>
      <description>原题链接
 首先要找到该结点，然后再考虑距离的问题 找到该结点后，需要向两个方向查找  向下，每向下一层k-1 向上，每向上一层k-1   但是注意向上后还需要再次向下找。特别的，如果DFS时是先左子树再右子树的遍历，那么右子树找到target，向上再向下找的时候，还需要再遍历下左子树。  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { vector&amp;lt;int&amp;gt; ans_; bool find_target_ = false; public: vector&amp;lt;int&amp;gt; distanceK(TreeNode* root, TreeNode* target, int k) { searchTAndDistanceK(root, target, k); return ans_; } private: void searchTAndDistanceK(TreeNode* node, TreeNode* target, int&amp;amp; k) { if (node == nullptr) return; if (k &amp;lt; 0) return; if (find_target_) { if (k == 0) { ans_.</description>
    </item>
    
    <item>
      <title>230. 二叉搜索树中第K小的元素</title>
      <link>https://engineers.cool/leetcode/leetcode/230/</link>
      <pubDate>Mon, 09 Aug 2021 11:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/230/</guid>
      <description>原题链接
深度优先遍历，遍历的时候携带要找第几小即可：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int kthSmallest(TreeNode* root, int k) { int child_cnt; return kthSmallest(root, k, child_cnt); } private: int kthSmallest(TreeNode* root, int k, int&amp;amp; child_cnt) { if (root == nullptr) { child_cnt = 0; return -1; } int l_child_cnt = 0, r_child_cnt = 0; int l_ret = kthSmallest(root-&amp;gt;left, k, l_child_cnt); if (l_ret !</description>
    </item>
    
    <item>
      <title>234. 回文链表</title>
      <link>https://engineers.cool/leetcode/leetcode/234/</link>
      <pubDate>Sun, 08 Aug 2021 11:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/234/</guid>
      <description>原题链接
题目要求O(n)时间复杂度 而且 O(1) 空间复杂度，那么可以想到思路是反转后半段链表，比较完在反转回来。
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { // 计算长度  int len = 0; ListNode* iter = head; while (iter) { ++len; iter = iter-&amp;gt;next; } if (len == 0 || len == 1) return true; // 反转后半段  int reverse_pos = len/2 + len%2; ListNode* pre_node = nullptr; iter = head; while (reverse_pos--) { pre_node = iter; iter = iter-&amp;gt;next; } pre_node-&amp;gt;next = nullptr; // 开始反转  while(iter) { ListNode* next = iter-&amp;gt;next; iter-&amp;gt;next = pre_node; pre_node = iter; iter = next; } iter = pre_node; bool ans = true; // 反转完开始对比  while (head) { if (head-&amp;gt;val !</description>
    </item>
    
    <item>
      <title>236. 二叉树的最近公共祖先</title>
      <link>https://engineers.cool/leetcode/leetcode/236/</link>
      <pubDate>Sat, 07 Aug 2021 11:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/236/</guid>
      <description>原题链接
深度遍历整棵树：
 遍历到该结点时，两个结点都还没找到，该结点可能是答案  如果该结点的值是其中一个搜索结点，从左右子树搜另外一个搜索结点  如果找到则该结点就是大单 如果没则返回nullptr   迭代遍历左子树和右子树   遍历到该结点时，两个结点已经找到了至少一个，那么该结点可能是答案，继续遍历即可  /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { set&amp;lt;int&amp;gt; to_find_val; to_find_val.insert(p-&amp;gt;val); to_find_val.insert(q-&amp;gt;val); return DFS(root, to_find_val); } private: TreeNode* DFS(TreeNode* root, set&amp;lt;int&amp;gt;&amp;amp; to_find_val) { if (!</description>
    </item>
    
    <item>
      <title>237. 删除链表中的节点</title>
      <link>https://engineers.cool/leetcode/leetcode/237/</link>
      <pubDate>Fri, 06 Aug 2021 11:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/237/</guid>
      <description>原题链接
这题输入方式挺有意思的
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: void deleteNode(ListNode* node) { node-&amp;gt;val = node-&amp;gt;next-&amp;gt;val; // ListNode* delete_node = node-&amp;gt;next;  node-&amp;gt;next = node-&amp;gt;next-&amp;gt;next; // delete delete_node;  } }; </description>
    </item>
    
    <item>
      <title>239. 滑动窗口最大值</title>
      <link>https://engineers.cool/leetcode/leetcode/239/</link>
      <pubDate>Thu, 05 Aug 2021 11:06:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/239/</guid>
      <description>原题链接
持续维护最值，最开始的想法是维护一个大顶堆，窗口内的都加进来；以后每次移动窗口时，就POP出不在窗口的数字，PUSH刚进窗口的数字。
但是有一个问题，在堆POP时，不知道该POP的数字在堆的哪个位置。
针对这个问题，考虑了两个思路：
 额外维护数据结构记录位置，比如用map&amp;lt;int,vector&amp;lt;size_t&amp;gt;&amp;gt;，记录每个数字的位置  但是这个数据结构会导致堆实现复杂化（挪动元素时需要修改这个结构）   记录需要POP的数字，但是先不着急POP，如果堆顶等于 需要POP的数字的最大值 才POP（堆顶），以及把这个数字从 需要POP的数字 中去除。  这个方法的话 需要POP的数字 也需要一个堆来维护。    以下使用第二个方法：
class BigHeap { public: BigHeap() : size_(0) { memset(heap_, INT_MIN, sizeof(int)*100000); } ~BigHeap() = default; void Push(int val) { heap_[size_++] = val; // push last val up  size_t cur_pos = size_-1; while (cur_pos != 0) { size_t father = (cur_pos+1)/2-1; if (heap_[father] &amp;lt; heap_[cur_pos]) { swap(heap_[father], heap_[cur_pos]); cur_pos = father; } else { break; } } } void Pop() { heap_[0] = heap_[size_-- -1]; // push first val down  size_t cur_pos = 0; while (true) { size_t child_l = cur_pos*2+1; size_t child_r = cur_pos*2+2; if (child_l &amp;lt; size_ &amp;amp;&amp;amp; child_r &amp;lt; size_) { // 有左 有右  size_t tmp_swap_child = heap_[child_l] &amp;gt; heap_[child_r] ?</description>
    </item>
    
    <item>
      <title>238. 除自身以外数组的乘积</title>
      <link>https://engineers.cool/leetcode/leetcode/238/</link>
      <pubDate>Thu, 05 Aug 2021 11:05:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/238/</guid>
      <description>原题链接
预处理一遍后缀乘积，存储在输出数组中；然后一边维护前缀乘积，一边更新结果数组（前缀乘积 * 预处理的后缀乘积）：
class Solution { public: vector&amp;lt;int&amp;gt; productExceptSelf(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;int&amp;gt; ans(len, 0); ans[len-1] = nums[len-1]; for (int i = len-2; i &amp;gt;= 0; i--) ans[i] = ans[i+1]*nums[i]; ans[0] = ans[1]; int pre_product = nums[0]; for (int i = 1; i &amp;lt; len-1; i++) { ans[i] = pre_product * ans[i+1]; pre_product *= nums[i]; } ans[len-1] = pre_product; return ans; } }; </description>
    </item>
    
    <item>
      <title>242. 有效的字母异位词</title>
      <link>https://engineers.cool/leetcode/leetcode/242/</link>
      <pubDate>Tue, 03 Aug 2021 11:08:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/242/</guid>
      <description>原题链接
class Solution { public: bool isAnagram(string s, string t) { if (s.length() != t.length()) return false; vector&amp;lt;int&amp;gt; s_cnt(26, 0); vector&amp;lt;int&amp;gt; t_cnt(26, 0); for (int i = 0; i &amp;lt; s.length(); i++) { s_cnt[s[i]-&amp;#39;a&amp;#39;]++; t_cnt[t[i]-&amp;#39;a&amp;#39;]++; } for (int i = 0; i &amp;lt; 26; i++) { if (s_cnt[i] != t_cnt[i]) return false; } return true; } }; </description>
    </item>
    
    <item>
      <title>240. 搜索二维矩阵 II</title>
      <link>https://engineers.cool/leetcode/leetcode/240/</link>
      <pubDate>Tue, 03 Aug 2021 11:07:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/240/</guid>
      <description>原题链接
直观（错误）思路 最开始的思路是先首行二分，然后找一列二分：
 首行二分，找到等于 或者 不大于target的最后一个 如果首行没有等于target的，就二分首行 不大于target的最后一个 的列  class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int l = 0, r = matrix[0].size()-1; int col = -1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (matrix[0][mid] == target) { return true; } else if (matrix[0][mid] &amp;gt; target) { r = mid-1; } else { l = mid+1; } } col = r; if (col == -1) return false; l = 0; r = matrix.</description>
    </item>
    
    <item>
      <title>268. 丢失的数字</title>
      <link>https://engineers.cool/leetcode/leetcode/268/</link>
      <pubDate>Mon, 02 Aug 2021 11:09:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/268/</guid>
      <description>原题链接
一上来会想到之前看过一个题：每个数字包含2遍 只有一个数字包含一遍，找这个数字。这题只是遍数都少了一次，那可以自己叠加上去：
class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { ans ^= (i+1); ans ^= nums[i]; } return ans; } }; 另外还有一个思路，可以一边加合一边减掉数组中的数字，最后的值就是缺的数字：
class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = 0; for (int i = 0; i &amp;lt; nums.size(); i++) { ans += i+1; ans -= nums[i]; } return ans; } }; 另外，求和可以用数学公式替代，减少计算次数。</description>
    </item>
    
    <item>
      <title>279. 完全平方数</title>
      <link>https://engineers.cool/leetcode/leetcode/279/</link>
      <pubDate>Sun, 01 Aug 2021 11:10:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/279/</guid>
      <description>原题链接
预处理所有（小于等于10000）的完全平方数都有哪些。然后就是类似零钱问题的DP。
class Solution { int num_sqs[101]; public: Solution() { for (int i = 0; i &amp;lt;= 100; i++) num_sqs[i] = i*i; } public: int numSquares(int n) { int dp[10001]; memset(dp, 0, sizeof(int)*10001); for (int i = 0; i &amp;lt;= 100; i++) { dp[num_sqs[i]] = 1; } for (int i = 1; i &amp;lt; n; i++) { if (dp[i] == 0) continue; int sqs_idx = 1; while (i+num_sqs[sqs_idx] &amp;lt;= n &amp;amp;&amp;amp; sqs_idx &amp;lt;= 100) { int sum = i+num_sqs[sqs_idx]; dp[sum] == 0 ?</description>
    </item>
    
    <item>
      <title>283. 移动零</title>
      <link>https://engineers.cool/leetcode/leetcode/283/</link>
      <pubDate>Fri, 30 Jul 2021 11:11:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/283/</guid>
      <description>原题链接
两个指针，一个指向非零写入位置，一个指向当前位置。
遍历当前位置，如果当前非0，则把该数字swap到非零写入位置，并把非零写入位置向后挪1。
class Solution { public: void moveZeroes(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(), no_zero_pos = 0, cur_pos = 0; while (cur_pos &amp;lt; n) { if (nums[cur_pos]) { swap(nums[no_zero_pos], nums[cur_pos]); no_zero_pos++; } cur_pos++; } } }; </description>
    </item>
    
    <item>
      <title>102. 二叉树的层序遍历</title>
      <link>https://engineers.cool/leetcode/leetcode/102/</link>
      <pubDate>Thu, 29 Jul 2021 10:27:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/102/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; if (!root) return ans; queue&amp;lt;TreeNode*&amp;gt; q; q.push(root); while (!</description>
    </item>
    
    <item>
      <title>101. 对称二叉树</title>
      <link>https://engineers.cool/leetcode/leetcode/101/</link>
      <pubDate>Thu, 29 Jul 2021 10:26:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/101/</guid>
      <description>原题链接
直观的思路，递归的判断左子树和右子树是否镜像一致，即 左子树的右子子树与右子树的左子子树 与 左子树的左子子树与右子树的右右子树:
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if (!root) return true; return isSymmetric(root-&amp;gt;left, root-&amp;gt;right); } private: bool isSymmetric(TreeNode* left, TreeNode* right) { if (left == nullptr &amp;amp;&amp;amp; right == nullptr) { return true; } else if (left == nullptr || right == nullptr) { return false; } else { if (left-&amp;gt;val == right-&amp;gt;val) { return isSymmetric(left-&amp;gt;left, right-&amp;gt;right) &amp;amp;&amp;amp; isSymmetric(left-&amp;gt;right, right-&amp;gt;left); } else { return false; } } } }; 上面可以把if (!</description>
    </item>
    
    <item>
      <title>100. 相同的树</title>
      <link>https://engineers.cool/leetcode/leetcode/100/</link>
      <pubDate>Wed, 28 Jul 2021 10:26:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/100/</guid>
      <description>原题链接
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == nullptr &amp;amp;&amp;amp; q == nullptr) { return true; } else if ((p !</description>
    </item>
    
    <item>
      <title>99. 恢复二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/99/</link>
      <pubDate>Wed, 28 Jul 2021 10:25:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/99/</guid>
      <description>原题链接
先中序遍历一边，拿到中序遍历的顺序，然后遍历数组找到需要交换的位置；最后再遍历树并对相应的结点赋值。
如果不想遍历两边树的话，感觉可以在第一次遍历的时候，存下结点地址，而不是结点值。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void recoverTree(TreeNode* root) { vector&amp;lt;int&amp;gt; nums; inorder(root, nums); pair&amp;lt;int, int&amp;gt; swapped = findTwoSwapped(nums); int re_cnt = 2; recover(root, re_cnt, swapped.</description>
    </item>
    
    <item>
      <title>98. 验证二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/98/</link>
      <pubDate>Sun, 25 Jul 2021 10:25:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/98/</guid>
      <description>原题链接
拿到中序遍历，检查中序遍历是否是递增即可：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { vector&amp;lt;int&amp;gt; trip_vis; tripTree(root, trip_vis); for (int i = 1; i &amp;lt; trip_vis.</description>
    </item>
    
    <item>
      <title>97. 交错字符串</title>
      <link>https://engineers.cool/leetcode/leetcode/97/</link>
      <pubDate>Sun, 25 Jul 2021 10:24:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/97/</guid>
      <description>原题链接
1次通过100%击败的动态规划。dp[i][j]表示 s1的前i个字符 加上 s2的前j个字符 能不能组成s3的前i+j个字符串，然后递推即可：
ass Solution { public: bool isInterleave(string s1, string s2, string s3) { if (s3.length() != s1.length() + s2.length()) return false; if (s3.length() == 0) return true; bool dp[101][101]; memset(dp, false, sizeof(bool)*101*101); dp[0][0] = true; for (int i = 0; i &amp;lt;= s1.length(); i++) { for (int j = 0; j &amp;lt;= s2.length(); j++) { if (i &amp;gt; 0 &amp;amp;&amp;amp; dp[i-1][j] &amp;amp;&amp;amp; s1[i-1] == s3[i+j-1]) dp[i][j] = true; if (j &amp;gt; 0 &amp;amp;&amp;amp; dp[i][j-1] &amp;amp;&amp;amp; s2[j-1] == s3[i+j-1]) dp[i][j] = true; } } return dp[s1.</description>
    </item>
    
    <item>
      <title>96. 不同的二叉搜索树</title>
      <link>https://engineers.cool/leetcode/leetcode/96/</link>
      <pubDate>Sun, 25 Jul 2021 10:23:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/96/</guid>
      <description>原题链接
跟上一题的思路一样，再加一个vis矩阵记录计算过的数字：
class Solution { // unordered_map&amp;lt;int, unordered_map&amp;lt;int, int&amp;gt;&amp;gt; vis;  int vis[20][20]; public: int numTrees(int n) { memset(vis, 0, sizeof(int)*20*20); return numTrees(1, n); } private: int numTrees(int s, int e) { if (s &amp;gt; e) return 1; if (vis[s][e] != 0) return vis[s][e]; int ans = 0; for (int i = s; i &amp;lt;= e; i++) { int ltrees_n = numTrees(s, i-1); int rtrees_n = numTrees(i+1, e); ans += ltrees_n*rtrees_n; } vis[s][e] = ans; return ans; } }; 第一次vis矩阵用unordered_map实现，速度有点慢，换int二维数组，击败100%。</description>
    </item>
    
    <item>
      <title>95. 不同的二叉搜索树 II</title>
      <link>https://engineers.cool/leetcode/leetcode/95/</link>
      <pubDate>Sat, 24 Jul 2021 10:23:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/95/</guid>
      <description>原题链接
回溯+枚举，枚举父结点的值+递归构造子树，最后把子树拼接起来:
class Solution { public: vector&amp;lt;TreeNode*&amp;gt; generateTrees(int n) { return MakeTrees(1, n); } private: vector&amp;lt;TreeNode*&amp;gt; MakeTrees(int s, int e) { if (s &amp;gt; e) return {nullptr}; // 这里要有一个nullptr  vector&amp;lt;TreeNode*&amp;gt; trees; for (int i = s; i &amp;lt;= e; ++i) { vector&amp;lt;TreeNode*&amp;gt; l_trees = MakeTrees(s, i-1); vector&amp;lt;TreeNode*&amp;gt; r_trees = MakeTrees(i+1, e); for (auto&amp;amp; l_tree : l_trees) for (auto&amp;amp; r_tree: r_trees) { TreeNode* father = new TreeNode(i); father-&amp;gt;left = l_tree; father-&amp;gt;right = r_tree; trees.</description>
    </item>
    
    <item>
      <title>94. 二叉树的中序遍历</title>
      <link>https://engineers.cool/leetcode/leetcode/94/</link>
      <pubDate>Sat, 24 Jul 2021 10:22:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/94/</guid>
      <description>原题链接
二叉树中序遍历，即先左子树 再本结点 再又子树：
/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; ans; MidTrip(root, ans); return ans; } private: void MidTrip(TreeNode* node, vector&amp;lt;int&amp;gt;&amp;amp; ans) { if (node == nullptr) return; if (node-&amp;gt;left) MidTrip(node-&amp;gt;left, ans); ans.</description>
    </item>
    
    <item>
      <title>93. 复原 IP 地址</title>
      <link>https://engineers.cool/leetcode/leetcode/93/</link>
      <pubDate>Sat, 24 Jul 2021 10:21:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/93/</guid>
      <description>原题链接
又是一道DFS搜索：
class Solution { public: vector&amp;lt;string&amp;gt; restoreIpAddresses(string s) { if (s.length() &amp;lt; 4 || s.length() &amp;gt; 12) return {}; vector&amp;lt;string&amp;gt; ans; string ip_now; DFS(s, 0, 0, ip_now, ans); return ans; } private: void DFS(string&amp;amp; s, int s_f_s, int pot_cnt, const string&amp;amp; ip_now, vector&amp;lt;string&amp;gt;&amp;amp; ans) { if (pot_cnt == 4 &amp;amp;&amp;amp; s_f_s == s.length()) { ans.push_back(ip_now); return; } else if (pot_cnt == 4 || s_f_s == s.length()) { return; } for (int i = s_f_s; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>92. 反转链表 II</title>
      <link>https://engineers.cool/leetcode/leetcode/92/</link>
      <pubDate>Sat, 24 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/92/</guid>
      <description>原题链接
找到相应位置，反转再链接即可：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { if (left == right) return head; ListNode* dummy = new ListNode(0, head); ListNode* pre_reverse = nullptr; ListNode* aft_reverse = nullptr; ListNode* dummy_reverse = new ListNode(0); ListNode* reverse_tail = dummy_reverse; int idx = 1; ListNode* cur_node = dummy; while (idx &amp;lt; left) { cur_node = cur_node-&amp;gt;next; ++ idx; } pre_reverse = cur_node; cur_node = cur_node-&amp;gt;next; while (idx &amp;lt;= right) { // 插入cur_node  ListNode* next = cur_node-&amp;gt;next; cur_node-&amp;gt;next = dummy_reverse-&amp;gt;next; dummy_reverse-&amp;gt;next = cur_node; if (cur_node-&amp;gt;next == nullptr) { reverse_tail = cur_node; } cur_node = next; ++ idx; } aft_reverse = cur_node; pre_reverse-&amp;gt;next = dummy_reverse-&amp;gt;next; reverse_tail-&amp;gt;next = aft_reverse; ListNode* ans = dummy-&amp;gt;next; delete dummy; delete dummy_reverse; return ans; } }; </description>
    </item>
    
    <item>
      <title>91. 解码方法</title>
      <link>https://engineers.cool/leetcode/leetcode/91/</link>
      <pubDate>Fri, 23 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/91/</guid>
      <description>原题链接
前面几题都是DFS搜索，这题一开始也想DFS来着，但是越写越不对劲，换思路用DP。
class Solution { public: int numDecodings(string s) { if (s.length() == 0) return 0; if (s[0] == &amp;#39;0&amp;#39;) return 0; int dp[100]; memset(dp, 0, sizeof(int)*100); dp[0] = 1; for (int i = 1; i &amp;lt; s.length(); ++i) { int dp_m1 = 0, dp_m2 = 0; if (isValid(s.substr(i,1))) dp_m1 = dp[i-1]; if (isValid(s.substr(i-1, 2))) dp_m2 = i &amp;gt; 1 ? dp[i-2] : 1; if (dp_m1 == 0 &amp;amp;&amp;amp; dp_m2 == 0) return 0; dp[i] = dp_m1 + dp_m2; } return dp[s.</description>
    </item>
    
    <item>
      <title>90. 子集 II</title>
      <link>https://engineers.cool/leetcode/leetcode/90/</link>
      <pubDate>Thu, 22 Jul 2021 10:20:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/90/</guid>
      <description>原题链接
DFS搜索，一个额外数据记录不再使用的数字，搜索时遇到不再使用的数字直接进入下一层:
ass Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsetsWithDup(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;bool&amp;gt; drop(21, false); vector&amp;lt;int&amp;gt; comb; DFS(nums, 0, comb, drop); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, int idx, vector&amp;lt;int&amp;gt;&amp;amp; comb, vector&amp;lt;bool&amp;gt;&amp;amp; drop) { if (idx == nums.size()) { ans.push_back(comb); return; } if (drop[nums[idx]+10]) { DFS(nums, idx+1, comb, drop); } else { comb.push_back(nums[idx]); DFS(nums, idx+1, comb, drop); comb.pop_back(); drop[nums[idx]+10] = true; DFS(nums, idx+1, comb, drop); drop[nums[idx]+10] = false; } } }; 有一个优化点，可以用while循环减少递归的层数:</description>
    </item>
    
    <item>
      <title>89. 格雷编码</title>
      <link>https://engineers.cool/leetcode/leetcode/89/</link>
      <pubDate>Thu, 22 Jul 2021 10:19:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/89/</guid>
      <description>原题链接
有点找规律的意思，先初始化1位的格雷码，循环增加位，反向遍历已有的格雷码数组 分别在新增位设置为1:
class Solution { public: vector&amp;lt;int&amp;gt; grayCode(int n) { if (n == 0) return {0}; vector&amp;lt;int&amp;gt; ans = {0, 1}; bool zx = false; for (int b = 1; b &amp;lt; n; b++) { int pre_len = ans.size(); int p = zx ? 0 : ans.size()-1; int d = zx ? 1 : -1; while (p &amp;gt;= 0 &amp;amp;&amp;amp; p &amp;lt; pre_len) { int n = ans[p] | 1&amp;lt;&amp;lt;b; ans.</description>
    </item>
    
    <item>
      <title>88. 合并两个有序数组</title>
      <link>https://engineers.cool/leetcode/leetcode/88/</link>
      <pubDate>Thu, 22 Jul 2021 10:18:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/88/</guid>
      <description>原题链接
一般思路可以通过，但时耗只击败60% 而且nums1原大小就是m+n这个条件没用到，感觉会有更优的算法
class Solution { public: void merge(vector&amp;lt;int&amp;gt;&amp;amp; nums1, int m, vector&amp;lt;int&amp;gt;&amp;amp; nums2, int n) { vector&amp;lt;int&amp;gt; ans(m+n, 0); int ans_idx = 0; int n1_idx = 0, n2_idx = 0; while (n1_idx &amp;lt; m || n2_idx &amp;lt; n) { int n1 = n1_idx &amp;lt; m ? nums1[n1_idx] : INT_MAX; int n2 = n2_idx &amp;lt; n ? nums2[n2_idx] : INT_MAX; if (n1 &amp;lt; n2) { ans[ans_idx++] = n1; n1_idx++; } else { ans[ans_idx++] = n2; n2_idx++; } } nums1 = ans; } }; 再想了一下，只要从后往前填num1，就不会有覆盖原数组的问题，也不用再建一个中加数组了:</description>
    </item>
    
    <item>
      <title>86. 分隔链表</title>
      <link>https://engineers.cool/leetcode/leetcode/86/</link>
      <pubDate>Thu, 22 Jul 2021 10:17:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/86/</guid>
      <description>原题链接
遍历一遍拆成两个链表，然后把两个链表合并即可:
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { if (!head) return head; ListNode* part_1_dummy = new ListNode(0); ListNode* part_1_tail = part_1_dummy; ListNode* part_2_dummy = new ListNode(0); ListNode* part_2_tail = part_2_dummy; ListNode* cur = head; while (cur) { if (cur-&amp;gt;val &amp;lt; x) { part_1_tail-&amp;gt;next = cur; part_1_tail = part_1_tail-&amp;gt;next; } else { part_2_tail-&amp;gt;next = cur; part_2_tail = part_2_tail-&amp;gt;next; } cur = cur-&amp;gt;next; } part_2_tail-&amp;gt;next = nullptr; part_1_tail-&amp;gt;next = part_2_dummy-&amp;gt;next; return part_1_dummy-&amp;gt;next; } }; </description>
    </item>
    
    <item>
      <title>83. 删除排序链表中的重复元素</title>
      <link>https://engineers.cool/leetcode/leetcode/83/</link>
      <pubDate>Tue, 20 Jul 2021 10:17:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/83/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return head; ListNode* cur = head; while (cur-&amp;gt;next) { if (cur-&amp;gt;val == cur-&amp;gt;next-&amp;gt;val) { cur-&amp;gt;next = cur-&amp;gt;next-&amp;gt;next; } else { cur = cur-&amp;gt;next; } } return head; } }; </description>
    </item>
    
    <item>
      <title>82. 删除排序链表中的重复元素 II</title>
      <link>https://engineers.cool/leetcode/leetcode/82/</link>
      <pubDate>Tue, 20 Jul 2021 10:16:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/82/</guid>
      <description>原题链接
双指针遍历，第一个指针指向写入的位置，第二个指针指向遍历的位置，额外增加变量 记录上一个遍历的结点 以及 是否重复。
 遍历到相同值时，标记重复，然后continue 遍历到不同值时，查看标记是否重复  如果之前没有重复，就把记录的结点写到第一个指针的位置 如果之前有重复，则忽略，重新continue    /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if (head == nullptr) return head; ListNode* dummy = new ListNode(); ListNode* n_write = dummy; ListNode* t_node = head; bool conflicted = false; for (ListNode* node = head-&amp;gt;next; node; node = node-&amp;gt;next) { if (node-&amp;gt;val == t_node-&amp;gt;val) { conflicted = true; continue; } else { if (!</description>
    </item>
    
    <item>
      <title>81. 搜索旋转排序数组 II</title>
      <link>https://engineers.cool/leetcode/leetcode/81/</link>
      <pubDate>Tue, 20 Jul 2021 10:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/81/</guid>
      <description>原题链接
前面有一道类似的题，只不过没有相等的数字。单纯按之前的方法的话(18~39行)，会判断错误位置，原因是两半边的基准数字可能一样，那么我这里的解决方案是，先绕过相等的数字，剔除掉后，再做逻辑:
class Solution { public: bool search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int last = nums.size()-1; if (nums[0] == target || nums[last] == target) { return true; } while (last &amp;gt;= 0 &amp;amp;&amp;amp; nums[last] == nums[0])last--; int l = 0, r = last; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (nums[mid] == target) { return true; } else if (nums[mid] &amp;lt;= nums[last]) { // mid 在右半边  if (nums[mid] &amp;lt; target &amp;amp;&amp;amp; target &amp;lt;= nums[last]) { l = mid+1; } else { r = mid-1; } } else { // mid 在左半边  if (target &amp;lt; nums[mid] &amp;amp;&amp;amp; target &amp;gt;= nums[0]) { r = mid-1; } else { l = mid+1; } } } return false; } }; 整体时耗较高，只优于60%提交。</description>
    </item>
    
    <item>
      <title>80. 删除序有序数组中的重复项 II</title>
      <link>https://engineers.cool/leetcode/leetcode/80/</link>
      <pubDate>Sun, 18 Jul 2021 10:15:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/80/</guid>
      <description>原题链接
双指针，一个指向写入位置，一个指向遍历位置:
class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int cur_num = nums[0]; int cur_cnt = 1; int write_pos = 1; for (int i = 1; i &amp;lt; nums.size(); ++i) { if (nums[i] == cur_num) { cur_cnt += 1; if (cur_cnt &amp;lt;= 2) { nums[write_pos++] = nums[i]; } } else { cur_cnt = 1; cur_num = nums[i]; nums[write_pos++] = cur_num; } } return write_pos; } }; </description>
    </item>
    
    <item>
      <title>79. 单词搜索</title>
      <link>https://engineers.cool/leetcode/leetcode/79/</link>
      <pubDate>Sun, 18 Jul 2021 10:14:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/79/</guid>
      <description>原题链接
枚举+DFS，一开始提交的时候有cout打印，然后就超时了&amp;hellip;还以为是有剪枝没想到 or 思路不对&amp;hellip;很久想不到看题解才发现一摸一样，是cout导致超时😂：
class Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{1,0},{-1,0},{0,1},{0,-1}}; public: bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { int m = board.size(); int n = board[0].size(); vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt; vis(m, vector&amp;lt;bool&amp;gt;(n, false)); for (int i = 0; i &amp;lt; m; ++i) for (int j = 0; j &amp;lt; n; ++j) { if (DFS(board, word, i, j, 0, vis)) { return true; } } return false; } private: bool DFS(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string&amp;amp; word, int x, int y, int cur, vector&amp;lt;vector&amp;lt;bool&amp;gt;&amp;gt;&amp;amp; vis) { if (x &amp;gt;= board.</description>
    </item>
    
    <item>
      <title>78. 子集</title>
      <link>https://engineers.cool/leetcode/leetcode/78/</link>
      <pubDate>Sun, 18 Jul 2021 10:13:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/78/</guid>
      <description>原题链接
跟上一题一样，回溯的思路，枚举k的大小，然后分别回溯一边：
class Solution { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_result; public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; subsets(vector&amp;lt;int&amp;gt;&amp;amp; nums) { for (int k = 0; k &amp;lt;= nums.size(); k++) { DFS(nums, 0, k); } return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, int s, int k) { if (dfs_result.size() == k) { ans.push_back(dfs_result); return; } if (nums.size()-s+dfs_result.size() &amp;lt; k) return; for (int i = s; i &amp;lt; nums.size(); ++i) { dfs_result.push_back(nums[i]); DFS(nums, i+1, k); dfs_result.pop_back(); } } }; 还是回溯，换一个思路会更快：不用枚举k的大小，只要枚举是否选回溯结点即可：</description>
    </item>
    
    <item>
      <title>77. 组合</title>
      <link>https://engineers.cool/leetcode/leetcode/77/</link>
      <pubDate>Sun, 18 Jul 2021 10:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/77/</guid>
      <description>原题链接
简单回溯算法搜索答案，可以有个剪枝小优化：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_result; DFS(1, n, k, dfs_result, ans); return ans; } private: void DFS(int s, int e, int k, vector&amp;lt;int&amp;gt;&amp;amp; dfs_result, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (dfs_result.size() == k) { ans.push_back(dfs_result); return; } if (e-s+1+dfs_result.size() &amp;lt; k) return; for (int i = s; i &amp;lt;= e; ++i) { dfs_result.push_back(i); DFS(i+1, e, k, dfs_result, ans); dfs_result.pop_back(); } } }; 官方给出了一种&amp;quot;非递归（字典序法）实现组合型枚举&amp;quot;的方法，本质上是找规律然后直接枚举出（字典序的）下一个组合。</description>
    </item>
    
    <item>
      <title>75. 颜色分类</title>
      <link>https://engineers.cool/leetcode/leetcode/75/</link>
      <pubDate>Sat, 17 Jul 2021 10:12:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/75/</guid>
      <description>原题链接
统计每个值的个数，然后再赋值回原数组即可:
class Solution { public: void sortColors(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;int&amp;gt; count(3, 0); for (int num : nums) count[num]++; int idx = 0; for (int i = 0; i &amp;lt; 3; i++) { while (count[i]--) { nums[idx++] = i; } } } }; 官方题解给出了几个使用指针的方法:
 单指针  两次遍历，第一次把0置换到头部(指针维护0的末尾)，第二次把1置换到0后面的空间(指针维护1的末尾)   双置针  方案1，一次性维护上面两个指针，需要注意的是，遇到0时，换到0末尾后，如果置换出来的是1，还需要再放回1的末尾。(相当于先把0末尾置换到1末尾，再把0置换到0末尾) 方案2，维护0末尾、2开头两个置针，类似快排一样操作。    </description>
    </item>
    
    <item>
      <title>74. 搜索二维矩阵</title>
      <link>https://engineers.cool/leetcode/leetcode/74/</link>
      <pubDate>Sat, 17 Jul 2021 10:11:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/74/</guid>
      <description>原题链接
就是标准的二分搜索:
class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int l = 0, r = m*n-1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; int i = mid/n, j = mid%n; if (matrix[i][j] == target) { return true; } else if (matrix[i][j] &amp;gt; target) { r = mid-1; } else { l = mid+1; } } return false; } }; </description>
    </item>
    
    <item>
      <title>73. 矩阵置零</title>
      <link>https://engineers.cool/leetcode/leetcode/73/</link>
      <pubDate>Sat, 17 Jul 2021 10:10:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/73/</guid>
      <description>原题链接
题目要求仅能使用常数级额外存储空间，那么我们不能单独维护需要设置为0的行与列。 可以把这个标记维护在行首和列首。但是这样会影响行首和列首本身的数值，一个解决方案是，先单独遍历行首列首，单独维护其是否要置0:
class Solution { public: void setZeroes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int m = matrix.size(); int n = matrix[0].size(); bool m_all_zero = false, n_all_zero = false; for (int i = 0; i &amp;lt; m; ++i) if (matrix[i][0] == 0) m_all_zero = true; for (int j = 0; j &amp;lt; n; ++j) if (matrix[0][j] == 0) n_all_zero = true; for (int i = 1; i &amp;lt; m; ++i) { for (int j = 1; j &amp;lt; n; ++j) { if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; cout &amp;lt;&amp;lt; &amp;#34;mark &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; endl; } } } for (int i = 1; i &amp;lt; m; ++i) { for (int j = 1; j &amp;lt; n; ++j) { if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; } } if (m_all_zero) { for (int i = 0; i &amp;lt; m; ++i) matrix[i][0] = 0; } if (n_all_zero) { for (int j = 0; j &amp;lt; n; ++j) matrix[0][j] = 0; } } }; 官方给出了进一步的优化，上面方法中行首与列首交叉的元素被浪费掉了，这个元素可以用来标记首行(或首列)，就可以再省一个额外存储。 值得注意的是，因为在首行仍然表示本列是否置0，所以在遍历置0时，需要最后处理首行。</description>
    </item>
    
    <item>
      <title>71. 简化路径</title>
      <link>https://engineers.cool/leetcode/leetcode/71/</link>
      <pubDate>Sat, 17 Jul 2021 10:08:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/71/</guid>
      <description>原题链接
基本思路是遍历解析原始字符串，记录遍历到的目录名，如果遇到了..就把缓存的目录名删除一个。最后，再拼接成完整路径:
class Solution { public: string simplifyPath(string path) { vector&amp;lt;string&amp;gt; dirs; for (int i = 0; i &amp;lt; path.length();) { while (i &amp;lt; path.length() &amp;amp;&amp;amp; path[i] != &amp;#39;/&amp;#39;) ++i; int s = ++i; while (i &amp;lt; path.length() &amp;amp;&amp;amp; path[i] != &amp;#39;/&amp;#39;) ++i; int e = i; string dir = path.substr(s, e-s); if (dir == &amp;#34;.&amp;#34;) { continue; } else if (dir == &amp;#34;..&amp;#34;) { if (dirs.size() &amp;gt; 0) dirs.resize(dirs.size()-1); } else if (!</description>
    </item>
    
    <item>
      <title>70. 爬楼梯</title>
      <link>https://engineers.cool/leetcode/leetcode/70/</link>
      <pubDate>Sat, 17 Jul 2021 10:07:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/70/</guid>
      <description>原题链接
class Solution { public: int climbStairs(int n) { if (n == 1) return 1; if (n == 2) return 2; int p1 = 1, p2 = 2; int p3 = p1 + p2; while(n--&amp;gt; 3) { p1 = p2; p2 = p3; p3 = p1 + p2; } return p3; } }; 官方题解果然还是有数学方法&amp;hellip;不管他了&amp;hellip;</description>
    </item>
    
    <item>
      <title>69. x 的平方根</title>
      <link>https://engineers.cool/leetcode/leetcode/69/</link>
      <pubDate>Sat, 17 Jul 2021 10:06:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/69/</guid>
      <description>原题链接
看上去是数学题，但是并不知道数学上求平方根的方法。可以使用二分法进行搜索：
class Solution { public: int mySqrt(int x) { if (x == 0 || x == 1) return x; int l = 1, r = x/2; int ans = 1; while (l &amp;lt;= r) { long long mid = l+(r-l)/2; long long mul = mid*mid; if (mul == x) { return mid; } else if (mul &amp;gt; x) { r = mid-1; } else { ans = mid; l = mid+1; } } return ans !</description>
    </item>
    
    <item>
      <title>67. 二进制求和</title>
      <link>https://engineers.cool/leetcode/leetcode/67/</link>
      <pubDate>Sat, 17 Jul 2021 10:05:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/67/</guid>
      <description>原题链接
模拟即可，值得注意的一点是，不用每次往ans的头部加字符，可以先往尾部加字符，最后再reverse一下：
class Solution { public: string addBinary(string a, string b) { string ans; int idx_a = a.length()-1, idx_b = b.length()-1; int carry = 0; while (idx_a &amp;gt;= 0 || idx_b &amp;gt;= 0) { int v_a = idx_a &amp;gt;= 0 ? a[idx_a] - &amp;#39;0&amp;#39;: 0; int v_b = idx_b &amp;gt;= 0 ? b[idx_b] - &amp;#39;0&amp;#39;: 0; int v_n = v_a + v_b + carry; carry = v_n / 2; ans.push_back(&amp;#39;0&amp;#39;+ (v_n%2)); idx_a--; idx_b--; } if (carry) { ans.</description>
    </item>
    
    <item>
      <title>66. 加一</title>
      <link>https://engineers.cool/leetcode/leetcode/66/</link>
      <pubDate>Sat, 17 Jul 2021 10:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/66/</guid>
      <description>原题链接
从后向前遍历，做加一操作即可：
class Solution { public: vector&amp;lt;int&amp;gt; plusOne(vector&amp;lt;int&amp;gt;&amp;amp; digits) { int idx = digits.size()-1; while (idx &amp;gt;= 0) { digits[idx]++; if (digits[idx]/10 == 0) // 不能进位直接返回  return digits; // 进位到下一轮  digits[idx--] %= 10; } reverse(digits.begin(), digits.end()); digits.push_back(1); reverse(digits.begin(), digits.end()); return digits; } }; </description>
    </item>
    
    <item>
      <title>64. 最小路径和</title>
      <link>https://engineers.cool/leetcode/leetcode/64/</link>
      <pubDate>Sat, 17 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/64/</guid>
      <description>原题链接
又是动态规划，连姿势都跟前两道一样：
class Solution { public: int minPathSum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); for (int i = 1; i &amp;lt; m; i++) grid[i][0] += grid[i-1][0]; for (int j = 1; j &amp;lt; n; j++) grid[0][j] += grid[0][j-1]; for (int i = 1; i &amp;lt; m; i++) for (int j = 1; j &amp;lt; n; j++) grid[i][j] += min(grid[i-1][j], grid[i][j-1]); return grid[m-1][n-1]; } }; </description>
    </item>
    
    <item>
      <title>63. 不同路径 II</title>
      <link>https://engineers.cool/leetcode/leetcode/63/</link>
      <pubDate>Sat, 17 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/63/</guid>
      <description>原题链接
这回真的要用动态规划了：
class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { int dp[100][100]; memset(dp, 0, sizeof(int)*100*100); int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0; for (int i = 1; i &amp;lt; m; ++i) dp[i][0] = obstacleGrid[i][0] == 0 ? dp[i-1][0] : 0; for (int j = 1; j &amp;lt; n; ++j) dp[0][j] = obstacleGrid[0][j] == 0 ? dp[0][j-1] : 0; for (int i = 1; i &amp;lt; m; ++i) for (int j = 1; j &amp;lt; n; ++j) if (obstacleGrid[i][j] == 0) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } }; </description>
    </item>
    
    <item>
      <title>62. 不同路径</title>
      <link>https://engineers.cool/leetcode/leetcode/62/</link>
      <pubDate>Sat, 17 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/62/</guid>
      <description>原题链接
一开始是想用数学的思路解题，奈何数学太差。。。最后换思路用动态规划（入参m,n足够小）：
 dp[i][j]表示从点0,0到点i,j的所有可能路径数 初始化dp[0][0~n-1]与dp[0~m-1][0] 循环计算其他点，dp[i][j] = dp[i-1][j] + dp[i][j-1]  class Solution { public: int uniquePaths(int m, int n) { int dp[100][100]; memset(dp, 0, sizeof(int)*100*100); dp[0][0] = 1; for (int i = 0; i &amp;lt; m; ++i) dp[i][0] = 1; for (int j = 0; j &amp;lt; n; ++j) dp[0][j] = 1; for (int i = 1; i &amp;lt; m; ++i) for (int j = 1; j &amp;lt; n; ++j) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } }; 官方题解中有数学解法的思路：</description>
    </item>
    
    <item>
      <title>61. 旋转链表</title>
      <link>https://engineers.cool/leetcode/leetcode/61/</link>
      <pubDate>Sat, 17 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/61/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { ListNode* dummy = new ListNode(0, head); ListNode* tail = nullptr; int len = 0; for (auto iter = dummy-&amp;gt;next; iter !</description>
    </item>
    
    <item>
      <title>59. 螺旋矩阵 II</title>
      <link>https://engineers.cool/leetcode/leetcode/59/</link>
      <pubDate>Fri, 16 Jul 2021 10:04:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/59/</guid>
      <description>原题链接
思路跟前面54题一样，我最开始写的是逐步模拟:
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generateMatrix(int n) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans(n, vector&amp;lt;int&amp;gt;(n, 0)); int pos_i = 0, pos_j = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{0,1},{1,0},{0,-1},{-1,0}}; int dir = 0; int idx = 1, max_idx = n*n; while (idx &amp;lt;= max_idx) { ans[pos_i][pos_j] = idx; int nxt_i = pos_i + dirs[dir][0]; int nxt_j = pos_j + dirs[dir][1]; if (nxt_i &amp;gt;= n || nxt_i &amp;lt; 0 || nxt_j &amp;gt;= n || nxt_j &amp;lt; 0 || ans[nxt_i][nxt_j] !</description>
    </item>
    
    <item>
      <title>58. 最后一个单词的长度</title>
      <link>https://engineers.cool/leetcode/leetcode/58/</link>
      <pubDate>Fri, 16 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/58/</guid>
      <description>原题链接
总是喜欢用一个大循环解决问题:
class Solution { public: int lengthOfLastWord(string s) { int ans = 0; bool start_word = false; for (int i = s.length()-1; i &amp;gt;= 0; --i) { if (start_word) { if (s[i] != &amp;#39; &amp;#39;) { ans++; } else { break; } } else { if (s[i] == &amp;#39; &amp;#39;) continue; else { start_word = true; ans++; } } } return ans; } }; 看了别人的代码才发现有更好的编码实现:
class Solution { public: int lengthOfLastWord(string s) { int ans = 0; int end = s.</description>
    </item>
    
    <item>
      <title>57. 插入区间</title>
      <link>https://engineers.cool/leetcode/leetcode/57/</link>
      <pubDate>Thu, 15 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/57/</guid>
      <description>原题链接
先二分查找，找到插入的位置，然后把插入位置前的interval复制到ans，最后按56题的样子把newInterval和剩余的intervals插入到ans:
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; insert(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, vector&amp;lt;int&amp;gt;&amp;amp; newInterval) { if (intervals.size() == 0) { return {newInterval}; } int left = 0, right = intervals.size()-1; int insert_pos = -1; while (left &amp;lt;= right) { int mid = left + (right-left)/2; insert_pos = mid; if (intervals[mid][0] == newInterval[0]) { break; } else if (intervals[mid][0] &amp;gt; newInterval[0]) { right = mid-1; cout &amp;lt;&amp;lt; &amp;#34;big &amp;#34; &amp;lt;&amp;lt; endl; } else { left = mid+1; insert_pos = left; cout &amp;lt;&amp;lt; &amp;#34;little &amp;#34; &amp;lt;&amp;lt; endl; } } cout &amp;lt;&amp;lt; insert_pos &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; right &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; left &amp;lt;&amp;lt; endl; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; int intervals_start = 0; if (insert_pos == 0) ans.</description>
    </item>
    
    <item>
      <title>56. 区间合并</title>
      <link>https://engineers.cool/leetcode/leetcode/56/</link>
      <pubDate>Tue, 13 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/56/</guid>
      <description>原题链接
bool cmp(vector&amp;lt;int&amp;gt;&amp;amp; a, vector&amp;lt;int&amp;gt;&amp;amp; b) { if (a[0] &amp;lt; b[0]) return true; else if (a[0] == b[0]) return a[1] &amp;lt; b[1]; return false; } class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; merge(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals) { sort(intervals.begin(), intervals.end(), cmp); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; int start_now = intervals[0][0]; int end_now = intervals[0][1]; for (int i = 1; i &amp;lt; intervals.size(); ++i) { auto&amp;amp; interval = intervals[i]; if (end_now &amp;gt;= interval[0]) { end_now = max(end_now, interval[1]); } else { ans.</description>
    </item>
    
    <item>
      <title>55. 跳跃游戏</title>
      <link>https://engineers.cool/leetcode/leetcode/55/</link>
      <pubDate>Tue, 13 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/55/</guid>
      <description>原题链接
简单的贪心即可，前面有一道类似的题（45. 跳跃游戏 II）：
class Solution { public: bool canJump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int max_pos = 0; for (int i = 0; i &amp;lt;= max_pos; i++) { max_pos = max(max_pos, i+nums[i]); if (max_pos &amp;gt;= nums.size()-1) { return true; } } return false; } }; </description>
    </item>
    
    <item>
      <title>54. 螺旋矩阵</title>
      <link>https://engineers.cool/leetcode/leetcode/54/</link>
      <pubDate>Tue, 13 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/54/</guid>
      <description>原题链接
逐层模拟输出，边界条件比较难：
class Solution { public: vector&amp;lt;int&amp;gt; spiralOrder(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int n = matrix.size()-1; int m = matrix[0].size()-1; vector&amp;lt;int&amp;gt; ans; int i = 0; while (i &amp;lt; min((m+1)/2, (n+1)/2)) { for (int y = i; y &amp;lt;= m-i; ++y) { int x = i; ans.push_back(matrix[x][y]); } for (int x = i+1; x &amp;lt;= n-i; ++x) { int y = m-i; ans.push_back(matrix[x][y]); } for (int y = m-1-i; y &amp;gt;= i; --y) { int x = n-i; ans.</description>
    </item>
    
    <item>
      <title>53. 最大子序和</title>
      <link>https://engineers.cool/leetcode/leetcode/53/</link>
      <pubDate>Mon, 12 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/53/</guid>
      <description>原题链接
贪心思路:
class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = INT_MIN; int sum = 0; for (int i = 0; i &amp;lt; nums.size(); ++i) { if (sum + nums[i] &amp;lt; 0) { sum = max(nums[i], 0); ans = max(ans, nums[i]); } else { sum += nums[i]; ans = max(sum, ans); } } return ans; } }; 官方的方法一思路一样，但是简洁很多
class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int ans = nums[0]; int sum = 0; for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>50. Pow(x, n)</title>
      <link>https://engineers.cool/leetcode/leetcode/50/</link>
      <pubDate>Sun, 11 Jul 2021 10:03:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/50/</guid>
      <description>原题链接
快速幂，只是有这个概念，记得前面有一题的写法如下，按印象搬出：
class Solution { // unordered_map&amp;lt;int, double&amp;gt; power_vis; public: double myPow(double x, int n) { bool neg_power = n &amp;lt; 0 ? true : false; long long power = n &amp;lt; 0 ? -(long long)n : n; double powered = quickPower(x, power); return neg_power ? 1/powered : powered; } private: double quickPower(double x, int n) { if (n == 0) { return 1; } else if (n == 1) { return x; } long long now_n = 1; double now_x = x; while (now_n+now_n &amp;lt;= n) { now_n += now_n; now_x *= now_x; } return now_x * quickPower(x, n-now_n); } }; 官方提供的标准快速幂（递归）：</description>
    </item>
    
    <item>
      <title>49. 字母异位词分组</title>
      <link>https://engineers.cool/leetcode/leetcode/49/</link>
      <pubDate>Sun, 11 Jul 2021 10:02:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/49/</guid>
      <description>原题链接
给每个字符串计算特征值，字母异位词的特征值要一样，然后把特征值一样的放在一起。
计算方法有两种：
 给字符串排序，排序后的字符串即为特征值 给字符串做字符统计，统计后转换成字符串（或者hash值）即为特征值  class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; ans; unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; cated_strs; for (auto&amp;amp; str: strs) { string cate = calcCate(str); cated_strs[cate].emplace_back(str); } for (auto&amp;amp; item : cated_strs) ans.emplace_back(item.second); return ans; } private: string calcCate(string&amp;amp; str) { string cate; vector&amp;lt;int&amp;gt; count(26, 0); for (auto&amp;amp; c : str) { count[c-&amp;#39;a&amp;#39;]++; } for (int i = 0; i &amp;lt; 26; ++i) { cate.push_back(count[i]); } return cate; } }; </description>
    </item>
    
    <item>
      <title>48. 旋转图像</title>
      <link>https://engineers.cool/leetcode/leetcode/48/</link>
      <pubDate>Sun, 11 Jul 2021 10:01:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/48/</guid>
      <description>原题链接
模拟即可AC：
class Solution { public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int scan_len = matrix.size() -1; while (scan_len &amp;gt;= 1) { int x = (matrix.size()-scan_len-1)/2; for (int i = 0; i &amp;lt; scan_len; ++i) { int y = x+i; spanMatrix(x, y, matrix); } scan_len -= 2; } } private: void spanMatrix(int x, int y, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { int len = matrix.size(); int tmp = matrix[x][y]; matrix[x][y] = matrix[len-y-1][x]; matrix[len-y-1][x] = matrix[len-x-1][len-y-1]; matrix[len-x-1][len-y-1] = matrix[y][len-x-1]; matrix[y][len-x-1] = tmp; } }; </description>
    </item>
    
    <item>
      <title>47. 全排列 II</title>
      <link>https://engineers.cool/leetcode/leetcode/47/</link>
      <pubDate>Sun, 11 Jul 2021 10:00:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/47/</guid>
      <description>原题链接
跟46. 全排列大体一样的思路，只是在选当前位置的数字时，增加一个visited存储，防止重复：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; DFS(0, nums, ans); return ans; } private: void DFS(int idx, vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (idx == nums.size()) { ans.push_back(nums); return; } set&amp;lt;int&amp;gt; vis; for (int i = idx; i &amp;lt; nums.size(); ++i) { if (vis.count(nums[i])) { continue; } vis.insert(nums[i]); swap(nums[i], nums[idx]); DFS(idx+1, nums, ans); swap(nums[i], nums[idx]); } } }; 官方题解：因为需要保持有序（为了不重复），单独维护了组合结果数字，填充组合数组时，同样的数字确保顺序填入，这样就防止了重复的组合：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permuteUnique(vector&amp;lt;int&amp;gt;&amp;amp; nums) { sort(nums.</description>
    </item>
    
    <item>
      <title>46. 全排列</title>
      <link>https://engineers.cool/leetcode/leetcode/46/</link>
      <pubDate>Sun, 11 Jul 2021 09:59:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/46/</guid>
      <description>原题链接
回溯（DFS）即可：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;bool&amp;gt; vis(6, false); vector&amp;lt;int&amp;gt; dfs_state; DFS(nums, vis, dfs_state, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;bool&amp;gt; &amp;amp; vis, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (dfs_state.size() == nums.size()) { ans.push_back(dfs_state); return; } for (int i = 0; i &amp;lt; nums.size(); ++i) { if (vis[i]) continue; dfs_state.push_back(nums[i]); vis[i] = true; DFS(nums, vis, dfs_state, ans); dfs_state.pop_back(); vis[i] = false; } } }; 官方题解思路一样，但是代码更干净，不用独立维护当前状态（原入参维护即可）：</description>
    </item>
    
    <item>
      <title>45. 跳跃游戏 II</title>
      <link>https://engineers.cool/leetcode/leetcode/45/</link>
      <pubDate>Sun, 11 Jul 2021 09:58:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/45/</guid>
      <description>原题链接
直观的思路，DP思想，用dp[i]表示跳到i的最小跳数，然后用i结点更新能跳到的位置的dp值：
// 368ms class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); vector&amp;lt;int&amp;gt; dp(len, INT_MAX); dp[0] = 0; for (int i = 0; i &amp;lt; len; ++i) { int steps = nums[i]; for (int j = 1; j &amp;lt;= steps &amp;amp;&amp;amp; i+j &amp;lt; len; ++j) { dp[i+j] = min(dp[i+j], dp[i]+1); } } return dp[len-1]; } }; 上述代码执行时耗368ms，有一个简单的优化：如果这个结点跳的最远点的dp值不能被本次优化，这次就不用遍历优化了：
// 36ms class Solution { public: int jump(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.</description>
    </item>
    
    <item>
      <title>43. 字符串相乘</title>
      <link>https://engineers.cool/leetcode/leetcode/43/</link>
      <pubDate>Sun, 11 Jul 2021 09:57:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/43/</guid>
      <description>原题链接
直观的思路是模拟乘法竖式，乘数的从右到左的每一位与被乘数相乘，然后相加，得到答案；注意不要漏了进位：
class Solution { public: string multiply(string num1, string num2) { if (num1 == &amp;#34;0&amp;#34; || num2 == &amp;#34;0&amp;#34;) return &amp;#34;0&amp;#34;; if (num2.length() &amp;gt; num1.length()) swap(num1, num2); string ans; int idx1 = num1.length()-1, idx2 = num2.length()-1; int carry = 0; for (int idx2 = num2.length()-1; idx2 &amp;gt;= 0; --idx2) { int step = num2.length()-1-idx2; string step_product = stepProduct(num1, num2[idx2], step); ans = sumStepProduct(ans, step_product); } return ans; } private: string stepProduct(string num1, char factor, int step) { string ans; int factor_n = factor-&amp;#39;0&amp;#39;; if (factor_n == 0) return &amp;#34;0&amp;#34;; if (factor_n == 1) return num1 + string(step, &amp;#39;0&amp;#39;); int idx1 = num1.</description>
    </item>
    
    <item>
      <title>40. 组合总和 II</title>
      <link>https://engineers.cool/leetcode/leetcode/40/</link>
      <pubDate>Sun, 11 Jul 2021 09:56:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/40/</guid>
      <description>原题链接
又是一道DFS题，注意点是不选idx是要不选所有idx一样的数字，否则会有重复的组合出现：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum2(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_state; DFS(candidates, 0, dfs_state, target, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int idx, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, int target, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (target == 0) { ans.push_back(dfs_state); return; } else if (idx &amp;gt;= candidates.size()) { return; } // 选idx  if (candidates[idx] &amp;lt;= target) { dfs_state.push_back(candidates[idx]); DFS(candidates, idx+1, dfs_state, target-candidates[idx], ans); dfs_state.pop_back(); } // 不选idx  while (++idx &amp;lt; candidates.</description>
    </item>
    
    <item>
      <title>39. 组合总和</title>
      <link>https://engineers.cool/leetcode/leetcode/39/</link>
      <pubDate>Sun, 11 Jul 2021 09:55:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/39/</guid>
      <description>原题链接
标准的回溯算法：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { sort(candidates.begin(), candidates.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; vector&amp;lt;int&amp;gt; dfs_state; DFS(candidates, 0, dfs_state, target, ans); return ans; } private: void DFS(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int start, vector&amp;lt;int&amp;gt;&amp;amp; dfs_state, int target, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; ans) { if (target == 0) { ans.push_back(dfs_state); return; } else if (start &amp;gt;= candidates.size()) { return; } for (int i = start; i &amp;lt; candidates.size(); ++i) { if (candidates[i] &amp;gt; target) break; dfs_state.</description>
    </item>
    
    <item>
      <title>38. 外观数列</title>
      <link>https://engineers.cool/leetcode/leetcode/38/</link>
      <pubDate>Sun, 11 Jul 2021 09:54:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/38/</guid>
      <description>原题链接
朴素的模拟思想：
class Solution { public: string countAndSay(int n) { int now_cnt = 1; string now_str = &amp;#34;1&amp;#34;; while (now_cnt &amp;lt; n) { now_cnt++; now_str = readstr(now_str); } return now_str; } private: string readstr(string&amp;amp; s) { string read_str = &amp;#34;&amp;#34;; char now_c = s[0]; int now_cnt = 1; for (int i = 1; i &amp;lt; s.length(); ++i) { if (s[i] == now_c) { now_cnt++; continue; } read_str.append(to_string(now_cnt)).push_back(now_c); now_c = s[i]; now_cnt = 1; } read_str.</description>
    </item>
    
    <item>
      <title>36. 有效的数独</title>
      <link>https://engineers.cool/leetcode/leetcode/36/</link>
      <pubDate>Sun, 11 Jul 2021 09:53:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/36/</guid>
      <description>原题链接
 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）  数独部分空格内已填入了数字，空白格用 &amp;lsquo;.&amp;rsquo; 表示。
 顺序遍历每个格子，检查&amp;amp;&amp;amp;更新这个格子分别在三种情况维护的状态即可：
class Solution { vector&amp;lt;long long&amp;gt; vis = vector&amp;lt;long long&amp;gt;(27); public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int n = board.size(); for (int i = 0; i &amp;lt; n; ++i) { for (int j = 0; j &amp;lt; n; ++j) { if (board[i][j] == &amp;#39;.&amp;#39;) continue; if (updateNum(i, j, board[i][j]-&amp;#39;0&amp;#39;)) continue; return false; } } return true; } private: bool updateNum(int x, int y, int num) { vector&amp;lt;int&amp;gt; update_pos = {x, y+9, x/3+(y/3)*3+18}; long long base = 1; for (int pos : update_pos) { if (vis[pos] &amp;amp; (base&amp;lt;&amp;lt;num)) return false; vis[pos] |= (base&amp;lt;&amp;lt;num); } return true; } }; </description>
    </item>
    
    <item>
      <title>35. 搜索插入位置</title>
      <link>https://engineers.cool/leetcode/leetcode/35/</link>
      <pubDate>Sun, 11 Jul 2021 09:52:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/35/</guid>
      <description>原题链接
 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
 标准的二分查找
class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size()-1; while (l &amp;lt;= r) { int mid = l+(r-l)/2; if (nums[mid] == target) { return mid; } else if (nums[mid] &amp;lt; target) { l = mid+1; } else if (nums[mid] &amp;gt; target) { r = mid-1; } } return l; } }; </description>
    </item>
    
    <item>
      <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://engineers.cool/leetcode/leetcode/34/</link>
      <pubDate>Sun, 11 Jul 2021 09:51:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/34/</guid>
      <description>原题链接
 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
 class Solution { public: vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { return {leftBound(nums, target), rightBound(nums, target)}; } private: int leftBound(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int l = 0, r = nums.size()-1; while (l &amp;lt;= r) { int mid = l + (r-l)/2; if (nums[mid] == target) { r = mid-1; } else if (nums[mid] &amp;lt; target) { l = mid+1; } else { // nums[mid] &amp;gt; target  r = mid-1; } } if (l &amp;gt;= nums.</description>
    </item>
    
    <item>
      <title>33. 搜索旋转排序数组</title>
      <link>https://engineers.cool/leetcode/leetcode/33/</link>
      <pubDate>Sun, 11 Jul 2021 09:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/33/</guid>
      <description>原题描述
先找到最小的数字，然后截成两节做二分查找：
class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int len = nums.size(); if (len == 1) return nums[0] == target ? 0 : -1; // 先找到最小值  int s = 0, e = len-1; int smallest_idx = -1; while (s &amp;lt;= e) { int mid = (s+e)/2; if (isSmallest(nums, mid)) { smallest_idx = mid; break; } if (s == mid) { ++s; } else if (e == mid) { ++e; } else if (nums[s] &amp;lt; nums[mid] &amp;amp;&amp;amp; nums[e] &amp;lt; nums[mid]) { s = mid+1; } else { e = mid-1; } } int result = binarySearch(nums, 0, smallest_idx-1, target); if (result !</description>
    </item>
    
    <item>
      <title>31. 下一个排列</title>
      <link>https://engineers.cool/leetcode/leetcode/31/</link>
      <pubDate>Sat, 10 Jul 2021 09:50:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/31/</guid>
      <description>原题描述
两层循环遍历：
 第一层倒叙枚举 会被冒泡到的位置（P1）(即第一个顺序的元素) 第二层倒叙枚举 冒泡的元素的位置（即第一个大于位置P1元素的位置P2） 然后交换，并重排 P1~结尾 的元素（从小大大）  class Solution { public: void nextPermutation(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); // 枚举冒到的位置  for (int up_tartget = len-2; up_tartget &amp;gt;= 0; --up_tartget) { // 找可以冒上去的数字  for (int up_idx = len-1; up_idx &amp;gt; up_tartget; --up_idx) { if (nums[up_idx] &amp;lt;= nums[up_tartget]) continue; // 找到了！  // 交换 然后后面那段重新排序  int tmp = nums[up_idx]; nums[up_idx] = nums[up_tartget]; nums[up_tartget] = tmp; sort(nums.</description>
    </item>
    
    <item>
      <title>29. 两数相除</title>
      <link>https://engineers.cool/leetcode/leetcode/29/</link>
      <pubDate>Sat, 10 Jul 2021 09:45:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/29/</guid>
      <description>原题描述
下面是一开始的朴素思想：
 判断结果是整数还是负数 循环 对被除数 减去（加上） 除数，直到被除数绝对值小于除数绝对值  class Solution { public: int divide(int dividend, int divisor) { if (dividend == INT_MIN &amp;amp;&amp;amp; divisor == -1) return INT_MAX; bool is_not_same_sign = (dividend&amp;amp;(1&amp;lt;&amp;lt;31)) ^ (divisor&amp;amp;(1&amp;lt;&amp;lt;31)); int ans = 0; int big_divisor = divisor; while (fabs(dividend) &amp;gt; fabs(divisor)) { if (is_not_same_sign) dividend += divisor; else dividend -= divisor; ++ans; } return ans; } }; 问题在于，在除数比较小的时候，步骤2效率太低。需要对这个步骤增速，由于限制了乘法那么一个好的增速方法是加法，加法翻倍，指数级增速：
class Solution { public: int divide(int dividend, int divisor) { // 边界情况  if (divisor == 1) return dividend; if (divisor == -1) { if (dividend == INT_MIN) return INT_MAX; return -dividend; } bool is_not_same_sign = (dividend&amp;amp;(1&amp;lt;&amp;lt;31)) ^ (divisor&amp;amp;(1&amp;lt;&amp;lt;31)); int sign = is_not_same_sign ?</description>
    </item>
    
    <item>
      <title>28. 实现strStr()</title>
      <link>https://engineers.cool/leetcode/leetcode/28/</link>
      <pubDate>Sat, 10 Jul 2021 09:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/28/</guid>
      <description>原题描述
?&amp;gt; 为什么这道题是&amp;quot;简单&amp;quot;&amp;hellip;没学过的话 肯定完全搞不出来吧！
class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; vector&amp;lt;int&amp;gt; next(needle.length()); gen_next(needle, next); int m = 0; int p = 0; while (m &amp;lt; haystack.length() &amp;amp;&amp;amp; p &amp;lt; needle.length()) { if (haystack[m] == needle[p]) { ++m; ++p; } else if (p) { p = next[p-1]; } else { ++m; } } if (p == needle.length()) { return m-p; } return -1; } private: void gen_next(string&amp;amp; pattern, vector&amp;lt;int&amp;gt;&amp;amp; next) { next[0] = 0; int p = 1; int now = 0; while (p &amp;lt; pattern.</description>
    </item>
    
    <item>
      <title>27. 移除元素</title>
      <link>https://engineers.cool/leetcode/leetcode/27/</link>
      <pubDate>Sat, 10 Jul 2021 09:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/27/</guid>
      <description>原题描述
跟上一题一样，快慢&amp;quot;指针&amp;quot;：
class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int slow = 0, fast = 0; while(fast &amp;lt; nums.size()) { if (nums[fast] != val) nums[slow++] = nums[fast]; ++ fast; } return slow; } }; 优化思路：操作数据结构是数据，假设极端情况只有第一个元素要删除，这样还用方法一做顺序遍历的话，会有很多次Copy。那么，优化思路就是第二个&amp;quot;指针&amp;quot;从后向前遍历：
class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { int start = 0, end = nums.size()-1; while(start &amp;lt;= end) { if (nums[start] != val) { ++start; continue; } if (nums[end] != val) nums[start++] = nums[end]; --end; } return start; } }; </description>
    </item>
    
    <item>
      <title>26. 删除有序数组中的重复项</title>
      <link>https://engineers.cool/leetcode/leetcode/26/</link>
      <pubDate>Sat, 10 Jul 2021 09:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/26/</guid>
      <description>原题描述
双指针：
class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int len = nums.size(); if (len == 0) { return 0; } int slow = 0, fast = 0; while (++fast &amp;lt; len) { if (nums[fast] == nums[slow]) continue; nums[++slow] = nums[fast]; } return slow+1; } }; </description>
    </item>
    
    <item>
      <title>24. 两两交换链表中的结点</title>
      <link>https://engineers.cool/leetcode/leetcode/24/</link>
      <pubDate>Sat, 10 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/24/</guid>
      <description>原题描述
思路：
 定义两个指针，指向要交换的两个结点签名 如果可以交换，则操作first-&amp;gt;next / second-&amp;gt;next-&amp;gt;next指针进行交换，以及递推 如果不可以交换，则保持现状  /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* dummy = new ListNode(0, head); ListNode* first = head; ListNode* second = dummy; while(first) { second-&amp;gt;next = first-&amp;gt;next; if (second-&amp;gt;next) { first-&amp;gt;next = second-&amp;gt;next-&amp;gt;next; second-&amp;gt;next-&amp;gt;next = first; } else { second-&amp;gt;next = first; } second = first; first = first-&amp;gt;next; } ListNode* ans = dummy-&amp;gt;next; delete dummy; return ans; } }; 跟上题一样，我的思路总是递推，官方题解还有一种递归思路（写起来更简单 也更容易理解）：</description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/22/</link>
      <pubDate>Sat, 10 Jul 2021 09:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/22/</guid>
      <description>原题描述
标准的回溯（DFS）算法：
class Solution { public: vector&amp;lt;string&amp;gt; generateParenthesis(int n) { vector&amp;lt;string&amp;gt; gen_brackets; string dfs_str; DFS(dfs_str, 0, 0, n, gen_brackets); return gen_brackets; } private: void DFS(string&amp;amp; dfs_str, int left, int right, int n, vector&amp;lt;string&amp;gt;&amp;amp; gen_brackets) { if (left == n &amp;amp;&amp;amp; right == n) { // 或者判断 dfs_str.size() ==n*2  gen_brackets.push_back(dfs_str); return; } if (left &amp;lt; n) { dfs_str.push_back(&amp;#39;(&amp;#39;); DFS(dfs_str, left+1, right, n, gen_brackets); dfs_str.pop_back(); } if (right &amp;lt; left) { dfs_str.</description>
    </item>
    
    <item>
      <title>20. 有效的括号</title>
      <link>https://engineers.cool/leetcode/leetcode/20/</link>
      <pubDate>Sat, 10 Jul 2021 09:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/20/</guid>
      <description>原题描述
用栈辅助配对即可，注意获取栈顶前要先判断是否为空。
class Solution { unordered_map&amp;lt;char, char&amp;gt; right_to_left = { {&amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;}, {&amp;#39;]&amp;#39;, &amp;#39;[&amp;#39;}, {&amp;#39;}&amp;#39;, &amp;#39;{&amp;#39;}, }; bool isRightBracket(const char c) const{ return right_to_left.count(c); } public: bool isValid(string s) { if (s.length()%2) return false; stack&amp;lt;char&amp;gt; brackets; for (auto c : s) { if (isRightBracket(c)) { if (brackets.empty() || brackets.top() != right_to_left[c]) { return false; } else { brackets.pop(); } } else { brackets.push(c); } } return brackets.empty(); } }; </description>
    </item>
    
    <item>
      <title>21. 合并两个有序链表</title>
      <link>https://engineers.cool/leetcode/leetcode/21/</link>
      <pubDate>Sat, 10 Jul 2021 09:33:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/21/</guid>
      <description>原题描述
基于归并排序的思想，merge两个链表即可：
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0, nullptr); ListNode* merge_tail = dummy; while (l1 || l2) { int v1 = l1 ?</description>
    </item>
    
    <item>
      <title>19. 删除链表的倒数第N个结点</title>
      <link>https://engineers.cool/leetcode/leetcode/19/</link>
      <pubDate>Sat, 10 Jul 2021 09:32:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/19/</guid>
      <description>原题描述
链表，无法下表访问，只能遍历，那么删除倒数第N个结点，只需要遍历两边就好了：
 第一次遍历，得到链表的长度 第二次遍历，删除第（len-n+1）个结点  但是题目表示中有表示：
?&amp;gt; 进阶：你能尝试使用一趟扫描实现吗？
看过题解后才发现，官方是想让我们继续强化双指针的思路：
 设计两个指针，第一个先行N个结点 随后两个指针一起遍历，第一个指针遍历到结尾的时候，删除第二个指针的next元素  另外题解中有两个比较好的建议：
  设计dummy结点，指向head，随后对链表的操作就不用特殊处理head结点了 因为要删除结点，这里确认下是否要求删除改结点的内存   /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0, head); ListNode* first = head; ListNode* second = dummy; for (int i = 0; i &amp;lt; n &amp;amp;&amp;amp; first; ++i) { first = first-&amp;gt;next; } while (first) { first = first-&amp;gt;next; second = second-&amp;gt;next; } //ListNode* delete_node = second-&amp;gt;next  second-&amp;gt;next = second-&amp;gt;next-&amp;gt;next; // delete delete_node;  ListNode* ans = dummy-&amp;gt;next; delete dummy; return ans; } }; </description>
    </item>
    
    <item>
      <title>18. 四数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/18/</link>
      <pubDate>Sat, 10 Jul 2021 09:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/18/</guid>
      <description>原题描述
完全类比15. 三数之和与16. 最接近的三数之和，排序然后双指针遍历最后两个：
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinations; if (nums.size() &amp;lt; 4) return combinations; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i!=0 &amp;amp;&amp;amp; nums[i]==nums[i-1]) continue; for (int j = i+1; j &amp;lt; nums.size(); ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j]==nums[j-1]) continue; int k = j+1, l = nums.size()-1; while (k &amp;lt; l) { long long sum_now = (long long)nums[i]+(long long)nums[j]+(long long)nums[k]+(long long)nums[l]; if (sum_now == (long long)target) { combinations.</description>
    </item>
    
    <item>
      <title>17. 电话号码的字母组合</title>
      <link>https://engineers.cool/leetcode/leetcode/17/</link>
      <pubDate>Sat, 10 Jul 2021 09:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/17/</guid>
      <description>原题描述
简单回溯（DFS）题目，预先构建好数字到可选字幕的映射：
class Solution { const vector&amp;lt;string&amp;gt; num_to_chars = { &amp;#34;&amp;#34;/*0*/,&amp;#34;&amp;#34;/*1*/,&amp;#34;abc&amp;#34;,&amp;#34;def&amp;#34;,&amp;#34;ghi&amp;#34;,&amp;#34;jkl&amp;#34;,&amp;#34;mno&amp;#34;,&amp;#34;pqrs&amp;#34;,&amp;#34;tuv&amp;#34;,&amp;#34;wxyz&amp;#34; }; public: vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if (digits.size() == 0) { return {}; } vector&amp;lt;string&amp;gt; ans; string dfs_str; DFS(digits, 0, dfs_str, ans); return ans; } private: void DFS(string digits, int deep, string dfs_str, vector&amp;lt;string&amp;gt;&amp;amp; ans) { if (deep &amp;gt;= digits.size()) { ans.push_back(dfs_str); return; } char now_deep_char = digits[deep]; for (auto c : num_to_chars[now_deep_char-&amp;#39;0&amp;#39;]) { dfs_str.push_back(c); DFS(digits, deep+1, dfs_str, ans); dfs_str.</description>
    </item>
    
    <item>
      <title>16. 最接近的三数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/16/</link>
      <pubDate>Fri, 09 Jul 2021 09:31:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/16/</guid>
      <description>原题链接
class Solution { public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int ans = INT_MAX; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i!=0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; for (int j = i+1; j &amp;lt; nums.size()-1; ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1]) continue; // search k  int target_k_val = target -(nums[i]+nums[j]); int nearest_k_val = findNearest(nums, j+1, nums.size(), target_k_val); int nearest_val = nums[i]+nums[j]+nearest_k_val; ans = selectNearest(target, nearest_val, ans); } } return ans; } private: int findNearest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int idx_s, int idx_e, int target) { // hack improve  if (nums[idx_s] &amp;gt; target) return nums[idx_s]; if (nums[idx_e-1] &amp;lt; target) return nums[idx_e-1]; int nearest_val = INT_MAX; while(idx_s &amp;lt; idx_e) { int mid = (idx_s+idx_e)/2; nearest_val = selectNearest(target, nearest_val, nums[idx_s]); nearest_val = selectNearest(target, nearest_val, nums[mid]); if (nums[mid] == target) { return nums[mid]; } else if (nums[mid] &amp;gt; target) { idx_e = mid; } else if (nums[mid] &amp;lt; target) { idx_s = mid+1; } }; return nearest_val; } int selectNearest(int target, int v1, int v2) { return fabs((target-v1) &amp;lt; fabs((long long)target-(long long)v2) ?</description>
    </item>
    
    <item>
      <title>15. 三数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/15/</link>
      <pubDate>Fri, 09 Jul 2021 09:30:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/15/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans; sort(nums.begin(), nums.end()); for (int i = 0; i &amp;lt; nums.size(); ++i) { if (i != 0 &amp;amp;&amp;amp; nums[i] == nums[i-1]) continue; int k = nums.size()-1; for (int j = i+1; j &amp;lt; nums.size()-1; ++j) { if (j!=i+1 &amp;amp;&amp;amp; nums[j] == nums[j-1]) continue; int sum = -1; while(j&amp;lt;k &amp;amp;&amp;amp; (sum = nums[i]+nums[j]+nums[k]) &amp;gt; 0) { --k; } if (j == k) break; if (sum == 0) { ans.</description>
    </item>
    
    <item>
      <title>14. 最长公共前缀</title>
      <link>https://engineers.cool/leetcode/leetcode/14/</link>
      <pubDate>Wed, 07 Jul 2021 09:44:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/14/</guid>
      <description>原题链接
class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if (strs.size() == 0) return &amp;#34;&amp;#34;; string comm_prefix; int idx = 0; while (true) { if (idx &amp;gt;= strs[0].size()) { break; } bool all_same_char = true; char this_char = strs[0][idx]; for (auto str : strs) { if (idx &amp;gt;= str.size() || this_char != str[idx]) { all_same_char = false; break; } } if (all_same_char) comm_prefix.push_back(this_char); else break; idx++; } return comm_prefix; } }; </description>
    </item>
    
    <item>
      <title>13. 罗马数字转整数</title>
      <link>https://engineers.cool/leetcode/leetcode/13/</link>
      <pubDate>Wed, 07 Jul 2021 09:43:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/13/</guid>
      <description>原题链接
class Solution { public: int romanToInt(string s) { unordered_map&amp;lt;char, int&amp;gt; roman_val = { {&amp;#39;I&amp;#39;, 1}, {&amp;#39;V&amp;#39;, 5}, {&amp;#39;X&amp;#39;, 10}, {&amp;#39;L&amp;#39;, 50}, {&amp;#39;C&amp;#39;, 100}, {&amp;#39;D&amp;#39;, 500}, {&amp;#39;M&amp;#39;, 1000}, }; int val = 0; int last_roman_val = 1000; for (auto c : s) { int v = roman_val[c]; val += v &amp;lt;= last_roman_val ? v : (last_roman_val*-2+v); last_roman_val = v; } return val; } }; </description>
    </item>
    
    <item>
      <title>12. 整数转罗马数字</title>
      <link>https://engineers.cool/leetcode/leetcode/12/</link>
      <pubDate>Wed, 07 Jul 2021 09:42:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/12/</guid>
      <description>原题链接
class Solution { public: string intToRoman(int num) { string roman; vector&amp;lt;pair&amp;lt;int, string&amp;gt;&amp;gt; case_reps = { {1000, &amp;#34;M&amp;#34;}, {900, &amp;#34;CM&amp;#34;}, {500, &amp;#34;D&amp;#34;}, {400, &amp;#34;CD&amp;#34;}, {100, &amp;#34;C&amp;#34;}, {90, &amp;#34;XC&amp;#34;}, {50, &amp;#34;L&amp;#34;}, {40, &amp;#34;XL&amp;#34;}, {10, &amp;#34;X&amp;#34;}, {9, &amp;#34;IX&amp;#34;}, {5, &amp;#34;V&amp;#34;}, {4, &amp;#34;IV&amp;#34;}, {1, &amp;#34;I&amp;#34;} }; for (auto case_rep : case_reps) { while(num &amp;gt;= case_rep.first) { num -= case_rep.first; roman += case_rep.second; } } return roman; } }; </description>
    </item>
    
    <item>
      <title>11. 盛最多水的容器</title>
      <link>https://engineers.cool/leetcode/leetcode/11/</link>
      <pubDate>Wed, 07 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/11/</guid>
      <description>原题链接
核心思路：减少搜索空间。指针每一次移动，都意味着排除掉了一个柱子。
为什么可以安全排除这跟柱子呢？
从最两端的柱子考虑，如果固定较短的柱子不动，那么不管怎么动另外一根，都不会有更大的答案出现；那么较短的柱子在剩余问题（剩余可能结果）的解决就完全没有作用了，可以丢弃；
class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int start = 0, end = height.size()-1; int area = 0; while(start &amp;lt; end) { area = max(area, (end-start)*min(height[start], height[end])); if (height[start] &amp;gt; height[end]) { end--; } else { start++; } } return area; } }; </description>
    </item>
    
    <item>
      <title>9. 回文数</title>
      <link>https://engineers.cool/leetcode/leetcode/9/</link>
      <pubDate>Wed, 07 Jul 2021 09:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/9/</guid>
      <description>原题链接
class Solution { public: bool isPalindrome(int x) { if (x &amp;lt; 0) return 0; string l_r, r_l; while(x) { int v = x%10; x /= 10; string s(1, &amp;#39;0&amp;#39;+v); l_r = s + l_r; r_l = r_l + s; } return r_l == l_r; } }; 还是太年轻了。官方方法是反转一半数字然后跟剩余未反转部分做比较：
class Solution { public: bool isPalindrome(int x) { // 特殊情况增加，末尾是0的非零输入 直接返回false  if (x &amp;lt; 0 || (x%10 == 0 &amp;amp;&amp;amp; x !</description>
    </item>
    
    <item>
      <title>8. 字符串转换整数 (atoi) </title>
      <link>https://engineers.cool/leetcode/leetcode/8/</link>
      <pubDate>Tue, 06 Jul 2021 21:41:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/8/</guid>
      <description>原题链接
按描述编码的模拟题，貌似没有什么要注意的点。
class Solution { public: int myAtoi(string s) { int ans = 0; int idx = 0; // 丢弃无用的前导空格  while(idx &amp;lt; s.size() &amp;amp;&amp;amp; s[idx] == &amp;#39; &amp;#39;) idx++; if (idx &amp;gt;= s.size()) { return 0; } // 扫描正负符号  bool is_neg = false; if (s[idx] == &amp;#39;-&amp;#39;) { is_neg = true; idx++; } else if (s[idx] == &amp;#39;+&amp;#39;) { idx++; } // 扫描接下来的数字  while(idx &amp;lt; s.size() &amp;amp;&amp;amp; isdigit(s[idx])) { int v = s[idx] - &amp;#39;0&amp;#39;; v = is_neg ?</description>
    </item>
    
    <item>
      <title>7. 整数反转</title>
      <link>https://engineers.cool/leetcode/leetcode/7/</link>
      <pubDate>Tue, 06 Jul 2021 21:40:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/7/</guid>
      <description>原题链接
整体思路比较明确：循环取数字的最后一位，加到反转数字的后面（预先判断加上去会不会溢出，溢出则返回0）。
class Solution { public: int reverse(int x) { int new_val = 0; while (x) { int n = x%10; // 取到case数字的最后一位  x /= 10; // case数字去掉最后一位  // 加往新数字前，判断是否会溢出  if (new_val &amp;lt; nearly_overflow_min || new_val &amp;gt; nearly_overflow_max) { return 0; // } else if (new_val == nearly_overflow_min &amp;amp;&amp;amp; n &amp;lt; nearly_overflow_min_append) {  // return 0;  // } else if (new_val == nearly_overflow_max &amp;amp;&amp;amp; n &amp;gt; nearly_overflow_max_append) {  // return 0;  } new_val = new_val*10+n; // 加到反转数字上  } return new_val; } private: int nearly_overflow_min = (1&amp;lt;&amp;lt;31)/10; // int nearly_overflow_min_append = (1&amp;lt;&amp;lt;31)%10;  int nearly_overflow_max = (~(1&amp;lt;&amp;lt;31))/10; // int nearly_overflow_max_append = (~(1&amp;lt;&amp;lt;31))%10;  }; 比较有意思的是判断溢出，我原本的想法是，有以下三种溢出的情况：</description>
    </item>
    
    <item>
      <title>6. Z 字形变换</title>
      <link>https://engineers.cool/leetcode/leetcode/6/</link>
      <pubDate>Tue, 06 Jul 2021 21:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/6/</guid>
      <description>原题链接
读完题后，首先把题示的例子手算一下，然后就想着找规律。确实也有规律，但是代码写出来难懂。
class Solution { public: string convert(string s, int numRows) { if (numRows == 1) return s; int delta = numRows*2-2; string ans; for (int i = 0; i &amp;lt; numRows; ++i) { for (int j = 0; j + i &amp;lt; s.size(); j += delta) { ans += s[j + i]; if (i == 0 || i == numRows-1) continue; if (j + delta - i &amp;lt; s.size()) ans += s[j + delta - i]; } } return ans; } }; 看了题解后，其实有一个朴素的思路，就是按题目的描述，遍历字符串按Z字形拼接到各行，最后再把所有行拼接起来即可。</description>
    </item>
    
    <item>
      <title>5. 最长回文子串</title>
      <link>https://engineers.cool/leetcode/leetcode/5/</link>
      <pubDate>Tue, 06 Jul 2021 20:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/5/</guid>
      <description>原题链接
朴素的，从回文串的定义考虑，中心对称的串，那么从中心向外扩张遍历即可；枚举每个中心（考虑 奇偶），向外遍历即可。
唯一要注意的点是，回文串可以是偶数长度，即中心的两个字符一样，一起为中心。
class Solution { public: string longestPalindrome(string s) { int start = 0, end = 0; for (int p = 0; p &amp;lt; s.size(); ++p) { auto [start1, end1] = expandStr(p, p, s); auto [start2, end2] = expandStr(p, p+1, s); if (end1-start1 &amp;gt; end-start) { start = start1; end = end1; } if (end2-start2 &amp;gt; end-start) { start = start2; end = end2; } } return s.substr(start, end-start+1); } private: pair&amp;lt;int, int&amp;gt; expandStr(int l, int r, const string&amp;amp; s) { while(l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; s.</description>
    </item>
    
    <item>
      <title>3. 无重复字符的最长子串</title>
      <link>https://engineers.cool/leetcode/leetcode/3/</link>
      <pubDate>Sun, 04 Jul 2021 20:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/3/</guid>
      <description>原题链接
官方的解法 &amp;amp;&amp;amp; 我的思路，滑动窗口，稍微有些不同：
 官方解法是遍历起点，额外记录终点；  在遍历中，把前一字符从集合去掉，然后while扩展终点，直到有重复字符；   我的思路是遍历终点，额外记录起点；  在遍历中，把当前字符加到集合，while从起点缩减字符，直到没有重复字符；    本质一样，都是滑动窗口，
class Solution { public: int lengthOfLongestSubstring(string s) { int max_substr_len = 0; unordered_set&amp;lt;char&amp;gt; flag; int s_len = s.length(); int cur_substr_start_pos = 0; // 当前无重复字符子串的起点  for (int i = 0; i &amp;lt; s_len; ++i) { // 遍历终点  while (flag.find(s[i]) != flag.end()) { // 以当前字符为重点，缩减起点开始的字符，直到没有重复字符  flag.erase(s[cur_substr_start_pos]); cur_substr_start_pos += 1; } // 记录当前字符到集合，并更新答案  flag.</description>
    </item>
    
    <item>
      <title>2. 两数相加</title>
      <link>https://engineers.cool/leetcode/leetcode/2/</link>
      <pubDate>Sun, 04 Jul 2021 10:34:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/2/</guid>
      <description>原题链接
/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode * head = nullptr, * tail = nullptr; int carry = 0; // 加法进位  while(l1 || l2) { int val1 = l1 ?</description>
    </item>
    
    <item>
      <title>1. 两数之和</title>
      <link>https://engineers.cool/leetcode/leetcode/1/</link>
      <pubDate>Mon, 21 Jun 2021 09:49:00 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/leetcode/1/</guid>
      <description>原题链接
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int, int&amp;gt; hashtable; int nums_size = nums.size(); for (int idx = 0; idx &amp;lt; nums_size; ++idx) { int other_value = target - nums[idx]; if (hashtable.count(other_value) == 1) { return {hashtable[other_value], idx}; } hashtable[nums[idx]] = idx; } return {}; } }; </description>
    </item>
    
    <item>
      <title>总结</title>
      <link>https://engineers.cool/leetcode/summery/</link>
      <pubDate>Fri, 03 Jul 2020 08:13:53 +0800</pubDate>
      
      <guid>https://engineers.cool/leetcode/summery/</guid>
      <description>随便找的一个面试题出现次数  206. 反转链表 146. LRU缓存机制 8. 字符串转换整数（atoi） 153. 寻找旋转排序数组中的最小值 3. 无重复自负的最长子串 剑指Offer 54. 二叉搜索树的第k大结点 300. 最长上升子序列 2. 两数相加 470. 用Rand7()实现Rand10() 112. 路径总和  旋转数据查找 二分查找框架 int binary_search(int[] nums, int target) { int left = 0, right = nums.length - 1; while(left &amp;lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] &amp;lt; target) { left = mid + 1; } else if (nums[mid] &amp;gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回  return mid; } } // 直接返回  return -1; } int left_bound(int[] nums, int target) { int left = 0, right = nums.</description>
    </item>
    
  </channel>
</rss>
